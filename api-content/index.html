{"posts":[{"title":"Oracle 的 循环实例","content":" 好久没有整 Oracle 了，最近因为数据库服务器需要腾挪空间，所以这个本来DBA干的事情，又落到了我这个万金油的头上🤦‍♂️。 折腾了几天，终算是有些明白了... 各种工具链也相对有些熟悉了，还算顺利的把备份做了，用户表删了。数据泵导出、表空间压缩、表空间扩容，都做了一遍，算是有点基础的 DBA 能力了🤦‍♂️... 本文是写给同事看的 Oracle 循环； 在开始学习循环之前，有以下几个概念，可以先了解： 1. 字符串拼接 我们使用循环，是为了节省我们的代码数量，提高编写SQL的效率，所以首先我们就需要把 SQL 语句作为字符串进行拼接处理。在oracle中，用'字符串'，来表示这是一个字符串，而 拼接字符串： 'select column '||变量a||' from table;' 通过||（英文输入下，按住shift + 回车键上面那个键打出）来连接变量与字符串，如果变量的值是 column2 那么这个字符串就会是： 'select column colmn2 from table;' 所以我只需要将一列数据传入，这个字符串就会动态的变化： 'select column colmn3 from table;' 'select column colmn4 from table;' 'select column colmn5 from table;' 注意事项1 ⚠️: 在' 和 || 之间要注意空格的使用，字符串中的空格是有效的，字符串外的空格可能是无效的； 注意事项2 ⚠️：在字符串内如果想要使用'，那么是通过'' 两个单引号表示； 2.显示自己循环的代码以及 执行字符串内的sql代码 2.1 显示循环的效果： Oracle 中可以使用 sys.dbms_output.put_line() （括内填入需要显示的内容）的方式来查看代码，这样方便在编写循环时，更加具体的查看到自己的循环结构。 在Navicat 中，可以通过 「DBMS 导出」标签看到输出的内容。 2.2 执行这个字符串 通过EXECUTE IMMEDIATE执行语句 注意事项3⚠️： 是没有() 的哦。 具体的关于 EXECUTE IMMEDIATE的用法参考： EXECUTE IMMEDIATE用法小结 3. 具体的 for 循环语句 基本的结构： BEGIN for i in 1 .. 10 loop sys.dbms_output_line('循环到数字' || i) end loop; END BEGIN ... END : 包裹住这么个 SQL 语句块，说明这段代码按照块来执行； for i in 1 .. 10 loop ... end loop: foor 到第一个 loop , 表示 i 是1开始，一直取到10（.. 表示范围），这个区间是闭合的，1和10都能取到，所以这个 i 会以次变成 1、2、3、4、5… 带入到下面的代码中； loop 到 end loop 表示具体的对循环执行的代码； 实例：循环添加数字 —— 依次添加column_201到column_ 304的的变量 BEGIN for i in 201 .. 304 loop execute immediate 'select column_|| i || 'form table' end loop; END 这样就可以动态的选取了选区了，不过这个语句会有 100 多个结果，实际中肯定不会这种使用： 下例，为表空间添加237-274的dbf文件： 实例：循环某个查询到临时表其中的一列 这应该是更加实用的： BEGIN for v_cur in (select t.user_name from user_table_qy t where group_id ='qy') loop execute immediate 'drop table' ||v_cur.user_name|| ' purge'; end loop; END 首先：for v_cur in (select t.user_name from user_table_qy t where group_id ='qy') loop 表示，v_cur 是后面这个语句的结果，虽然只有一个变量，但它还是一张表，所以在执行语句时 v_cur.user_name 就表示 user_name 这一列，所以会依次去执行drop table 操作。 ","link":"https://hwang.top/post/oracle-de-xun-huan-shi-li/"},{"title":"Try Nest.js —— 学习笔记","content":" 用到啥学啥系列 其实也是为了另一个小项目写一个小后端。 推荐参考 -&gt; 去这看吧，非常清楚： https://tc9011.com/2019/07/14/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/ 1. 什么是 Nest.js Nestjs 是 Node 渐进式框架，底层默认使用 express（可以通过 Adapter 转换到 fastify），可以使用 express 或者 fastify 所有中间件，完美支持 TypeScript。熟悉 Spring 和 Angular 的同学可以很快上手 Nestjs，它大量借鉴了 Spring 和 Angular 中的设计思想 2. 核心理念 Dependency Injection (DI)，一般翻译为 依赖注入； Inversion of Control （loC），控制反转：主要用降低代码耦合度；相当于是用一个中转的函数来抽象原来类里面需要的变量，这样就实现了耦合度的降低。 在 nest.js中，通过 @Injectable() 装饰器来像 loC 容易注册。 模块化：Module 把controller、service和pipe等打包成内聚的功能块，每个模块聚焦于一个特性区域、业务领域、工作流或通用工具。 每个属于这个模块的controller、service等都需要在这个模块中注册，如果需要引入其他模块或者第三方模块，需要将它注册到imports，通过exports可以将相应的service、module等共享出去。 在 nest.js中，通过 @Module() 装饰器来像声明一个模块； AOP, 面向切片编程（Aspect Oriented Programming），主要有这么几个切片： Middlewares：中间键 Guards：Guards 和前端路由中的路由守卫一样，主要确定请求是否应该由路由处理程序处理。通过守卫可以知道将要执行的上下文信息，所以和 middleware 相比，守卫可以确切知道将要执行什么。 Interceptors (在流被操纵之前)：可以给每一个需要执行的函数绑定，拦截器将在该函数执行前或者执行后运行。可以转换函数执行后返回的结果，扩展基本函数行为等。 Pipes：是具有 @Injectable() 装饰器的类，并实现了 PipeTransform 接口。通常 pipe 用来将输入数据转换为所需的输出或者处理验证。 参数验证等内容 Interceptors (在流被操纵之后) Exception filters (如果发现任何异常)：内置的 Exception filters 负责处理整个应用程序中的所有抛出的异常，也是 Nestjs 中在 response 前，最后能捕获异常的机会。 DTO：数据访问对象简称DTO（Data Transfer Object）， 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。 ORM ：是”对象-关系映射”（Object/Relational Mapping） 的缩写，通过实例对象的语法，完成关系型数据库的操作。通过 ORM 就可以用面向对象编程的方式去操作关系型数据库。 在 Java 中，常用 DAO （Data Access Object， 数据访问对象）层来进行各种数据库的操作。DAO 主要作用是分离业务层与数据层，避免业务层与数据层耦合。 Nest.js 中可以使用 typeORM 为 DAO 层，支持MySQL / MariaDB / Postgres / CockroachDB / SQLite / Microsoft SQL Server / Oracle / MongoDB / NoSQL。在 typeORM 中数据库的表对应的就是一个类，通过定义一个类来创建实体。实体（Entity）是一个映射到数据库表（或使用 MongoDB 时的集合）的类，通过@Entity()来标记，具体的： import {Entity, PrimaryGeneratedColumn, Column} from &quot;typeorm&quot;; @Entity() export class User { @PrimaryGeneratedColumn() id: number; @Column() firstName: string; @Column() lastName: string; @Column() age: number; } //上面代码将创建以下数据库表： //+-------------+--------------+----------------------------+ //| user | //+-------------+--------------+----------------------------+ //| id | int(11) | PRIMARY KEY AUTO_INCREMENT | //| firstName | varchar(255) | | //| lastName | varchar(255) | | //| isActive | boolean | | //+-------------+--------------+----------------------------+ // 使用 @InjectRepository() 修饰器注入 对应的Repository，就可以在这个Repository对象上进行数据库的一些操作。 import { Injectable } from '@nestjs/common'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository } from 'typeorm'; import { User } from './user.entity'; @Injectable() export class UserService { constructor( @InjectRepository(User) private readonly userRepository: Repository&lt;User&gt;, ) {} async findAll(): Promise&lt;User[]&gt; { return await this.userRepository.find(); } } 3. 上手 hello world ！ 安装： $ npm install -g @nestjs/cli $ nest new my-awesome-app 启动 $ npm start 自此，通过http://loaclhost:3000 就可以看到 Hello World 了。 4. Controller 在 Nest.js 中 Contraller 负责处理传入的请求，并调用对应的 service 完成处理，返回对客户端的响应，可以通过 CLI 来创建 controller： $nest g co [your-cintroller] 这时候，CLI 会自动生成 controller 文件，并且把 controller 注册到对应的 module 中。 并且和其他一些 node 框架不一样，Nestjs 路由不是集中式管理，而是分散在 controller 中，通过@controller()中声明的（可选）前缀和请求装饰器中指定的任何路由来确定的。 import { Controller, Get } from '@nestjs/common'; import { CatsService } from './cats.service'; @Controller('cats') export class CatsController { constructor(private readonly catsService: CatsService) { } @Get(':id') findOne(@Param('id') id: string): string { return this.catsService.getCat(); } } 上面这段代码中，通过 Get 请求去请求http://localhost:3000/cats/1就会调用findOne方法。如果需要调整，添加前缀，可以在 main.ts 中使用 GlobalPrefix 设置： import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); app.setGlobalPrefix('api/v1'); await app.listen(3000); } bootstrap(); 5. Service 在 Nest.js 中，controller 就像是调用 service 的指挥者，把对应的请求分发到相应的 service 中去处理。在 controller 中，我们注意到，在构造函数中注入了CatsService实例，来调用对应 service 中的方法。这就是 Nest.js 中依赖注入的注入方式 — 构造函数注入。service 可以看做夹在 controller 和 model 之间的一层，在 service 调用 DAO （在 Nestjs 中是各种 ORM 工具或者自己封装的 DAO 层）实现数据库的访问，进行数据的处理整合。 import { Injectable } from '@nestjs/common'; @Injectable() export class CatsService { getCat(id: string): string { return `This action returns ${id} cats`; } } 上面代码中通过@Injectable()定义了一个 service，这样你就可以在其他 controller 或者 service 中注入这个 service。 参考：https://tc9011.com/2019/07/22/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/ ","link":"https://hwang.top/post/try-nestjs-xue-xi-bi-ji/"},{"title":"Try Electron记实（八）— 组件传参\\ Electron Node 模块支持问题 \\文件路径问题 ","content":" 是的，用的啥学啥系列。 传参，这是基础了，复习复习 父组件和子组件可以通过 props 获取，父组件发送的形式是用bind(用缩写:)绑定值到子组件身上。然后子组件用属性props接收。 子组件传值父组件，首先是子组件发送 this.$emit，父组件on监听的方法，然后父组件通过@事件名=获取值的方法。 兄弟组件一般通过 bus 进行传递，就是建立一个公共区域的组件。 使用 electron-rebuild 来重新编译 Node 模块 官方文档：https://www.electronjs.org/docs/tutorial/using-native-node-modules // 安装electron-rebuild，不需要全局安装 npm install --save-dev electron-rebuild //执行命令 ./node_modules/.bin/electron-rebuild // 在windows下如果上述命令遇到了问题，尝试： ./node_modules/.bin/electron-rebuild.cmd 用 node 的path，读到的文件路径在electron 原来是不一样的... 今天在渲染进程中使用 fs.readSync() ，显然是不正确的。渲染进程的前端开发，项目文件会被webpack打包，自然不能这样用。 静态资源的引入： 1.静态资源如css,img，js,请放在根目录的static文件夹里， 因为electron打包后会复制一份static文件夹到dist文件夹中，这样项目引入的静态资源就不会报路径错误了。 electron 获取打包后 可执行文件 的文件路径 参考链接：https://stackoverflow.com/questions/46307797/how-to-get-the-original-path-of-a-portable-electron-app app.getAppPath() 获取文件的路径，例如 c:\\desktop\\win-ia32-unpacked\\resources\\app.asar Node.js 的__dirname，获取的路径： c:\\desktop\\win-ia32-unpacked\\resources\\app.asar\\dist\\electron process.execPath ，获取的路径c:\\desktop\\win-ia32-unpacked\\xxx.exe process.cwd() ， 获取的路径c:\\desktop\\win-ia32-unpacked ","link":"https://hwang.top/post/try-electron-ji-shi-ba-zu-jian-chuan-can-electron-node-mo-kuai-zhi-chi-wen-ti-wen-jian-lu-jing-wen-ti/"},{"title":"Try Electron记实（七）— 先学习 Vue.js 实现拖拽再应用到 electron 中","content":" 是的，用的啥学啥系列。 参考：https://www.jianshu.com/p/873512cdbd0f 首先，ant-design 是提供了 a-upload 组件，用于上传的，但是不幸的是，前端一般是拿不到真实的本机路径的。所以简单考虑后，决定直接写一个通过 Electron API 的方法的上传框。 Vue.js 里面怎么做 1. 涉及的时间 dragenter、dragover、drop 事件 当把文件拖动到浏览器的拖动区域时，会触发三种事件： 文件第一次进入拖动区时，触发 dragenter 事件 文件在拖动区来回拖拽时，不断触发 dragover 事件 文件已经在拖动区，并松开鼠标时，触发 drop 事件 实现拖动上传，我们只需要关心 drop 事件。不过另外两个事件也需要监听，目的是阻止浏览器默认行为。如果不阻止，那么把文件拖到浏览器时，浏览器就会自动下载这个文件（默认行为），drop 事件触发不出来。 所以要做的就是阻止默认的事件。需要再 mounted 挂载后处理。（有点不懂，mounted 不是加载完了吗？ Vue 不推荐直接操作 DOM 元素，是不是可以直接用 v-on 绑定到 methods 里面。） 接着就是再 methods 对象中写函数。具体参见文章，写的比较清楚，包括进度条如何实现都有的。 2. 具体到 Electron 中 在electron 中： 为了让用户能够通过HTML5的file API直接操作本地文件，DOM的File接口提供了对本地文件的抽象。Electron在File接口中增加了一个path属性，它是文件在系统中的真实路径。 而这个 path 属性就是我需要的。 其中，methods： methods: { onDrag: function(e) { e.stopPropagation(); e.preventDefault(); }, onDrop: function(e) { e.stopPropagation(); e.preventDefault(); let file = e.dataTransfer.files[0]; console.log('path-&gt;', file.path); } } 这里，使用 e.stopPropagation()、e.preventDefault()来阻止默认的行为。 我也直接在&lt;div&gt; 标签上使用 v-on 进行绑定，并没有什么问题。 3. 利用 ipcRenderer 模块，打开文件选择框 我选择的方式是使用 remote 模块直接打开文件夹，代码片段如下： const dialog = require('electron').remote.dialog; dialog.showOpenDialog({ properties: ['openFile']}).then((file) =&gt;{ if (file.filePaths.length === 1) { this.fileSelected = file.filePaths[0]; console.log(this.fileSelected); } }) 使用 remote.dialog，调用主进程内的 electron 模块，获取文件路径即可。 ","link":"https://hwang.top/post/try-electron-ji-shi-qi-xian-xue-xi-vuejs-shi-xian-tuo-zhuai-zai-ying-yong-dao-electron-zhong/"},{"title":"Try Electron记实（六）— Vue 的 Mixins 混入  / 小知识补习：` import ` 与 `import {}`","content":"Mixins 混用 **用途：**用于Vue组件中，可复用的功能；一个 Mixins 对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混入”该组件中。 理解： 利用 Vue 的方式实现组件的功能的自由服用与组合。 官方示例，一看就懂： // 定义一个混入对象 var myMixin = { created: function () { this.hello() }, methods: { hello: function () { console.log('hello from mixin!') } } } // 定义一个使用混入对象的组件 var Component = Vue.extend({ mixins: [myMixin] }) var component = new Component() // =&gt; &quot;hello from mixin!&quot; **一些特性： ** 同名的情况： 同名的钩子函数将被合并为一个数组，因此会被一起调用。Mixins 的钩子将先被执行； 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 更多信息：https://cn.vuejs.org/v2/guide/mixins.html 小知识补习：import 与 import {} 一般情况下，其实是需要 import {} from xxx，但是一般的模块都会设置： 至于为什么能 import lodash from 'lodash' 是因为，为了给用户提供方便，lodash 用到export default 命令，为模块指定了默认输出，让lodash 的使用者不用阅读文档就能用任意自定义模块名加载 lodash。 所以，import lodash from 'lodash' 这句，你喜欢的话也能写成import _ from 'lodash' 其次，from` 后面的 'lodash' 为什么不是 node_modules里 lodash的完整路径呢（ / node_modules / .bin / lodash ），是因为你的项目里 npm 帮忙做了配置呀，自动帮它加了前缀，一般补全模块路径是这事是npm帮做的。 ","link":"https://hwang.top/post/try-electron-ji-shi-liu-vue-de-mixins-hun-ru-xiao-zhi-shi-bu-xi-import-yu-import/"},{"title":"Hwang Reading List - New 07","content":" 注：链接是 IFTTT 生成的，可能需要科学的上网方式，才能够访问 中国企业获设计“剽窃奖”被质疑 近日，一则中国制造商包揽德国“金鼻子剽窃奖”前十名的消息引发关注。中国设计是否存在山寨外国设计再次引发热议。 为什么DevOps很好，但却很难落地，大家对DevOps是怎么理解的？ 关于 DevOps 为什么难落地，与其我们在这里闭门造车，倒不如看看来自专家的看法 为什么进度条永远卡在 99%？ 机密处万籁俱寂，防守严格，他一路破解密码，悄声潜入，没料到 U 盘一插电脑，警报就开始厉声鸣叫，门外死神般的脚步纷至沓来，踩得他浑身汗如雨下。 阿里巴巴发布全新奥运组合LOGO！仅用9根线“托”起五环！ 微信号 AlibabaDesign 功能介绍 这是一个充满魅力的组织，是一群疯狂热爱用户体验的家伙；这里有国际音乐家、有舞者、游戏玩家、摄影师以及各个领域的爱好者；我们坚信，创新、设计、技术和客户第一的价值观粘合在一起， 2020，我想如何讲述自己的故事——2019总结 12月的 Monthly Review 已经做了2019年终总结的播客有声版，加上2019半年总结也写了，总感觉下半年应该没什么值得记录。而且一直没有想清楚2020年的目标和展望，想通过整理成文字版的过程给自己一些灵感。 2019，小程序又给了谁机会？ 以上是宏观的生态数据，透过这些数据，我们不免会有一个疑惑：是谁承担起了这些流量？ iPhone 可有设计哲学？ iPhone 4G 出来之前，注定会有更多强大，快速，激动人心的新设备来挑战智能手机的巅峰 : 3GS 。 2019 创业回顾 2019 公司人数 +1 -1，最后是四个人。还是蛮多人知道会惊讶一下，你们只有四个人？两个运营，加一个全能工程师，加我（还有两只猫）。 2019 我做了什么 虽然维护的项目有保持健康的成长，但没有做什么新东西 2020 打算投入更多的时间在开源项目上，不再怠惰于现有项目的日常维护，而是做一些新东西，（可能）有 DPlayer 重构、Telegram Bot 平台、RSS 客户端等 刘慈欣：中国变成民主体制会是人间地狱 断章取义通常有危险。但刘慈欣在接受《纽约客》采访时的这几段话已经刻板八股到了 caricature 的程度，断章与否其实没有任何区别了。采访是樊嘉扬做的，所以说的应该是普通话。 钉钉 Dark Mode 设计 微信号 AlibabaDesign 功能介绍 这是一个充满魅力的组织，是一群疯狂热爱用户体验的家伙；这里有国际音乐家、有舞者、游戏玩家、摄影师以及各个领域的爱好者；我们坚信，创新、设计、技术和客户第一的价值观粘合在一起， ","link":"https://hwang.top/post/hwang-reading-list-new-07/"},{"title":"Try Electron记实（五）— 异步的一些东西 ：Promise 对象","content":" 参考资料：https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544 先吐槽，从来没有接触过 Promise 对象相关的东西，只知道 JS 的世界里，异步是一个非常重要的概念。今天写逻辑代码，第一次接触到了，因为 function 异步执行，想当然的以为 return 的就是给赋值的结果，结果因为异步并没有拿到最后的结果。 首先，关于 Promise 和 async/await ：https://zhuanlan.zhihu.com/p/23249103： 可以很明显的看到，callback 来控制异步的方式虽然非常简单，但也过于原始。在实际的使用中代码的逻辑顺序和业务的顺序是不相同的，错误控制基本靠手动检查err参数。 而到了 Promise 中这种情况好了很多，通过链式调用，Promise 可以直接在 then 中返回一个新的 Promise 来将异步操作串联起来，也有了统一的 catch 来做错误处理。美中不足的是，你仍然需要传递一个回调函数给 then，通过 then 来串联虽然保证了至少代码顺序上和真正的逻辑顺序一致，但和同步代码的差别仍然很大。 async/await 则直接将其变成了同步的写法，心智负担大大降低。 具体的： Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 then方法可以接受两个回调函数作为参数。 第一个回调函数是Promise对象的状态变为resolved时调用， 第二个回调函数是Promise对象的状态变为rejected时调用。 其中，第二个函数是可选的，不一定要提供。 这两个函数都接受Promise对象传出的值作为参数。 用法： const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); promise.then(function(value) { // success }, function(error) { // failure }); ","link":"https://hwang.top/post/try-electron-ji-shi-wu-yi-bu-de-yi-xie-dong-xi-promise-dui-xiang/"},{"title":"Try Electron记实（四）— 项目中添加路由","content":"通过路由的方式进行侧边导航栏的切换： 安装 vue-router，并添加到项目中； 在 main.js 中引入 vue-router 插件； ... ... //省略其他 import Router from 'vue-router' Vue.use(Router) 引入路由文件，并在 Vue 实例中添加配置 import router from '.'router/index' ...//省略其他 new Vue({ router: router, //添加配置 render: h =&gt; h(App), }).$mount('#app') 编辑路由文件router/index.js 中添加需要的路由路径 &lt;router-link to=&quot;&quot;&gt; 和 &lt;router-view&gt; 标签 一个是用来跳转的，一个是用来显示调整页面的。 Done！ 基础的路由添加步骤就是这样了。在其他具体的事情，具体在看吧。 ","link":"https://hwang.top/post/try-electron-ji-shi-si-xiang-mu-zhong-tian-jia-lu-you/"},{"title":"Try Electron记实（三）— ant-design-vue 主题的修改","content":"官方文档描述： 在 vue cli 3 中定制主题 项目根目录下新建文件vue.config.js // vue.config.js module.exports = { css: { loaderOptions: { less: { modifyVars: { 'primary-color': '#1DA57A', 'link-color': '#1DA57A', 'border-radius-base': '2px', }, javascriptEnabled: true } } } } 关于- vue.config.js : 每次在终端运行 vue-cli-service 时，都会先找到对应的 vue.config.js，获取到相关配置，才继续执行其它操作 动手试试 直接在项目跟目录添加这么一个配置文件即可。 因为 vue.config.js 是在 vue-cli-service 运行时检查的，所以在使用 electron-builder 构建的项目中，并不能热更新。 我的理解是，这个 vue-cli-service 启动后，才可以热更新 electron 的窗体程序和Vue写的前端页面的，热更新并不会重新启动一遍 vue-cli-service。 ","link":"https://hwang.top/post/try-electron-ji-shi-san-ant-design-vue-zhu-ti-de-xiu-gai/"},{"title":"Try Electron记实（二）— ant-design 的引入、font-awesome 的引入","content":" 简单记录一下； 有一点点的坑是引入 less 的事情，其他都挺顺利的； ant-design 和 font-awesome 的引入 引入，在 src/main.js 文件内引入： import Vue from 'vue'; import App from './App.vue'; import Antd from 'ant-design-vue'; import 'ant-design-vue/dist/antd.less'; import { library } from '@fortawesome/fontawesome-svg-core' import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome' import { 【需要的包】 } from '@fortawesome/free-solid-svg-icons' library.add( 【需要的包】 ) Vue.component('font-awesome-icon', FontAwesomeIcon) Vue.config.productionTip = false; Vue.use(Antd); new Vue({ render: h =&gt; h(App), }).$mount('#app') 其中，如果需要配置 ant 的主题 import 'ant-design-vue/dist/antd.less'; ``` 使用 less 配置主题。 ","link":"https://hwang.top/post/try-electron-ji-shi-er-ant-design-de-yin-ru-font-awesome-de-yin-ru/"},{"title":"关于团队协作工具的理想形态，这是我从飞书上得到的思考","content":"2017 年底，我加入我们导师的团队，开始创业。当我们人数达到 10 人时，我们也发现了，在微信上沟通工作时，总会出现： 沟通记录混乱：用过微信的大家都懂。 文件丢失，文件版本混乱：微信并不会负责你的文件存储。 共享信息沟通不畅：每当有新人入职时，许多问题需要重复解答。 项目管理不畅：各种任务环节很难被监控到。 这些问题频繁出现在前几个月，解决这些问题的任务被安排在了我身上，当时市面上能够选择的产品，主要可以分为「国内系」以及「海外系」。一家企业在日常业务中，普遍需要的，其实就是三大功能，团队沟通、信息资源管理、项目管理。无论是生产、研发还是销售环节，这三大基础需求都是存在的。一家企业根据他所处的领域的不同，企业的组织形式千差万别，对于这「三大基础需求」也是有显著的差异的。 更多内容前往少数派阅读：https://sspai.com/post/58385 ","link":"https://hwang.top/post/guan-yu-tuan-dui-xie-zuo-gong-ju-de-li-xiang-xing-tai-zhe-shi-wo-cong-fei-shu-shang-de-dao-de-si-kao/"},{"title":"figma 的一些快捷键","content":" command + option +v 样式全部复制 command + 1/2 切换图层和组件库 shift + 1/2 放大当前 对象 command + option + G 创建 frame //我比较常用的 按住 option 从组件库中拖拽出组件，替换组件 / 按住 option + command 保持原有大小 option + L 合并图层 （为选中时，收起所有的 command+shift+K 批量添加图片 ","link":"https://hwang.top/post/figma-de-yi-xie-kuai-jie-jian/"},{"title":"疫情","content":"2020 这是一段比较难忘的记忆... 这里不会记录更多，但是在我的 Google Photo 里，记录了一切。 ","link":"https://hwang.top/post/yi-qing-ji-lu/"},{"title":"Try Electron 记实（一）","content":" 记录一下第一次正式开始写一个 Electron 应用； 基础比较差，几乎没什么基础... 开始一个 Electron 项目 使用 Vue-cli 3.0 以上，进行项目初始化； vue add electron-builder vue create . 运行这个项目： yarn electron:serve Done npm 常用参数记录 发现对 npm 的一些参数还不是很熟悉，记录一下； 基本的安装/卸载：npm install/uninstall [packegename] 其中安装这一部分，可选参数： --saveor -S：添加到生产环境的依赖 ; --save-dev or -D：添加到开发环境； --save-optional or -O： 添加到可选环境配置 （好像不太常用）； --save-exact or -E ：指定版本安装模块； 开始项目时一次性安装依赖包npm install 可选参数： --global or -g 全局安装； 卸载部分可选参数与安装时相同 卸载还可以使用：npm remove 、npm rm、npm r 、 npm un 、 npm unlink(unlink 与 link 好像是测试的) npm list/ll/la/ls 列出已安装的模块； npm outdated 列出需要更新的模块； npm update 更新依赖包，可选参数 --global or -g npm root 查看命令的绝对路径； npm config npm 的配配置 yarn 常用参数记录 顺便整理一下 yarn 的一些参数；yarn 用于固定开发中包的各种版本； yarn add yarn add [package]@[version] ``` 添加到生产环境中 - `--dev` or `-D` 安装到生产环境中 - 不常用的：`yarn global add &lt;package...&gt; ` 全局安装； yarn cache yarn cache dir： 列出当前的 yarn 全局缓存在哪里 yarn cache list --pattern &lt;pattern&gt; 列出匹配指定模式的已缓存的包。 yarn cache clean 清除全局缓存。 yarn list 默认情况下，所有包和它们的依赖会被显示。 --depth 深度参数 yarn remove 默认移除依赖，并更新 package.json 和 yarn.lock yarn run 运行定义的动作 yarn upgrade 更新升级包； yarn global bin 查看全局安装的目录 ","link":"https://hwang.top/post/try-electron-ji-shi-yi/"},{"title":"Electron 初试","content":"之前做的上传工具，打算用 electron 改做了。原先的使用 Pyside2 写的，软件写起来没什么问题，用起来也很舒服，但是打包的话就相对比较麻烦了，各种坑，Windows 可能还勉强能够应付一下，但是mac 版的资料属实能够找到的资料也不够多。 选择前 electron 主要是我司目前是有前端开发的，这样后续产品也能接上。 试试 election 的样例 clone了项目后，直接用： $ npm install 结果中间就卡住了，没有继续下载；大概是卡在 core-js 这个包的安装时候。 强制停止，然后删除 node-model 文件，再修改代理： $ npm config set registry https://registry.npm.taobao.org 然后在安装： $ npm install 嘿，好家伙，直接显示两个包没下。看了下还是 core-js；所以就只能用 cnpm 了。 下载 cnpm： $ npm install -g cnpm --registry=https://registry.npm.taobao.org 然后使用 cnpm： $ cnpm install $ cnpm start ","link":"https://hwang.top/post/election-chu-shi/"},{"title":"Hwang Reading List - New 06","content":" 注：链接是 IFTTT 生成的，可能需要科学的上网方式，才能够访问 真正提高效率：自定义你的 Touch Bar 自 2016 年 Touch Bar 在 MacBook Pro 上问世以来，对其最大的争议就是它并不能很好地提高用户的工作效率：Touch Bar 提供的大多数功能很容易使用键盘快捷键来实现，并且有些时候使用快捷键更加方便、符合直觉。 聊聊 GFW 如何封杀 Resilio Sync（BTSync）？以及如何【免翻墙】继续使用？ ★引子 最近一个多月，有好些读者抱怨 Resilio Sync（原名叫做“BitTorrent Sync”，简称“BTsync”）无法正常使用。所以俺一直打算写一篇来谈谈这个事情。顺便也分享一下：如何继续【免翻墙】使用 Resilio Sync。 第四范式戴文渊：机器写出1000万条以上规则，就超越了专家 为你推送和解读最前沿、最有料的科技创投资讯 培养大脑记忆力的第二次机会：「记忆神器」Anki 使用详解 阅读建议：本文基于 Anki for Mac，可以在 Anki 中国 上免费下载；本文涉及众多新概念，建议在 Anki 中国 下载一个共享的牌组，尝试文中提到的一些概念和操作。 用 Ai Search 和 Drafts 实现 Alfred 的搜索体验 这篇文章主要探讨的是一种结合 Ai Search 和 Drafts 进行快速网站搜索的方法。Ai Search 扮演的是一个搜索引擎库，而 Drafts 是提高调用搜索引擎效率的工具。文中方法的关键点在于键盘输入，搜索内容和选择搜索引擎的操作都可以 强大如怪物：顶级文本处理应用 Drafts 4 深度评测 虽然此前购买过旧版本的 Drafts，但在拿到手上最新版本的 Drafts 4 前，其实我并没有怎么好好使用它。倒并不是因为它不好用，而是因为它和另外一款相似的应用 Editorial 在我心里一直是两款「怪物」一般的文本输入类应用。因 这个在线协作工具，什么都能画 Matrix 是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。 企业微信3.0发布会，都讲了些什么？ 通过邹叔在现场拍的两张照片来看，企业微信最重要的改变就是：从拉新变成沉淀，从2B工具变成了帮助企业2C的工具。 克洛普的圣诞致辞：作为最幸运的红军人，这是骄傲难忘的一年 编者按：如往年一样，克洛普在圣诞节当天于利物浦官方发表了他的圣诞致辞，让我们来看看渣叔如何向大家分享这一年的感受。 Mac Pro 2019 Teardown Teardown of the reinvented 2019 Mac Pro, which returns to a properly repairable design that happens to not grate cheese very well. Performed December 2019. 2019：“暗黑”的一年 昨天，微信开放了安卓平台 7.0.10 版本的内部测试。安装之后，可以看到的一些小变化是多选信息、查看图片、视频等界面的微调。 Flypig | 自媒体时代的 “非虚构” 人生 微信号 DAZED_CHINA 功能介绍 《DAZED》杂志官方公众号。微博：@DazedChina 。 Hannah——舌尖后缩，轻触上颚然后落下，H-a-n-n-a-h，倒过来念也是如此。这是电影《降临》（Arrival, 2017）中语言学家Louise女儿的名字，故事的结尾又回到了 杭州 杭州是上海边上的一座城，说它“美丽”不足以形容它的风貌，说它“最适合人居住”又会让人误以为它房价便宜，所以很难找出一个词来概括它。 ","link":"https://hwang.top/post/hwang-reading-list-new-06/"},{"title":"Hwang Reading List - New 05","content":" 最近真就没怎么更新博客... 注：链接是 IFTTT 生成的，可能需要科学的上网方式，才能够访问 基于QTdesigner的PyQt编程 \\ 前面的教程中有讲过对于python自带的Tk模块的使用，实际上个人感觉Tk的使用不仅繁琐，而且做出来的界面并不美观，这里向大家推荐pyqt。 qyqt这个模块的最大优势在于界面可以使用qtdesigner直观的制作，然后代码直接读取就可以 Kindle 十二岁 \\ 两个多星期后的十一月十九日，就是 Kindle 的正式十二岁生日。正版电子书发展至今，对于我这种不住在英语国家但要看英文书的人带来了许多便利，但它在排版上依然远远劣于盗版 PDF（即远未达到平面出版的排版水平）。 知料 | 越薄越好？噼里啪啦的键盘是怎么成为苹果绊脚石的 \\ 蝶形键盘失败了，这一苹果曾力推的全新设计，在短暂四年后便狼狈退场。 极圈化 \\ 不知道从什么时候开始，阶层固化、鄙视链定序、圈内刻奇成了舆论热点的源头，这一部分是商业社会价格歧视的结果，一部分是分工后专业化的信息壁垒，另一部分则是本质上人群价值观割裂后产生的信息不对称与隔离。 我推荐的 RSS 订阅列表 \\ 每次推荐 RSS 阅读器，总有人条件反射地说「现在谁还用那个！」，令人生厌。但另一个条件反射式的反应非常合理：就算我装了 RSS 阅读器，里面一片空白，我该订什么呢？ ","link":"https://hwang.top/post/hwang-reading-list-new-05/"},{"title":"树莓派、Windows 设备都可以做你 Mac 的「时间机器」——利用 SMB 协议进行 Time Machine 备份","content":" 本文以发布于少数派：https://sspai.com/post/57539 推荐在少数派阅读 macOS 为用户提供了便捷的系统备份功能：Time Machine （你可以从少数派2015年的老文中学习使用这个功能：Time Machine 使用教程 ）。 一般而言，Time Machine 需要你连接一块硬盘到你的 Mac 上才能够启动。当然，你可以通过「有线连接」和「无线连接」的方式，进行备份。有线连接不再赘述，可以参考上面的教程。而无线连接，少数派上同样可以参考：把群晖 NAS 变成「时间返回舱」，轻松搞定 Time Machine 无线备份，而本文将介绍除了使用 NAS 以外，你还可以在任何能够使用 SMB 协议的设备上创建你的「时间机器」。 首先，SMB 协议是一种能够将本机电脑上的文件夹分享到局域网内其他设备上的一种协议。你可以简单的理解为是一种文件共享的协议。我们要做的就是通过这个协议，将主机上的某个文件共享到你的 Mac 上，然后在那上面创建备份。所以，我们需要的具体步骤就是：1. 通过 SMB 分享一个文件夹； 2. 在 Mac 上加载这个文件夹；3. 利用这个文件夹创建备份。 1. 通过 SMB 分享一个文件夹 这一步，我们需要做的事，具体而言就是： 开启 SMB 服务； 配置一个文件夹进行共享； 所以，正如标题里写的，无论是树莓派这种 Linux 设备，还是 Windows 设备，你都可以开启 SMB 服务，进行局域网内的文件的共享。所以，如果你有一台 Linux 设备，你可以参考下面的树莓派的步骤，如果你有一台 Windows 设备，可以参考 Windows 的步骤。 树莓派上开启 SMB 服务 详细内容，同样可以参考我派的文章：利用 Samba - 像管理本地文件一样处理树莓派文件。 首先，更新源： $ sudo apt-get update 第二步，安装 samba 服务： $ sudo apt-get install samba samba-common-bin 第三步，修改 SMB 的配置，这里使用 vim 进行编辑： $ sudo vim /etc/samba/smb.conf 在配置文件的最后添加： [pi] path = /home/pi/ valid users = pi browseable = Yes writeable = Yes writelist = pi create mask = 0777 directory mask = 0777 保存退出后，重启一下 samba 服务 $ sudo /etc/init.d/samba restart 最后一步，就是添加 pi 用户为 Samba用户，这一步，会让你设置共享时的密码。 $ sudo smbpasswd -a pi Windows 上开启 SMB 服务 Windows 上做 Smb 共享会方便很多，首先在一个磁盘空间比较富裕的地方，创建一个文件夹，然后右键，属性，打开「共享」栏： 然后点击共享，弹出用户设置界面： 设置共享的账户，以及权限设置为「读和写」，一般而言推荐在这里新建一个专门的共享账户，账户和密码就是届时需要在mac上输入的账户和密码： 账户设置完成后，点击「共享」即可： 点击完成，这个文件就已经能够在局域网访问了。这里做个简单的提醒，部分Windows设备的防火墙设置，会禁用共享，可以先通过关闭防火墙的方式来排除是不是防火墙的问题，再通过对应规则的设置，重新开启防火墙即可。 2. 在 Mac 上加载这个文件夹 这个时候，打开你的 finder，应该能够在「位置这一栏」下看到树莓派，或者你的 Windows 设备的名字了。点击后，就能看到你共享的文件夹了。 如果没有看到，那么通过右键 finder 图标，点击「连接服务器」，输入：smb://设备的IP地址/共享的文件夹名称 的方式连接，在输入账号密码后，也能够连接上这个文件夹。正确连接后，就说明，其他设备上的硬盘，已经能够为你的 Mac 所用了。 接下来我们就要进行最后一个步骤，创建一个「时间机器」了！ 3. 利用这个文件夹创建备份 当你兴奋的打开你的 Time Machine 设置，点击「选择备份磁盘」时，看到却是： 是的，并没有你想要的那个文件夹 接下来，我们要做的，其实是创建一个磁盘镜像文件，然后将这个磁盘镜像文件挂载到你的 Mac 上，作为一个「虚拟硬盘」，然后利用这个「虚拟硬盘」进行备份。具体的： 3.1 创建一个空白映像： 打开「磁盘工具」，选择菜单栏中的 「新建映像」，选择「空白映像…」，然后如图所示，填入信息： 其中「大小」可以根据你实际需求来填写[1]。 3.2 将此这个空白映像拷贝到你的 SMB 共享文件夹中： 在 finder 中先推出这个磁盘，然后在保存的位置中，将这个磁盘文件拖入 SMB 共享文件夹的对应位置： 3.3 挂载这个磁盘 双击在 SMB 共享文件夹中的这个映像文件，然后他就会挂在在你的 Mac 上： 最后，通过 terminal 将这个磁盘设置为 TimeMachine 的备份磁盘： $sudo tmutil setdestination /Volumes/TimeMachine 这里的 /Volumes/TimeMachine 就是这个磁盘的挂载点，一般而言就是 /Volumes/ + 磁盘的名称，如果你不是很确定，可以在磁盘工具中，选择这个磁盘，点击右键，选择「显示简介」，看到挂载信息： 输入完命令后，再输入你的Mac密码，即可成功挂载。当你再次打开 TimeMachine 时，已经可以开始备份了。 一个400GB的空白磁盘映像，大概有400MB ↩︎ ","link":"https://hwang.top/post/shu-mei-pai-windows-she-bei-du-ke-yi-zuo-ni-mac-de-shi-jian-ji-qi-li-yong-smb-xie-yi-jin-xing-time-machine-bei-fen/"},{"title":"Docker-compose 的使用（一）","content":"文件目录 在一个 文件夹下，我这里是 Docker ├── docker-compose.yml ├── gitlab └── nginx └── conf.d 其中 gitlab，是直接在shell脚本中运行的，不是使用 docker-compose的方式进行管理的，就以启动一个 nginx 为例： version: '3.4' #版本号 services: web: image: nginx container_name: web_nginx restart: always volumes: - ./nginx/conf.d:/etc/nginx/conf.d ports: - 80:80 一般来说一份标准配置文件应该包含 version、services、networks （可选）、volumes（可选） 首先是 Version Version 3 支持多机和单机，而2仅支持单机。版本1已经废弃了。推荐直接用3及以上版本 其次是 Services 就是服务主体，这里设置了一个 nignx ，名称是 web，然后 是声明 image 是 nginx，这个image 通过 docker pull nginx拉取。接着是 container_name，定义这个容器名称，这样方便通过docker 命令进行直接的管理，然后是 restart:always，表明自动重启。之后是 volumns 相当于docker 命令中的-v参数，用于做容器内的和宿主机的映射。最后是 ports ，端口映射。这样就OK了。 利用 docker-compose 进行管理 通过以下命令运行： $ docker-compose up -d 其中 -d 表示在后台运行。 如果需要重启服务可以通过： $ docker-compose restart web 这里的web 就是 services 的名称。 ","link":"https://hwang.top/post/docker-compose-de-shi-yong-yi/"},{"title":"Hwang Reading List - New 04","content":"这些文章来自 Hwang 的 Instapaper Pocket。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper Pocket，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。 “肉腿”是怎么火起来的？ | 机核 GCORES &gt; 本文系用户投稿，不代表机核网观点 文/沉迷真扎的白 相信这几天不少胖友们的微博首页和我一样，被拥有着一双肉腿的可爱女孩子形象刷屏了。这名女孩子就是9月26日发售的游戏《莱莎的炼金工房》中的女主角莱莎 。作为光 Windows Terminal 食用指南 &gt; 自今年微软开发者大会 Build 2019 中首次亮相以来，经历了近半年的发展，万众瞩目的 Windows Terminal 已经日趋成熟。从十月份开始，我将其作为主力终端使用了一段时间，暂时还没遇到什么严重的问题。 浅谈 Python 中的闭包与中间件封装 &gt; 这两天看了一些中间件框架相关的代码，发现闭包的应用很多，由于之前对闭包这个概念似懂非懂，所以我借此机会学习了一番，然后把成果在此总结记录一下。 Editorial：除了写作，我还兼职 Workflow &gt; 当今 iOS 端 Markdown 写作软件基本由 Ulysses、Bear、Drafts 等明星软件把持，有的功能纯粹，有的界面优雅，但要说到功能强大、扩展强就要数今天的主角 Editorial 了，这是一款被严重低估的软件。当深度使用过后，不禁感叹，这货 DataWorks高级功能场景化案例分享 &gt; 自2009年DataWorks立项，伴随着阿里巴巴集团登月计划、公共云和专有云的发布，直到2018年V2. GQ报道 | 幸存者李佳琦：一个人变成算法，又想回到人 &gt; 功能介绍 记录人物的浮沉和时代价值的变迁。全面、真实、深入、准确的非虚构故事，每周为您送上。 ","link":"https://hwang.top/post/hwang-reading-list-new-04/"},{"title":"划重点 ｜ 经济学，学Python 需要学哪些内容？—— 爬虫相关的必知必会的那些知识","content":"经济学的数据来源，一直都是以调查数据和统计数据为主，Python 这门易学易用的语言的出现拓宽了数据来源的边界。 Python 能够通过几行代码就能获取在网络中存在的各种数据，再利用前文《划重点 ｜ 经济学，学Python 需要学哪些内容？——数据分析处理 化必知必会的知识点》提到的数据处理的相关知识，能够便捷的结构化数据，为实证分析提供强有力的支持。 利用 Python 获取网页中的信息，就是所谓的爬虫。而越来越多经济学专业的学生也被导师“要求”学习 Python 以及爬虫的技巧。那么对于经济学学生来说，学习 Python 来爬虫，到底需要学习哪些知识呢？ 1. HTML ：了解网页的基础，知道爬取的对象是什么 现如今，我们已经习惯了打开浏览器查看各式各样的网络内容，而浏览器中所出现的所有内容，都可以简单概括为 HTML+ CSS+Javascript，其中 HTML 用于储存网页内容，CSS 用于储存网页的样式，Javascript 负责网页的交互。所以，要获取数据，就必须要对 HTML 下手。 学习和了解 HTML 成为了必不可少的知识。当然，你也无需担心，抱怨“又要学一门新的语言”HTML 是一种标记型语言，所谓标记型语言就类似于： Hello HTML 非常容易理解，&lt;h1&gt;&lt;/h1&gt;就是一个标记，标记里面的内容属于h1，也就是一级标题的意思。不同的标记代表不同的功能比如h2 就代表二级标题，p 就代表正文等等，浏览器根据这个标记去显示内容的样式。所以对于爬取数据来说，只要知道哪个是标记，哪个内容，并且能够找到自己需要的标记在哪个层级的标记下就可以了。 2. 浏览器的开发者界面：获取网页背后的代码 学会了HTML，你还需要知道，去哪里看到这些代码。所以，这时候你就需要学习如何使用浏览器的开发者模式了。 Chrome 浏览器是比较常用的一款能够较好显示网页源码的软件，你可以在界面右上角选择更多工具，然后打开开发者工具： 打开以后，你就能够看到网页的源代码了。浏览器就是根据这些代码，显示出网页的。 总的来说，Chrome 提供了这么几个板块的功能[1]： Elements: 允许我们从浏览器的角度看页面，也就是说我们可以看到chrome渲染页面所需要的的HTML、CSS和DOM(Document Object Model)对象。也就是为我们显示源码。 Network: 可以看到页面向服务器请求了哪些资源、资源的大小以及加载资源花费的时间，当然也能看到哪些资源不能成功加载。此外，还可以查看HTTP的请求头，返回内容等； Resources: 对本地缓存（IndexedDB、Web SQL、Cookie、应用程序缓存、Web Storage）中的数据进行确认及编辑；记录了Cookie等信息，可以用于爬取一些需要登录的网址。 以及我们并不常用，但是可以了解一下： Sources: 主要用来调试js；对于我们经济学学生来说，并不那么重要。 Timeline: 提供了加载页面时花费时间的完整分析，所有事件，从下载资源到处理Javascript，计算CSS样式等花费的时间都展示在Timeline中； Profiles: 分析web应用或者页面的执行时间以及内存使用情况； Audits: 分析页面加载的过程，进而提供减少页面加载时间、提升响应速度的方案； Console: 显示各种警告与错误信息，并且提供了shell用来和文档、开发者工具交互。 通过这个界面，你就可以获取诸如 Xpath 、Cookie 这些对于爬虫非常重要的信息，学会使用这个工具，对于爬虫来说必不可少。 3. Python 的爬虫框架 最后，就是使用爬虫框架来进行爬虫，不同框架的上手难度以及自由度个有不同，纵多的爬虫框架，用于处理不同的情况，比较常用的有： Requests 库https://requests.kennethreitz.org/en/master/：适合新手上手的一个爬虫框架，如果你有了一定的 Python 基础，那么先用 request 库上手一般都是没错的。 Beautiful Soup https://beautifulsoup.readthedocs.io/：将网页变为 Soup，然后在Soup中提取HTML内信息的爬虫方案。同样比较容易学习，易于上手。 Scrapyhttps://scrapy.org/ ：他是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 比较适合结构化数据的提取。 Pyspider https://github.com/binux/pyspider：一个带有GUI的爬虫框架，可以在GUI上直接写 爬虫脚本。 除此之外，还有许多不同类型的爬虫框架，大家可以根据自己的需求在网络上简单搜索，就能找到各种不同库的比较，届时选择自己想对能够接受的包即可。 以上三部分就是爬虫中需要知道的三大块的知识了，除此之外，你可能还需要一定的网络知识，用于处理爬虫实践中的不同种类的错误。并且，爬虫是一个可以不断深入的领域，不同类型的网站又会有不同的“反爬虫”策略，为了处理这些策略可能会需要用到更多不同的知识，对于经济学专业的学生来说，继续深入可能会有些“得不偿失”了，选取那些爬虫成本更低的网站才符合效用最大化。 所以简单总结，爬虫需要了解HTML的基础知识，然后要学会使用 浏览器开发者模式，查看源码以及网络信息，最后就是选择一个称手的第三包来进行爬虫操作。 参考：https://segmentfault.com/a/1190000000683599 ↩︎ ","link":"https://hwang.top/post/hua-chong-dian-or-jing-ji-xue-xue-python-xu-yao-xue-na-xie-nei-rong-pa-chong-xiang-guan-de-bi-zhi-bi-hui-de-na-xie-zhi-shi/"},{"title":"PySide2/PyQt 在 Windows 中添加对高分屏的支持","content":"Qt 当中有一个类是 QSize，用于标识组件的尺寸，那么是不是应该能够做到自适应高分屏呢？ 本着大胆猜测小心求证的心态，去网上看来一圈。许多教程都是让你获取当前分辨率，然后再设置界面缩放的。这么做也不是不行，但是总感觉不应该是这样的。 直到在QtCore下面找到了： Qt.AA_UseHighDpiPixmaps Make pixmap() generate high-dpi pixmaps that can be larger than the requested size. Such pixmaps will have devicePixelRatio() set to a value higher than 1. After setting this attribute, application code that uses pixmap sizes in layout geometry calculations should typically divide by devicePixelRatio() to get device-independent layout geometry. Qt.AA_EnableHighDpiScaling Enables high-DPI scaling in Qt on supported platforms (see also High DPI Displays). Supported platforms are X11, Windows and Android. Enabling makes Qt scale the main (device independent) coordinate system according to display scale factors provided by the operating system. This corresponds to setting the QT_AUTO_SCREEN_SCALE_FACTOR environment variable to 1. This attribute must be set before QGuiApplication is constructed. This value was added in Qt 5.6. Qt.AA_DisableHighDpiScaling Disables high-DPI scaling in Qt, exposing window system coordinates. Note that the window system may do its own scaling, so this does not guarantee that devicePixelRatio() will be equal to 1. In addition, scale factors set by QT_SCALE_FACTOR will not be affected. This corresponds to setting the QT_AUTO_SCREEN_SCALE_FACTOR environment variable to 0. This attribute must be set before QGuiApplication is constructed. This value was added in Qt 5.6. AA_ 前缀表示，是ApplicationAttribute。 其中的Qt.AA_EnableHighDpiScaling 里面明确写了： support platforms are x11, Windows , Android 并且说明了这个设置项必须在 QGuiApplication创建前： This attribute must be set before QGuiApplication is constructed. This value was added in Qt 5.6. 所以接下来就好做了，只需要一行代码即可实现对高分屏的适配： QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling) 例如： # -*- coding:utf-8 -*- import sys from UI import styleBook from PySide2 import QtCore from PySide2.QtCore import Qt from PySide2.QtWidgets import QApplication from PySide2.QtGui import QIcon from stqt import mainWindows if __name__ == '__main__': QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling) app = QApplication(sys.argv) mainWindow = mainWindows() mainWindow.setWindowTitle('Single Table Query Tools') mainWindow.setWindowIcon(QIcon('./LOGO.ico')) main_qss = styleBook.get_main_style() mainWindow.setStyleSheet(main_qss) mainWindow.show() sys.exit(app.exec_()) 在 app = QApplication 创建前添加即可。 其他建议： 推荐图标直接使用 SVG 文件，这样在拉伸中不会导致分辨率问题。 样式写在单独的 QSS 文件中，每一个 Widget 组件都用 px 标示尺寸，这样在放大缩小中都能够很好的按倍数支持。同样文字内容也用 font-size 标注，能够很好的支持。 One More Thing 这个设置在应用从高分屏切换到低分辨率的时候也能够自动适应。挺方便的。 ","link":"https://hwang.top/post/pyside2pyqt-zai-windows-zhong-tian-jia-dui-gao-fen-ping-de-zhi-chi/"},{"title":"为公众号撰稿—如何精准检索我们公众号的文章","content":" 2019.11.03 为刘老师准备的一篇小教程 在「刘西川文献阅读与写作」的运营中，我们常常在后台收到这样的留言： 这位读者的意图其实很明显——希望查找我们公众平台关于「实证研究」的文章。但是由于我们精力和技术有限，以及微信公众平台本身的限制，并不能实时返还相关的内容。那么如何正确的检索我们公众号的文章呢？ 其实微信提供了定向搜索特定微信公众号推文的功能，具体操作如下： 打开「刘西川文献阅读与写作」公众号，相信爱学习的你一定已经把我们置顶了（如果没有还不赶快星标我们的公众号） 点击右上方 头像 按钮 ，即可查看详情 点击搜索按钮，即可搜索「刘西川文献阅读与写作」下的所有推文啦。 如下图： 甚至是正文内出现关键字都能找到哦。 ","link":"https://hwang.top/post/wei-gong-zhong-hao-zhuan-gao-ru-he-jing-zhun-jian-suo-wo-men-gong-zhong-hao-de-wen-zhang/"},{"title":"划重点 ｜ 经济学，学Python 需要学哪些内容？——数据分析处理 化必知必会的知识点","content":"也许会有专业软件工程师可以认为 Python 的火热，有些“过誉”了，但是在经济学乃至数据科学领域，Python的火热绝对是能够理解的。任何一个经济学届的「有志青年」，都应该抓住这把火。对于那些还没有上手，有准备上手的「有志青年」们，本文将为大家梳理经济学类学子，学习 Python ，在数据分析处理环节需要用到哪些内容。 注：以下知识点主要以 Python 的第三方包为主。 onePoint Python的第三方包：Python 具有丰富的扩展性，成千上万的第三方扩展包不断为 Python 赋能，使得其能够承载各式各样的不同需求。一般代码前几行，诸如import pandas as pd ，就是在导入第三方包。得益于开源免费，任何人都可以为其贡献第三包，而许多优秀的第三方包又促进更多的人使用Python，进而创造出更多的第三方包，进而形成一种良性的循环。 经济学使用 Stata 也好，Python 也好，根本目的是为了对于数据进行分析，从而了解到隐藏在数据背后的“经济解释”。所以数据分析是学完 Python 基础的第一课，也是最重要的一课。 1. Pandas ：数据操作的基石 毫不过分的说，学好 Pandas 甚至比学好 Python 更重要。可以说，正是因为 Pandas 的好用，奠定了 Python 在数据科学地位。 那么，Pandas 是什么？ Pandas 是 Python 的第三方包，用于数据处理。 Python 默认的数据格式，无论是列表还是字典，都不能很好的用于操作在现实中常见的二维数据。Pandas 为此而生， Pandas 提供了一种名为 DataFrame 的数据格式，将数据储存为一个二维表的形式，再通过各种函数方法，对数据进行横向、纵向、亦或者按条件的切片来对数据进行处理，最终得到需要的数据结果。 Pandas 提供了快速而高效的 DataFrame 对象，用于数据操作与综合索引（索引就是用来快速查找对象的，例如快速找到标示性别的一列）。通过 Pandas 你可以轻松的读取CSV和文本文件、Microsoft Excel、SQL数据库和快速HDF 5格式的数据。并且基于各种索引与标签，你可以轻松的创建数据切片（例如一个数据里标示年纪的切片），通过大数据集筛选特定子集（例如，筛选性别为男性、年龄大于18岁的成人男性样本）。 总结一下，无论是基础的数据操作，还是为日后扩展，Pandas 都是极为基础，极为重要的一款第三方包。 GitHub 项目地址👉：https://github.com/pandas-dev/pandas 官方文档地址👉：https://pandas.pydata.org/pandas-docs/stable/ 2. Numpy：为Python 提供强劲的运算支持 Numpy 是 Pandas 的一个依赖项（安装 Pandas 时会自动安装 Numpy），Pandas 的高效率一部分原因就是归功于 Numpy 的强大。 简单理解就是 Numpy 提供了一个比 Python 自带的数组运算更加快速的 Numpy数据的数据格式。当你的分析涉及到数组运算，尤其是多维的数组运算时，那你应当考虑学习使用 Numpy。同时，Numpy也提供了强大的线性代数、傅立叶变换和随机数的功能。 Numpy 是Python 数据处理的又一块基石，在机器学习和深度学习领域，Numpy 具有广泛的应用。所以学习 Numpy 到如何的深度，需要看你所研究的领域，是否需要用到较为高级的数学运算。 官方地址👉：https://numpy.org/ 官方文档👉：https://numpy.org/doc/ 如果你熟悉 Matalab，可以查看：《与matlab比较》，也可以对照中文翻译版 3. Statsmodels： 将计量搬到python上来 通过 Pandas 进行数据处理，我筛选到了需要的数据，接下来我们经济学的学生需要做什么呢？当然是开始计量之旅喽！ 那么我们还需要将数据从 Pandas 的 DataFrame 导出成 CSV，再导入到 Stata 中，进行计量运算嘛？ 大可不必，在 Python 你可以自己手写一个 OLS 函数，然后反复调用即可。(此时可能有读者冒出了大量的 「黑人问号.jpg」) 其实关注本公众号的读者应该已经阅读过：工具&amp;方法 | 6行代码教你用python做OLS回归 是的 Python 当中也有计量库了：Statsmodels 。Statsmodels 是一个Python的第三方模块，他封装了许多计量模型，方便学者直接调用。所谓封装，就相当于 Stata 中一个 reg 命令，代表了最基础的 OLS 回归命令，在Statsmodels 中也有类似 reg 的语句，提供给 OLS 估计。详细的内容可以参考工具&amp;方法 | 6行代码教你用python做OLS回归 ，以及下面的官方链接。 不得不说，通过 Statsmodels，Python 中做计量的成本大大降低，学习 Python 对于经济学学生来说，也能做到「全栈」式的使用体验。 官方地址👉： https://www.statsmodels.org/stable/index.html 官方示例👉：https://www.statsmodels.org/stable/examples/index.html 4 . sqlachemy ( or pymysql、cx_oracle) ：进阶操作，处理 SQL 数据库 相比于 Stata ，Python 还可以通过很容易的方式，链接到数据库中，对数据库内的数据进行操作。与经济学关系更为密切的一般是 关系型数据库，即 MySQL、Oracle 为代表的数据库类型。 Python 当中提供了极其便利的方式链接到 以上类型的数据库。通过 pymysql 能够链接到 mysql 数据库，通过 cx_oracle 能够链接到 Oracle 数据库，并且，如果你对 SQL 语句不熟悉，你可以使用 sqlachemy 一类的ORM框架的方式，跳过原生 SQL 语句，通过类似 Pandas 的筛选语句的方式来操作数据库查询，获取需要的数据子集。 经济学对于SQL 数据库的处理，更多时候是在总的大数据集中，筛选出自己需要子集，再进行操作。这个过程，你可以通过 sqlachemy 的方式筛选数据，也可以通过原生sql查询的方式获取数据，再将数据储存为 DataFrame 格式，利用 Pandas 进行精细化的二次处理，再通过上面提到的 Statsmodels 等第三方包进行计量处理。 官方地址👉：https://www.sqlalchemy.org/ 至此，小编整理的，经济学学生需要用的数据处理相关的包已经介绍完毕了。简单总结一下，当你拿到数据是 CSV 一类格式的数据时，通过 Pandas 将文件读取为一个 DataFrame，然后对其按需求进行筛选和运算，得到自己需要的数据集。如果数据储存在 SQL 数据库中，通过Python 连接数据库，运用 ORM 框架或者 原生 SQL 语句对数据进行筛选，拿到自己需要子集后，读取到 DataFrame 中，在Pandas中再进行更加精细化的处理，得到真正需要的数据集。这些数据集，依然可以通过 Python 的Statsmodels进行计量，得到计量的结果。至此一个数据处理 Workflow 在 Python 得到完整的体现。 根据本文的阅读的阅读数量和点赞情况，我们会考虑基础推出数据获取（爬虫）、数据可视化的相关内容哦。 做一个投票，投一下希望先做数据获取（爬虫）还是先做数据可视化 ","link":"https://hwang.top/post/hua-chong-dian-or-jing-ji-xue-xue-python-xu-yao-xue-na-xie-nei-rong-shu-ju-fen-xi-chu-li-hua-bi-zhi-bi-hui-de-zhi-shi-dian/"},{"title":"Hwang Reading List - New 03","content":"这些文章来自 Hwang 的 Instapaper Pocket。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper Pocket，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。 High Schools to TikTok: We’re Catching Feelings Teens love the app, and now it’s getting the stamp of approval with teacher-approved clubs. Did school just get ... fun? WINTER GARDEN, Fla. 如何在印象笔记中巧用搜索？ 从我用手机开始就一直在用手机记录东西，大都是标签、随记之类的，在 2012 年时候我就开始寻找能在电脑和手机上同步的软件，然后发现了 Evernote，它强大的多台设备之间完整同步功能让我非常惊喜，由此我开始关注大象。 使用 Dropbox 同步 Klib 数据库 在 Klib 实现通过 iCloud 在不同 Mac 电脑同步前，可以借助 Dropbox 等第三方工具来同步。这里以 Dropbox 为例进行介绍，假定 Dropbox 本地同步目录位于：~/Sync/Dropbox/ 狄德罗效应下，小程序被“逼”向中心化 文 | 陈小江 来源 | 螳螂财经（ID:TanglangFin） 话说，一直以“去中心化”自居的微信小程序正向“中心化”靠拢。 按照张小龙在2017微信公开课Pro上的最初设想，去中心化的微信小程序是这样的：小程序在微信没有入口，没有订阅 从这 10 个应用实例开始，打造一套 Things 自动化流程 最近任务管理应用 Things 为我们带来了一次重磅更新：全面支持 URL Scheme，让用户能够通过 URL Scheme 完成链接到 Things、支持强大的快捷方式以及从其他应用程序切换，也正式宣告了其在自动化领域对于 Todoist 和 OmniFocus 等 创业的这三年 我是 16 年来北京之后开始创业的，到现在已经满满三年了，但是我与创业这件事的渊源，在更早之前就已经开始了，我记得那是 15 年初的冬天，我在大学寝室吃完一顿火锅，纵横捭阖，向室友们大骂了一通当时的许多创业者， 最前线 | 苹果最贵原创剧诞生，想要复制Netflix的成功 当视力被剥夺，人类凭借其他感官生存，世界会变成怎样？ 这一幕即将在Apple TV+的原创剧集《看见》中上演。在这部长达10集的科幻剧集中，故事设定在600年后的未来，一种致命的病毒使地球人口减少到只有200万，同时夺走了所 第四消费时代离你有多远？ 新消费时代，许多行业都被颠覆，并且变革的速度只会越来越快，打败企业的不是别人，而是自己陈旧的思维。企业只有不断进化，才能继续生存。 关于音乐早教 一、常见的音乐早教是一个规训的过程，我们应该对此做出反抗。胎儿在子宫内可以听到母亲血液流动的声音，出生后听到的是人类的说话声、其它婴儿的哭声、以及医院环境内的各种人工音声。这三者都属于被称作「实验音乐 实行威权式法治的新加坡，如何建构自身的正当性？_文化_好奇心日报 《威权式法治》 内容简介 本书指出，新加坡缔造了一种匪夷所思的威权式法治。作者展示了作为法治以及自由民主之基石的制度和程序，是通过何种方式成为了制约异己、保护当政者的工具，但同时又无损于政府在国内和国际 ","link":"https://hwang.top/post/hwang-reading-list-new-03/"},{"title":"STQT 查询工具 Oracle 相关记录 （2）sqlalchemy 连接 oracle 中的一些注意事项","content":"1. sqlalchemy 需要通过 cx_Oracle 连接数据库 pip install cx_Oracle 即可安装。 2. cx_Oracle 并不能直接连接 Oracle ，还需要驱动 下载驱动，注意版本号： 下载地址：https://www.oracle.com/database/technologies/instant-client/downloads.html 需要下载与服务器端对应的 版本。 我这里下载的文件是：instantclient-basic-windows.x64-11.2.0.4.0.zip 解压，里面是一个 instantclient_11_2 文件夹。比如直接放在 C 盘下。 添加这个文件到环境路径中 C:\\instantclient_11_2 重启 Python 运行一遍。 3. 连接如果环境变量并没有解决问题： 尝试将 .dll 文件存放到 python 的 Lib\\site-packages 路径中。 一般来说这样就可以了。 4. 一些错误记录 错误代码 ORA-28547，应该是 oci.dll 文件版本错误。 错误代码 ORA-03135，也可能是上面这个问题。 出现以上错误，优先检查数据库版本号是不是正确的，或者是不是下来 basiclite之类的文件。 ","link":"https://hwang.top/post/stqt-cha-xun-gong-ju-oracle-xiang-guan-ji-lu-2sqlalchemy-lian-jie-oracle-zhong-de-yi-xie-zhu-yi-shi-xiang/"},{"title":"所学皆会有所用，一个后台运营小编辑的贺词———祝贺「刘西川阅读写作课」公众号关注人数突破 10000 人","content":" 本文是应刘老师邀请写的。 属实是太久没写了，生疏了。 还好有刘老师修改，不然真是惨不忍睹了。 刚写完，给女朋友改，她都破口大骂 “写的什么垃圾”。 🌚 从零到一（万）经历了不平凡的过程，零是开始，10000是被初步的认可。祝贺“刘西川阅读写作课”微信公众号关注人数，突破10000人，完成了从零到一（万）的重要一步。二零一八年 四月，该号正式上线，开启了它的不易之旅。我也有幸参与到这个“旅程”之中，作为一名后台人员，我负责将刘西川老师的文章排布到公众号上，并制作推送给大家。各位阅读的早期文章，都是由我这个小编排版的。 我至今仍然非常喜欢张五常曾经举过的一个例子，他说： 他拿100元钱，掉在地上，为什么这个钱会掉在地上，这个问题物理学能够解释，而这100块钱，为什么不见了呢？这个问题，经济学能够解释。 这个例子非常好的诠释了经济学的价值。我很喜欢这个“讨巧”的例子，它让我这位刚踏入大学就选择经济学专业的大学生豁然开朗：经济学居然如此有用，在自然学科群中，物理学是基础，而经济学（经济学的解释）则是社会科学中的“物理学”。我为自己能在经济学专业学习而感到高兴。在我看来，这是一种所学有用的观念，这种观念让我更加自信，也更加坚定的去汲取更多的知识。 我们公众号中上就曾经推送过类比物理学的经济学文章《张五常 | 演化、逻辑与公理：经济学是社会科学中的皇后？》。每次为文章排版时，我都会提前仔细阅读这些文章，这一过程也让我积累了许多写作、阅读以及社科研究相关的知识。古语曰“家中有粮，心里不慌”，积累的这些知识给我最大的底气是，当我写本科毕业论文的时候，能够有条不紊，相对比较自如，有一种拿着“答案”写“答案”的感觉。也许会有人质疑我，认为这有点夸张。但我可以肯定的告诉大家，如果不信，可以翻阅刘老师的写作课系列推文，学习论文写作每个部分的要点，必然能找到“手握答案”的感觉。除了有关社会科学范式的文章，我们还推送了一些有关引言、摘要等方面的文章。如果你还为写本科毕业论文而苦恼，那么我推荐你拜读一下这篇：《彭玉生： “洋八股”与社会科学规范 》，相信你读完定会恍然大悟——天呐！社科写作原来也是有套路可寻的。 因为大部分推文的内容都专注于阅读与写作，这里的学与用是能够相匹配的，对论文写作的帮助也是有口皆碑。若各位老师与同学以此为目的来关注本号，必会有意想不到的收获。细心的关注者也许会发现，这个公众号以“文心雕龙”为 logo ，《文心雕龙》是一本文艺理论方面的书籍，该书作者一是反对不切实际的浮靡文风，二是主张实用的“攡文必在纬军国”之落实文风。我想，尽显真诚，力推干活，也许正是刘老师选择文新雕龙的初心吧。实用的文风其实也隐含着实用主义的价值主张。信息网络的发达亦让人们更加容易的输出内容，海量信息使得人们更加注重甄别信息，同时也更加“爱惜”自己的时间。人们总会扪心自问：看这个有用吗？或许基于实用主义追求所谓的干货，并没有什么错！我只想借助自己的例子，谈谈自己的一些认识。 在为刘老师运营这个公众号的过程中，为了提高自己的编辑效率，我专门学习了 CSS 的写法。很多人可能不大了解 CSS，其实它像是推文的&quot;衣服&quot;，通过学习和编辑一个文件，可以为刘老师的文章快速地套上“衣服”，排出一篇精美版式的文章。在一般人看来，作为一名经济学专业的大学生，学习这些，并没有太多益处，反而有点浪费时间。但是，谁又能想到，毕业后的我竟然真的写起了代码。我学 CSS 的经验其实也是来自于学习 stata 、撰写 do 文件。do 文件几乎是经济学学生对于 “编程”的初步认识。而往后，我以 CSS 为基础，掌握了 HTML，又学会 了Python，但如今，竟成了半个&quot;码农&quot;。这一切，谁又能想到呢 ？ 大学，是学习效率最高，也最能够集中精力学习的时期，于我而言，多学习一些自己喜欢的知识总是没有坏处的。我相信所学皆会有所用。有时候，在很多人看来，这样的观点显得有些 阿 Q 精神。我也很难去反驳那些有用才学的“精英”的观点，而我所做的，只是真诚地分享一些自己的体会。 说了这么多，“腹有诗书气自华”，多多阅读好的内容，总是能够让人在任何时候提笔撰文都更加有状态。无论是社科写作，还是程序员要写的各类技术文档，“多阅读”总是“写得好”的前提。刘老师常说，“己所不欲，勿施于人”，自己都不愿意看的东西，就不要放在公众号上。我的经历与体会分享给大家，只是想说，刘老师所选所作之内容，都有其价值所在，值得我们阅读和学习。 最后，再次祝贺刘西川阅读写作课微信公众号，终于迈出了更坚实的一步，取得了关注者突破10000 名的可喜成绩，希望该号能够在社科领域继续发光发热，指引更多在社科领域努力的学子们前行，帮助更多对社科写作感到困惑的初学者和年轻朋友。同时，也希望“阅读写作课”能够在更广泛的领域产生更积极的影响，近期的 推文《会议纪要这样写，才专业！》(#)推文就是一次积极的尝试。 😹 结尾彩蛋： ","link":"https://hwang.top/post/suo-xue-jie-hui-you-suo-yong-yi-ge-hou-tai-yun-ying-xiao-bian-ji-de-he-ci-zhu-he-liu-xi-chuan-yue-du-xie-zuo-ke-gong-zhong-hao-guan-zhu-ren-shu-tu-po-10000-ren/"},{"title":" STQT 查询工具 Oracle 相关记录","content":" 一、SQL - Oracle 中的表名、字段名、字段类型等信息 表 ALL_TAB_COLUMNS 表 all_tab_columns 的内容包含了所有表的字段信息，可以通过查询语句获取需要的内容。 SELECT * FROM ALL_TAB_COLUMNS 示例： --查询某张表中的字段名，字段类型，是否为空，字段长度等信息 SELECT COLUMN_ID, TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, NULLABLE FROM ALL_TAB_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES' ORDER BY COLUMN_ID; --查询某张表中的字段名，字段类型，是否为空，字段长度等信息 SELECT * FROM ALL_TAB_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES' 表 USER_TABLE 用户表 去除系统内的表格 SELECT * FROM USER_TABLES WHERE TABLESPACE_NAME&lt;&gt;'SYSTEM' AND TABLESPACE_NAME&lt;&gt;'SYSAUX' 二、权限管理记录 自己本地使用 Docker 搭了一个 Oracle 数据库 授权表空间 alter user 用户名 quota unlimited on 表空间; eg: ALTER USER test01 QUOTA UNLIMITED ON QY_TEST; ","link":"https://hwang.top/post/stqt-cha-xun-gong-ju-oracle-xiang-guan-ji-lu/"},{"title":"在 mac OS 的 VS code 中配置  PySide2 的环境的注意事项","content":"基本信息可以参考：https://blog.csdn.net/gongjianbo1992/article/details/100654638 pyside2-rcc : 将 资源文件专为 Python 可以用的文件 pyside2-uic : 将 Ui 文件 专为 Python 文件 记录一下几个注意事项： 1. 环境变量的一些问题： 一般来说 pyside2-rcc 这类命令不一定会自动添加到环境变量中，所以需要添加到环境变量或者直接在设置项中选择完整的文件路径，例如我的： /Library/Frameworks/Python.framework/Versions/3.7/bin/pyside2-rcc 在 Vs code 中填入即可。 类似的 pyside2-uic 也是一样的。 现在 为使用的 是 zsh， 所以配置文件也是在 .zshrc 中，配置文件中一般都会有标示环境变量的。可以直接在里面添加。 如果添加成功那么 直接在终端中输入 pyside2-rcc 是不会报错的。 当然，默认直接在 /usr/bin 目录里面添加添加替身也是可以的。 2. 绑定 Designer 软件的注意事项 如果使用 Ui 文件来创建用户界面，那么可能需要通过 Qt Designer 来修改文件。 一个 mac OS 的常识，应用程序都是以 .app 结尾的 「文件夹」 所以在 VScode 中添加的路径不能是一个文件夹，需要是一个可执行文件。 右键显示包内容，然后在 /Contents/MacOS 里面就能看到可执行文件了。需要添加的是这个可执行文件的路径。 ","link":"https://hwang.top/post/zai-mac-os-de-vs-code-zhong-pei-zhi-pyside2-de-huan-jing-de-zhu-yi-shi-xiang/"},{"title":"Docker 的入门「指北」","content":" 本文以发布于少数派：https://beta.sspai.com/post/56893 推荐在少数派阅读 如果你购买过 VPS 云主机，那么或多或少，你都可能听说过 Docker。如果你从未听说过Docker，那么本文可能能够为你开启新世界。 利用Docker，你能够哦非常轻松的部署各类服务，无论是个人云盘（Nextcloud：打造属于自己的网盘服务 Docker 版(附带视频）、个人的RSS服务（利用 Docker 搭建 Tiny Tiny RSS 服务）、HomeKit 桥接（利用 Docker 搭建 HomeKit 智能家居），亦或者搭建一个个人博客（使用 Docker 部署 Ghost 教程），甚至是做一个自己的维基百科、自己的社交软件，都能够轻松的实现。 是的，Docker 就好像是 服务器端的「应用商店」，你能够通过Docker，轻松的部署各种属于个人、团队的服务。而现如今，无论是利用各个平台的云主机，还是 树莓派、群晖、威联通等这些物理的服务器主机，甚至是自己废旧的老电脑，都能够很容易的使用上 Docker。 在正式开启前，本文默认读者了解基本的命令行操作，以及了解基本的Linux相关知识，如果您还不了解这些，可以通过 B站 这个 UP 主的视频有所了解：https://www.bilibili.com/video/av56233347 那么开启 Docker 之旅吧！ Docker 可以理解为寄存在主机上的特殊的虚拟机。它利用特殊的虚拟化技术，比一般的虚拟化技术能够更加高效合理的利用资源。一台主机上可以创建众多的容器，这些容器通过特定的方式与主机共享硬件资源，并且访问特定的文件，使用特定的端口。通过 Docker ，一台主机能够运行多种不同的服务。 第一步，安装或者启用 Docker 一般来说，Docker 会运行在 Linux 服务器上，无论是哪种发行版本，你都可以非常容易的在搜索引擎中找到其他平台的安装方法。这里我以 Ubuntu 为例： $ sudo apt update # 先更行一下软件包缓存 $ sudo apt install docker-ce # ce 代表社区版 接着启动 Docker 服务 $ sudo systemctl enable docker $ sudo systemctl start docker 这样，你就可以尝试一下运行 docker 命令了 $ sudo docker run hello-world 默认情况下，docker 命令需要使用 root 用户或者在docker组下的用户才能使用（docker 命令会使用 Unix socket 与 Docker 引擎通讯）。也就是说，如果不设置，默认情况下，所有的 docker 命令都需要加 sudo。 一般情况下，你可以创建一个名为 docker 的用户组，再将当前用户加入到 docker 组中，使得操作更为安全。 $ sudo groupadd docker #创建 Docker 组。 $ sudo usermod -aG docker $USER #添加当前用户到 docker 用户组中，也可将 $USER 替换为你想加入到 docker 组中的用户。 第二步，拉取你的第一个 Image 其实你可以这么理解 Docker，你可以在一个名为 Docker Hub 的网站中，查找Docker 镜像（image），这个过程就好像是在 App Store 中搜索自己需要下载的应用一样。查找完想要下载的镜像后，在终端中输入： $ docker pull [镜像名称] 可以拉取镜像的到本地。是的，你就下载了这个应用，只不过是在服务端。当然，一般来说这个过程会比较缓慢，你可以替换国内源加速这一过程。 第三步，启动你的服务 与一般应用下载打开不同，Docker 的镜像可以重复的被打开成不同的容器。你可以简单的理解为这是「应用双开」，或者说是「应用多开」。我们使用 docker run 命令来启动容器。 这个启动的过程可以是一次性的启动，即直接使用 docker run + 一些列参数的方式启动服务，也可以通过 docker compose 来编排你的项目。由于 compose 会相对专业，本文就不做过多的介绍了，这里只以 docker run 为例作为讲解，以下是常见的参数： -d ：正常情况下，启动一个服务区，我们都会让其在后台运行，所以使用参数 -d 来告诉 Docker，在后台默默奉献即可。 --name= ：前面已经提到了，你可以对一个 Docker 镜像进行多开操作，所以通过 dockr run -d --name=[你的名字] 的方式，可以指定开启的这个容器的名称，这样在多开的情况下，能够更为方便的进行管理。 -p : 指定端口的映射。 这里简单讲解一下端口的含义：以用户输入在浏览器中输入www.sspai.com 为例，首先浏览器会通过 DNS 服务器把这个 Url 翻译为 IP 地址，再通过 IP 地址，找到少数派的服务器，再通过端口号确定开启的服务，例如如果你输入的是：https:\\\\www.sspai.com，那么对应的端口就是 443。端口号就相当于服务器的柜台，同个服务区会有多个柜台提供服务。诸如 http 服务，默认是 80 端口， https 默认是 443 端口，类似的 FTP 服务是 21 等等。 并且一个端口只能支持一个服务，就是说一个柜台只支持办理一项服务。 回到 -p 这个参数，-p 8080:80 就是指将 docker 中开启的端口，映射到主机的 8080 端口中。也就是说通过主机的IP地址的8080 端口，可以访问到 docker 容器的80 端口服务。 服务器的 8080 柜台接收到的服务，会发送到容器的80柜台中。是的，容器也相当于是一个服务器，在 Docker 内部，他们之间也是有 IP 地址的说法的，所以容器也是需要开「柜台」来管理服务的。 理解这一步非常重要，和一般的使用应用不同，服务器上的应用就是一直在运行，然后让你去访问的，所以 -p 参数设置不对，可就找不到柜台办理正确的服务器了。例如运行： $ docker run -d --name=nextcloud_demo -p 8080:80 nextcloud 那么你可以通过 http://localhost:8080 访问到你的 nextcloud 服务。这里的 loaclhost 指的是在 Docker 服务器上访问。如果你想通过自己的电脑，访问 Docker 服务器上的服务，把 loaclhost 替换为服务器的 IP 地址即可。 -v ：建立主机于docker容器内的文件关联。通过-v 能够 主机的文件映射到 docker 容器中，例如： $ docker run -d \\ -v nextcloud:/var/www/html \\ nextcloud 就是将本地本地文件夹 nextcloud 映射到容器中的 /var/www/html 目录。 这 4 个参数就是docker 最基础也是最常用的参数了。了解了这四个参数，再参照 Docker Hub 下每一个镜像的使用说明，你就可以尽情的拥抱和享受开源社区的各种服务了。 推荐一些好用的 Docker 镜像 除了开篇提到的 NextCloud、Tiny Tiny RSS、Ghost 等服务外，还有一些镜像值得尝试： MediaWiki： 和维基百科一样的属于个人或者团队的维基服务。 Wekan：属于个人或者团队的开源看板应用。参考Trello等服务。 WordPress：为人所知的、被广泛使用的、收购了tumblr的博客服务，可以用来搭建个人博客，甚至商用网站。 gitlab、gitea 等 Git 服务：如果有团队代码管理需求，可以使用 Docker 快速部署一个私用的 Git 服务。 部署一时爽，运维「火葬厂」 Docker 让服务的安装变得异常容易，但是选择一项服务后，后面的运维才是真正折腾人的地方。 首先是管理容器中，最常使用到： $ docker ps #查看运行中的容器。 $ docker ps -a #查看所有容器，包括停止的。 $ docker images #查看安裝的镜像 然后是停止、启动已有的容器： $ docker stop &lt;容器名称/ID&gt; # 正常停止容器 $ docker start &lt;容器名称/ID&gt; # 启动已有容器 $ docker kill &lt;容器名称/ID&gt; # 强制停止容器 一般容器运行后，会有一个 ID，用以区分容器，这个ID 一般都是乱序的，所以之前的 --name 参数，能够使你更加方便对容器进行管理。 除此之外，还有就是进入 Docker 容器中，修改一些配置文件： $ sudo docker exec -it &lt;容器名称/ID&gt; /bin/bash 就是说你可以通过这个命令，进入到 容器的 bash 中，对容器内进行一些修改。 最后 docker 还有许多其他的命令和方法可供学习。作为当今最受欢迎的容器化解决方案，docker 在业界发光发亮的同时，也为一般用户，「一键」启用某些服务提供了契机。利用开源社区，你可以比以往任何时候都更为容易的实现许多互联网服务的「自给自足」。 ","link":"https://hwang.top/post/docker-de-ru-men-zhi-bei/"},{"title":"Hwang 的低质阅读单 New 2","content":"这些文章来自 Hwang 的 Instapaper 。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper ，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。 谐门武学：使用JupyterHub搭建多用户数据控制台 使用 Python 函数进行模块化 约定式提交 PyQt5 tutorial - Python GUI programming examples - Like Geeks 为什么你的SaaS会“失败”？_36氪 香港：（曾经的）实践中有限政府的最好例子 12条经验，让你在机器学习的路上避免很多坑 苹果不再需要 Jony Ive Qt for Python &amp; PyInstaller — Qt for Python 整容的人越来越年轻了，自拍是罪魁祸首 刘林平 | 规律与因果：大数据对社会科学研究冲击之反思 组策略应用——安装软件-Rainy`s IT Tech Blog-51CTO博客 PyQt 5信号与槽的几种高级玩法 - 博文视点 Python 工匠：使用数字与字符串的技巧 5代防火墙 -- 网络系统 -- IT技术博客大学习 -- 共学习 共进步！ 我的书桌——先砸一块砖 漫话中文自动分词和语义识别（下）：句法结构和语义结构 -- 算法 -- IT技术博客大学习 -- 共学习 共进步！ Type is Beautiful » 孔雀计划：中文字体排印的思路 简明Vim练级攻略 -- Linux -- IT技术博客大学习 -- 共学习 共进步！ 数据科学入门后，该做什么？ ","link":"https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-2/"},{"title":"Qt for Python 的小Tips —— 外部加载 QSS","content":"PyQt5/PySide2 —— 加载 QSS 文件 class beautifyUI(object): def __init__(self): pass def readQss(self, qssfile): &quot;&quot;&quot; 加载 QSS 文件； qssfile：qss文件路径； &quot;&quot;&quot; with open(qssfile, &quot;r&quot;) as f: return f.read() 定义一个函数，基本上就可以通过这个 读取 QSS 作为字符串，然后存为变量，读取进去就OK了。 当然这个文件在打包时也要特殊处理：要么作为字符串储存于某个变量中，要么直接在特定目录下去读取这个文件。在mac的应用打包中，格外需要注意这点。请尽量使用绝对路径记录信息。 ","link":"https://hwang.top/post/qt-for-python-de-xiao-tips-wai-bu-jia-zai-qss/"},{"title":"Qt for Python 的小 Tips - 不显示软件的「大下巴」— QStatus","content":"这里设置 软件的底部信息栏，PySide 中称为 QStatusbar。 利用 QT Creator 生成的 mainWindows 软件会自动添加该部件。如果不需要底部状态栏，注释掉就可以了。 ","link":"https://hwang.top/post/qt-for-python-bu-xian-shi-ruan-jian-de-da-xia-ba-qstatus/"},{"title":"Procreate 练习","content":"画图，画图。 好久没有动笔了。线条画的一点都不流畅了。 ","link":"https://hwang.top/post/procreate-lian-xi/"},{"title":"Update 了一下 figma 的封面","content":"更新了一下figma的封面： ","link":"https://hwang.top/post/update-liao-yi-xia-figma-de-feng-mian/"},{"title":"一个用了 3 个月 PyQt 的人，在学 Vue.js 基础","content":" el: data: methods: 用于存放 事件内的方法。 可以理解为 PyQt 中 存放 槽函数 的一个字典。 v-cloak 能够解决插值表达式（{{}}） 闪烁 的问题 &lt;v-test='msg'&gt; v-test 没有闪烁问题，会覆盖元素中原本的内容，但是，插值表达式只会替换自己的占位符。 v-html : 输出闪烁问题 v-blind : 绑定 属性 的指令，简写为 : ; v-blind 可以写合法的 js 表达式 v-on : 绑定 事件的 （类似 qt 中的 信号与槽的绑定），简写为 @ v-model: 双向数据绑定，只能用在表单元素（input（radio、text、address、email...） select checkbox textarea）中。 v-for: 循环操作 &lt;p v-for =&quot;item in list&quot;&gt;{{item}}&lt;/p&gt; &lt;p v-for =&quot;(item, i) in list&quot;&gt;索引值:{{i}} --- 项目：{{item}}&lt;/p&gt; 可以迭代 1.普通数组；2.对象数组；3.对象；4. 数字（起始是1） 在组件中使用 V-for 循环的时候，必须使用 v-for 的同时，制定唯一的字符串/数字类型的 key 值 v-if 每次都会重新删除或者创建元素 有较高的切换性能消耗 v-show 切换元素的 display:none 样式 有较高的初始渲染消耗 事件修饰符 @click.stop 阻止事件的冒泡（从内到外，触发事件） @click.prevent 阻止默认行为的使用 .capture 以捕获机制触发行为（从外到里，触发事件） .self 只有自身的时候执行 .once 只触发一次 vue 中使用样式 使用数组 :class = ['style1','style2'] 会给出style1和style2的合并样式效果 :class = ['style1','style2',{'style3':flag}]使用 v-blind ，伪 Class 表达可以使用对象的方式赋值，能够更好的实现样式变化的情况,在data中： data flag: true } 此时能够通过js来控制这个样式的实现与否。 在数组中可以使用 三元表达式(https://baike.baidu.com/item/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/1394210)，python 中 类是 if 的判断语句 可以直接使用对象的方式调用样式。 ","link":"https://hwang.top/post/yi-ge-yong-liao-3-ge-yue-pyqt-de-ren-zai-xue-vuejs-ji-chu/"},{"title":"Python 的虚拟环境管理  virtualenv & pyenv","content":" pyenv : 用于Python版本管理。 virtualenv ：用于构建按项目的虚拟环境。 pyenv-virtualenv ： pyenv 的插件，用于构建项目的虚拟环境。 由于生产需要，用 PyQt5 写了小程序，打包成 .app 过程中发现，打包后竟然有200多M，应该是因为之前使用的python环境中其他包比较多的关系。所以就想到建虚拟环境，来打包。 首先想到的是按项目建虚拟环境，那就用virtualenv 。简单看了一下，实践如下： virtualenv 1. 安装virtualenv 用pip进行安装。 $ pip install virtualenv 先建文件夹，再cd到需要的文件夹中，运行下面的命令： $ virtualenv --python=&quot;/usr/local/bin/python3.7&quot; --no-site-packages venv 其中： --python （-p） # 用于指定版本 --no-site-packges # 表示不需要包 venv # 虚拟环境的名称 其它选项： --version #显示当前版本号。 -h, --help #显示帮助信息。 -v, --verbose #显示详细信息。 -q, --quiet #不显示详细信息。 -p PYTHON_EXE, --python=PYTHON_EXE #指定所用的python解析器的版本，比如 --python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前系统安装(/usr/bin/python)的python解析器 --clear #清空非root用户的安装，并重头开始创建隔离环境。 --no-site-packages #令隔离环境不能访问系统全局的site-packages目录。 --system-site-packages #令隔离环境可以访问系统全局的site-packages目录。 --unzip-setuptools #安装时解压Setuptools或Distribute --relocatable #重定位某个已存在的隔离环境。使用该选项将修正脚本并令所有.pth文件使用相当路径。 --distribute #使用Distribute代替Setuptools，也可设置环境变量VIRTUALENV_DISTRIBUTE达到同样效要。 --extra-search-dir=SEARCH_DIRS #用于查找setuptools/distribute/pip发布包的目录。可以添加任意数量的–extra-search-dir路径。 --never-download #禁止从网上下载任何数据。此时，如果在本地搜索发布包失败，virtualenv就会报错。 --prompt==PROMPT #定义隔离环境的命令行前缀。 #环境变量和配置文件 2. 激活虚拟环境 $ . venv/bin/activate 前面出现(venv) 即可。 一些发现 virtualenv 默认似乎是从原环境中下载包的。就是优先直接从原有库中拷贝，不通过下载。这样速度会比较快。 由于本地环境除了 anaconda 的以为， Python 3.7。在打包中出现了一些兼容性问题，具体可见： https://github.com/pyinstaller/pyinstaller/issues/1957 https://github.com/pyinstaller/pyinstaller/issues/3753 即便按照issues里说的做了，我也没能解决问题。所以想到下载 3.6版本的 Python 来使用。所以就想到了用 pyenv pyenv 基本过程可参考：https://www.jianshu.com/p/4646dedaaff5 1. 安装 我是通过 Homebrew 下载的（可参考：https://zhuanlan.zhihu.com/p/27294128）。 备份一下 .bash_profile # Setting PATH for Python 3.7 # The original version is saved in .bash_profile.pysave PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}&quot; export PATH # added by Anaconda3 5.2.0 installer export PATH=&quot;/Users/wangxuexi/anaconda3/bin:$PATH&quot; eval &quot;$(pyenv virtualenv-init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; eval &quot;$(pyenv init -)&quot; export PYENV_ROOT=&quot;$HOME/.pyenv&quot; export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; eval &quot;$(pyenv init -)&quot; eval &quot;$(pyenv virtualenv-init -)&quot; $ brew install pyenv 有可能需要： $ echo 'export PYENV_ROOT=&quot;$HOME/.pyenv&quot;' &gt;&gt; ~/.bash_profile $ echo 'export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile $ echo 'eval &quot;$(pyenv init -)&quot;' &gt;&gt; ~/.bash_profile 写完后，用以下命令重新登录一下： $ source ~/.bash_profile 如果有需要可以安装 pyenv-virtualenv: $ brew install pyenv-virtualenv 同样的： $ echo 'eval &quot;$(pyenv virtualenv-init -)&quot;' &gt;&gt; ~/.bash_profile # 写入 profile $ source ~/.bash_profile # 重新进登录一遍 命令参数如下 pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt; # 建虚拟环境 pyenv virtualenv activate &lt;virtualenv-name&gt; # 激活虚拟环境 pyenv virtualenv-delete &lt;virtualenv-name&gt; # 删除虚拟环境 2. pyenv 的使用 基本的下载、删除 命令： v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v # 用国内源安装很快 v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install $ pyenv install -v 3.6.0 # 安装 $ pyenv uninstall 2.7.10 # 删除 激活，pyenv 有几种激活方式： local Set or show the local application-specific Python version global Set or show the global Python version shell Set or show the shell-specific Python version 通过version 、 versions 查看版本。 其他： Usage: pyenv &lt;command&gt; [&lt;args&gt;] Some useful pyenv commands are: commands List all available pyenv commands local Set or show the local application-specific Python version global Set or show the global Python version shell Set or show the shell-specific Python version install Install a Python version using python-build uninstall Uninstall a specific Python version rehash Rehash pyenv shims (run this after installing executables) version Show the current Python version and its origin versions List all Python versions available to pyenv which Display the full path to an executable whence List all Python versions that contain the given executable See `pyenv help &lt;command&gt;' for information on a specific command. For full documentation, see: https://github.com/yyuu/pyenv#readme 3. Pyenv virtualenv 的使用 3.1 创建： pyenv virtualenv [-f|--force] [-u|--upgrade] [VIRTUALENV_OPTIONS] &lt;version&gt; &lt;virtualenv-name&gt; -f 表示强制的（假如虚拟环境已存在，将会覆盖这个虚拟环境） -u 表示upgrade，用于修改已经存在的虚拟环境的Python版本 VIRTUALENV_OPTIONS 是传递给virtualenv的选项，可以通过virtualenv的帮助获取选项的含义 version 表示Python版本 virtualenv-name 指定虚拟环境名 3.2 使用 pyenv的virtual不用手动去激活环境；当把本地目录与环境相关联起来后，将自动激活虚拟环境，离开目录时自动退出虚拟环境 注意事项： pyenv 下载慢：http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/ 先去官网下载对应版本的源码：https://www.python.org/downloads/source/ 然后创建/.pyenv/cache目录： mkdir /.pyenv/cache (如果已经有该目录直接进入: cd /.pyenv/cache) 然后 pyenv install 3.6.0 打包出错，提示需要 python-dev：https://github.com/pyenv/pyenv/issues/1095 使用以下命令进行安装： PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install 3.6.0 删除虚拟环境 $ pyenv local system $ pyenv virtualenv-delete venv pyenv-virtualenv: remove /home/will/.pyenv/versions/3.4.1/envs/venv? y $ pyenv versions * system (set by /home/will/test/.python-version) 3.4.1 3.4.2 $ pyenv uninstall 3.4.1 pyenv: remove /home/will/.pyenv/versions/3.4.1? y $ pyenv versions * system (set by /home/will/test/.python-version) 3.4.2 Windows 上的虚拟环境管理 Windows 上同样支持 Virtualenv 进行虚拟环境的管理的。步骤与上述差不多。 Windows 不支持 Pyenv 。 安装 virtualenvwrapper 使用 virtualenvwrapper 能够比较容易的使用虚拟环境。 $ pip install virtualenvwrapper-win 创建 虚拟环境 使用 mkvirtualenv 创建虚拟环境。 $ mkvirtualenv -p [python路径] [虚拟环境名称] 环境默认创建地址为：C:\\Users\\[username]\\envs 激活 虚拟环境 使用 workon + [虚拟环境名称] 命令进行激活。 $ workon env1 使用 workon 列出当前的虚拟环境： $ workon 退出虚拟环境： $ deactivate 删除环境： $ rmvirtualenv 复制虚拟环境： $ cpvirtualenv env1 env3 参考：https://www.jianshu.com/p/60f361822a7e ","link":"https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv/"},{"title":"Hwang 的低质阅读单 New 1","content":"Hwang 的低质阅读单 New 这些文章来自 Hwang 的 Instapaper 。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper ，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。 来自 Petra Collins 的“驱魔仪式” | 异视异色｜i-D 中国｜来自VICE的时尚频道 公众号「信息流」改版一周年，有人说没有想的那么糟糕 | 人人都是产品经理 复盘 Evernote：笔记 App 的开山鼻祖，为什么没落了？ 苹果的后 iPhone 时代 无大台的时代 苹果的跨平台计划：如何用 App 打通 iPad 和 Mac PyQt + QML 快速开发GUI总结 2019中国α世代线上娱乐价值观念洞察 | 人人都是产品经理 机器学习能成为因果推断的“圣杯”吗？ 如何用 Python 和 BERT 做多标签（multi-label）文本分类？ 怎么选择数据服务器？请记住这五条 如何用约会软件进行艺术创作？ 亚马逊中国停售纸质书／李楠宣布从魅族离职／京都动画大火已造成 33 人遇难 社交围城里的刷新机器 马斯克的脑机接口来了，USB 连大脑，用 iPhone 操控 | 近未来 ⑫ 早报 | 明年 iPhone 或全线支持 5G vivo 首款 5G 手机或将亏本卖 《哪吒》破动画票房纪录 港真，乱么？ | 可能吧 win10引导错误的修复（内容系转载） - 技术经验 - W3xue AI 语音模仿老板声音要求转账，成功骗走了 173 万 Designing Dark Mode 一篇文章让你彻底搞清楚Python中self的含义 - jessonsh - 博客园 出身清华姚班，斯坦福博士毕业，她的毕业论文成了「爆款」 高清图标SVG解决方案全总结（上） - 文章 - 伯乐在线 高清图标SVG解决方案全总结（下） - 文章 - 伯乐在线 ","link":"https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1/"},{"title":" 用 Python 做计量 （一）—— 初识Python 的计量模块： Statsmodels ","content":" 本文发布于 「 数据Seminar 」公众号：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1569839526&amp;ver=1884&amp;signature=hxZrP-JJKRnGggkDaM2PDBJc7DJsrqQWkpBciqqbDAEeqjNhRKIc37VK4bPqNUKSDjtXPGV0yto99QK5ywqoagPK1PhKPC0dynzFMNVchJWrQG5X3VUMMBadcyBnh7hi&amp;new=1 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}}); 阅读本文前需要掌握的基础知识： Python 的基础知识、 numpy 的基础知识、 pandas 的基础知识 基本的计量知识 如果你还不会，那么本文也会介绍一些 python 语法的基础内容，方便大家理解。 随着数据资源的日渐丰富，学者们越来越多的需要接触到大数据的处理，许多学者还是习惯使用 Stata 对数据进行处理，而 Stata 由于其自身的限制，在处理大数据集时要么需要强劲的处理性能（昂贵的硬件成本），要么需要等待较长时间（更加昂贵的时间成本）。Python 和 R 也就日渐进入学者的视野，相对于 R ，Python 的语法更为简单，成为一部分学者的首选。 在数据处理上，numpy 和 pandas 的组合，使得 Python 能够轻松应对千万级别的数据处理。在攻克数据处理这一环后，在数据应用上，除了新潮的机器学习、深度学习的方法，对于现阶段社科学者来说，计量可能才是最现实的。在 Python 中处理的数据如果还需要调回到 Stata 中做计量，那未免太「蹩脚」。今天，数据Seminar 公众号将带大家体验 Python 上的第三方计量库：Statsmodels 。 简介 Statsmodels 是一个Python的第三方模块，他封装了许多计量模型，方便学者直接调用。所谓封装，就相当于 Stata 中一个 reg 命令，代表了最基础的 OLS 回归命令，在Statsmodels 中也有类似 reg 的语句，提供给 OLS 估计。另外 Statsmodels 的开源协议为 BSD （基本上对于用户来说属于为所欲为协议，你可以任意使用这款扩张包，具体参见链接地址）。 statsmodels is a Python module that provides classes and functions for the estimation of many different statistical models, as well as for conducting statistical tests, and statistical data exploration. An extensive list of result statistics are available for each estimator. The results are tested against existing statistical packages to ensure that they are correct. The package is released under the open source Modified BSD (3-clause) license. The online documentation is hosted at statsmodels.org. 安装： 如果你使用 Anaconda 安装的 python ，那么： conda install statsmodels 如果你使用 pip 管理你的python包，那么： pip install statsmodels # python2 或者： pip3 install statsmodels #python3 “精读”代码，初探：OLS 官方的说明文档：http://www.statsmodels.org/stable/gettingstarted.html 首先先看了一下 OLS 的示例： import numpy as np import statsmodels.api as sm import statsmodels.formula.api as smf dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit() print(results.summary()) 运行后： *(本文采用的编辑器为 Google 的 colab) * 是的，OLS就是这么几行，具体来看内容，其实进行 OLS 回归只需要一行内容。为了方便 Python 基础不那么好的同学，我们驻行“精读”一遍这些代码： 1. 导入模块 import numpy as np import statsmodels.api as sm import statsmodels.formula.api as smf 首先是需要导入 numpy、statsmodels 的相关模块，numpy 推荐的缩写命名 np，statsmodels 推荐的缩写命名是 sm，这样后面的代码就可以通过 np.[具体的函数\\方法] ，sm. [具体的函数\\方法] 的方式来更加简洁的调用了。 2. 生成测试数据集 dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data 由于并没有现成数据，我们可以通过 statsmodels 中自带的数据集，关于该数据集的具体信息可以参考：https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Guerry.html，简单来说，这是一个关于犯罪、识字等相关内容的社会科学领域的数据集。 这个数据集以DataFrame 格式的储存在了 dat 这个变量中。 DataFrame 格式在 Python 中被广泛的使用，可以说无论是机器学习还是本文介绍的计量相关内容，DataFrame 格式相关的操作都需要熟练掌握。关于 DataFrame 的相关内容，需要更加细致的去学习Python的另一个第三方库 pandas ，本文不再赘述。 3. 回归操作 results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit() 首先是smf.ols， smf 就是前面的 statsmodels.formula.api ，OLS 回归的方法在 statsmodels.formula.api下，如果前文没有声明 smf 代表statsmodels.formula.api 的话，你这里可就要写成 statsmodels.formula.api.ols 了，可见合理的缩写声明对于代码的简洁美观非常有帮助。 接下来是括号内的内容('Lottery ~ Literacy + np.log(Pop1831)', data=dat) 这其实是OLS模型需要传入的参数，以,为区隔，第一个参数是回归模型，第二个参数是数据。 在这行代码中，回归模型是：'Lottery ~ Literacy + np.log(Pop1831)'，数据是前面加载的dat ，比较方便的是，statsmodels，直接从数据dat中读取了变量名称，并不需要进行额外的赋值操作。我们具体看一下这个模型的写法，对于没有接触过 Python 和 R 的读者来说，这种写法可能相对有些陌生，其实这个模型代表了： 这种写法参考了R的相关内容，具体是由 Python 中的 Patsy 库实现的。上面这个就是一个计量模型（他当然不是计算 Literacy + np.log(Pop1831)的和，Literacy 和 np.log(Pop1831) 都是矩阵）。这就和 Stata 中 reg y x0 x1 x2 是一样，只是在Python 中模型需要写成y~x0+x1+x2，而 reg 需要写成 smf.ols()。 这个模型中还用到了一个知识点：np.log ，就是说引用了 numpy 中的 log 函数，对变量Pop1831 取对数，就是使用 numpy 进行 log 运算。 如果你直接写 log(Pop1831)，Python是不知道 log 是做什么的，所以要告诉 Python，这个 log 来自于 numpy，这样 Python 就能正常处理 Pop1831 这个数据切片（“切片” 是Python数据处理中常用名词，可以理解为一个 DataFrame 的一列、一行或者几列、几行的数据）了。 最后 data=dat 就是声明对于这个模型，使用的数据时 dat， 这样前面的模型中的 Lottery 、Literacy 和 Pop1831，statsmodels 都能智能的去从 DataFrame 切片（切片操作需要学习Pandas哦），然后应用到模型中。 括号内的内容就是进行回归操作的核心。 括号外还有.fit()，就是告诉 Python，可以进行回归计算了。如果没有这个.fit() ，Python 只会记录这个模型和相关的数据信息，而添加了.fit()，记录时回归后的结果。 （上图可以看到储存在计算机中的内容是有差异的） 同样，.fit() 后输出的结果也并非像 Stata 那样那样直接输出的事结果，而是将结果储存，可以进行多种方式的调用。 如果想输入结果，那么就使用 results.summary() ，将其打印出来，正如示例中展示的那样： OLS 实例 这里简单演示一下 OLS 回归，数据处理这一部分内容，在 Python 中主要使用 numpy 和 pandas，这里就不演示，本文直接读取处理完的数据来演示 OLS 的内容： 本文的数据来自CFPS，主要研究的内容是子女认知能力和服务是否创业的关系，处理后的第一个回归模型的内容主要是，母亲的创业状态（self_employed_m_16），教育年限(edu)，是否参加课外补习(extra_classes)，家庭药品支出(expend_medical)、自评健康状况(health)、家庭氛围(quarrel)、与母亲同住时长(livewith_m)、与父亲同住时常(livewith_f)、log的家庭收入(lg_fin)、子女数量(num_chd)、母亲的受教育程度(edu_m)、父亲的受教育程度(edu_f)、户口(hukou)、东中西部虚拟变量（east 、 west），然后被解释变量就是认知能力(y_rznl)。 import numpy as np import pandas as pd import statsmodels.api as sm import statsmodels.formula.api as smf df = pd.read_csv(&quot;testing.csv&quot;) OLS_1 = smf.ols(&quot;y_rznl~ self_employed_m_16 + edu + extra_classes + \\ expend_medical + health + quarrel + livewith_m + livewith_f + \\ lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot;, data=df).fit() print(OLS_1.summary()) 最后输出结果： 而stata输出的结果（置信区间是97.5%）： 可以看到，结果基本一致。 最后，在OLS这里案例中，可以看到 Python 输出结果基本与 Stata 相同，在代码的撰写上， Python 同样非常方便，并且由于 Python 是一门编程语言，在一些循环的撰写上非常有优势，例如我需要多次循环某几个变量，以及对应的被解释变量： import numpy as np import pandas as pd import statsmodels.api as sm import statsmodels.formula.api as smf df = pd.read_csv(&quot;testing.csv&quot;) y_list =[y1, y2, y3, y4] # 被解释变量的列表 x0_list = [x0_1, x0_2, x0_3, x0_4, x0_5] # 某一个解释变量的列表 model_list = [] for y in y_list: for x0 in x0_list: model = &quot;%s ~ %s + edu + extra_classes + \\ expend_medical + health + quarrel + livewith_m + livewith_f + \\ lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot; % (y, x0) OLS = smf.ols(model, data = df).fit() print(OLS.summary()) 这样就能一次性依次输出，以下内容的回归结果： y1 = x0_1 + edu + extra_calsses +... y1 = x0_2 + edu + extra_calsses +... y1 = x0_3 + edu + extra_calsses +... … y1 = x0_5 + edu + extra_calsses +... y2 = x0_1 + edu + extra_calsses +... y2 = x0_2 + edu + extra_calsses +... … y2 = x0_5 + edu + extra_calsses +... … y4 = x0_5 + edu + extra_calsses +... 所以无论是数据处理还是计量回归中，都能给你极大的便利。 相比Stata，Python 是免费开源的，不需要额外的授权费用，并且如果志在机器学习，那么先从相对熟悉的计量入手或许是一个不错的选择。 ","link":"https://hwang.top/post/yong-python-zuo-ji-liang-yi-chu-shi-python-de-ji-liang-mo-kuai-statsmodels/"},{"title":"如何 在 Windows 的共享文件夹中创建文件图标","content":"Windows 系统中可以通过右键文件夹属性的方式创建文件夹图标。然而，在共享文件夹中并不能直接创建。 🎬 Apply an Icon to a Folder on a NetWork Drive 视频中演示了一种相对曲折的方法在共享文件夹中，创建带有图标的文件夹。 究其原理，其实就是共享文件夹中系统没有创建 desktop.ini 文件的设置（可能是安全原因的考虑？）。 参考：Set custom folder icon for a network folder in Windows file explorer 做法： 这种方法的前提就是你有共享文件夹的写入权限，在windows 10 上已经不能正常使用了 在本地创建一个有 icon 的文件夹； 移动该文件夹到 共享文件夹中； 在弹出窗口中 允许 desktop.ini 的相关选项； 刷新一下共享文件夹 OK ","link":"https://hwang.top/post/ru-he-zai-windows-de-gong-xiang-wen-jian-jia-zhong-chuang-jian-wen-jian-tu-biao/"},{"title":"SQL 的一些内容","content":"MySQL 累计求和 SET @csum := 0; SELECT ADCODE, NAME, (@csum := @csum + ADCODE) AS CUMSUM FROM all_location_data LIMIT 20; 首先 是设置一个变量 @csum 为0 接着 选择要显示的字段，设置一个公式(@csum := @csum + ADCODE) 这里 ADCODE 就是想要 累积加总的变量，将其记为 CUMSUM。 最后加上 FROM all_location_data LIMIT 20; 限制了现实20条。 MySQL 统计某个 字段 不重复的行数 SELECT count(DISTINCT name) AS nu FROM company; ","link":"https://hwang.top/post/sql-de-yi-xie-nei-rong/"},{"title":"Python Pexpect 库的简单入门","content":" 2019.03.26 Hwang 参考： 1.https://www.jianshu.com/p/cfd163200d12 2.https://blog.csdn.net/Cloud_Strife0/article/details/82217494 1. Pexpect 是什么 pexpect 是 Python 语言的类 Expect 实现。 而 expect 主要用于模拟人机对话，简单地说就是可以使用正则匹配捕捉系统的提问（ssh登录需要输入密码等），并且根据捕捉到的提问进行不同的操作。 例子： import pexpect import sys # 用spawn来执行一个指令 child = pexpect.spawn('ftp ftp.openbsd.org') # 用expect等待指定的关键字’name‘ child.expect('(?i)name .*: ') # 若上一步匹配到了，则向计算机输入name child.sendline('anonymous') # 用expect等待指定的关键字’password‘ child.expect('(?i)password') # 若上一步匹配到了，则向计算机输入password child.sendline('pexpect@sourceforge.net') # 用expect等待指定的关键字’ftp&gt;‘ child.expect('ftp&gt; ') # 若上一步成功匹配，则意味着进入了ftp连接，现在做一些操作 child.sendline('cd /pub/OpenBSD/3.7/packages/i386') child.expect('ftp&gt; ') child.sendline('bin') child.expect('ftp&gt; ') child.sendline('prompt') child.expect('ftp&gt; ') child.sendline('pwd') child.expect('ftp&gt; ') print(&quot;Escape character is '^]'.\\n&quot;) sys.stdout.write (child.after) sys.stdout.flush() child.interact() # Escape character defaults to ^] # At this point this script blocks until the user presses the escape character # or until the child exits. The human user and the child should be talking # to each other now. # At this point the script is running again. print('Left interactve mode.') # The rest is not strictly necessary. This just demonstrates a few functions. # This makes sure the child is dead; although it would be killed when Python exits. if child.isalive(): child.sendline('bye') # Try to ask ftp child to exit. child.close() # Print the final state of the child. Normally isalive() should be FALSE. if child.isalive(): print('Child did not exit gracefully.') else: print('Child exited gracefully.') 2. 用法 2.1 spawn() demo_ssh = pexpect.spawn('ssh xxx@&lt;ip&gt;') 如上例中，spawn() 返还的是句柄（handle）[1]，一般用法：spawn(&lt;cmd 命令&gt;) ， 后续的操作都会基于这里定义的变量 demo_ssh 。 注意: spawn() ，或者说 pexpect 并不会转译任何特殊字符 比如 | *字符在Linux的shell中有特殊含义，但是在 pexpect 中不会转译它们，如果在 linux 系统中想使用这些符号的正确含义就必须加上 shell 来运行，这是很容易犯的一个错误。 正确的方式： process = pexpect.spawn('/bin/bash -c &quot;ls -l | grep LOG &gt; log_list.txt&quot;') process.expect(pexpect.EOF) 参数 timeout 设置超时时间（30默认） maxread 缓存设置 默认 2000 字符 searchwindowsize - 模式匹配阀值 logfile - 运行输出控制 logfile_read - 获取标准输出的内容 logfile_send - 获取发送的内容 cwd - 指定命令执行的目录 env - 指定环境变量 ignore_sighup - 是否过滤 SIGHUP 信号 delaybeforesend - 字符发送延时 2.2 expect() 关键字匹配，当spawn 启动一个程序并且返回程序控制句柄后，可以用expect() 来指定匹配内容。 使用 expect() 使用正则表达式来匹配。 2.2.1 expect_exact() 精确匹配，它的使用和 expect() 是一样的，唯一不同的就是它的匹配列表中不再使用正则表达式。 从性能上来说 expect_exact() 要更好一些，因为即使你没有使用正则表达式而只是简单的用了几个字符 expect() 也会先将它们转换成正则表达式模式然后再搜索，但 expect_exact() 不会，而且也不会把一些特殊符号转换掉。 2.2.2expect_list() 预转换匹配，使用方式和 expect() 一样，唯一不同的就是它里面接受的正则表达式列表只会转换一次。 2.2.3 expect_loop() 用于从标准输入中获取内容，loop这个词代表它会进入一个循环，必须要从标准输入中获取到关键字才会往下继续执行。 2.3 send() 发送关键字。用来向程序发送指定的字符串。 2.3.1 sendline() 发送带回车符的字符串。 2.3.2 sendcontrol() 发送控制信号 2.3.3 sendeof() 发送 EOF 信号 2.3.4 sendintr() 发送终止信号 2.4 interact() - 将控制权交给用户 🧡 interact() 表示将控制权限交给用户（或者说标准输入）。一般情况下 pexpect 会接管所有的输入和输出，但有的时候还是希望用户介入，或者仅仅是为了完成一部分工作的时候， interact() 就很有用了。 2.5 close() 停止应用程序 如果想中途关闭子程序，那么可以用 close 来完成，调用这个方法后会返回这个程序的返回值。 如果设置 force=True 会强行关闭这个程序，大概的过程就是先发送 SIGHUP 和 SIGINT 信号，如果都无效的话就发 SIGKILL 信号，反正不管怎么样都会保证这个程序被关闭掉。 多次调用这个方法是允许的，但是不保证每次都能返回正确的返回值。尽量不要这么做，如果想保证程序被关闭的话只要设置force的值就可以了。 2.6 terminate() 可以看作是上面 close() 的别名 2.7 Kill() 发送 SIGKILL 信号，向子程序发送 SIGKILL 的信号。 2.8 flush() 什么都不干，只是为了与文件方法兼容而已。 2.9 isalive() 检查子程序运行状态。 检查被调用的子程序是否正在运行，这个方法是运行在非阻断模式下面的。 如果获得的返回是 True 表示子程序正在运行；返回 False 则表示程序运行终止。 2.10 isatty() 检查是否运行在 TTY （即控制台）设备上 2.11 next() 返回下一行内容，和操作文件一样，这个方法也是返回缓存中下一行的内容。 2.12 read() 返回剩下的所有内容。 获取子程序返回的所有内容，一般情况下我们可以用 expect 来期待某些内容，然后通过 process.before 这样的方式来获取，但这种方式有一个前提：那就是必须先 expect 某些字符，然后才能用 process.before 来获取缓存中剩下的内容。 read() 的使用很不同，它期待一个 EOF 信号，然后将直到这个信号之前的所有输出全部返回，就像读一个文件那样。 一般情况下，交互式程序只有关闭的时候才会返回 EOF ，比如用 by 命令关闭 ftp 服务器，或者用 exit 命令关闭一个 ssh 连接。 这个方法使用范围比较狭窄，因为完全可以用 expect.EOF 方式来代替。当然如果是本机命令，每执行完一次之后都会返回 EOF ，这种情况下倒是很有用： process = pexpect.spawn('ls -l')output = process.read()print output 看起来这么做有点无聊？但我想一定有什么理由支持这个方法。 可以用指定 read(size=-1) 的方式来设置返回的字符数，如果没有设置或者设置为负数则返回所有内容，正数则返回指定数量的内容，返回的内容是字符串形式。 2.13 readlines() - 返回列表模式的所有输出 返回一个列表，列表中的每个元素都是一行（包括\\r\\n字符）。 2.14 setecho() - 子程序响应模式 设置子程序运行时的响应方式，一般情况下向子程序发送字符的时候，这些字符都会在标准输出上显示出来，这样你可以看到你发送出去的内容，但是有的时候，我们不需要显示，那么就可以用这个方法来设置了。 注意，必须在发送字符之前设置，设置之后在之后的代码中都一直有效。比如： process = pexpect.spawn('cat')# 默认情况下，下面的1234这个字符串会显示2次，一次是pexpect返回的，一次是cat命令返回的process.sendline(&quot;1234&quot;)# 现在我们关闭pexpect()的echo功能process.setecho(False)# 下面的字符只会显示一次了，这是由cat返回的process.sendline(&quot;abcd&quot;)# 现在重新开启echo功能，就可以再次看到我们发送的字符了process.setecho(True) 2.15 setwinsize() - 控制台窗口大小 如果子程序是一个控制台（TTY），比如 SSH 连接、 Telnet 连接这种通过网络登陆到系统并发送命令的都算控制台，那么可以用这个方法来设置这个控制太的大小（或者说长宽）。 它的调用方式是 process.setwinsize(r, c) 默认值是 setwinsize(24, 80)，其中 24 是高度，单位是行； 80 是宽度，单位是字符。 为什么要用它？想像下面的场景： 有的时候你通过pexpect登陆到某个ssh控制台之后，又用 interact() 来将控制权交给用户，然后用户到控制台里面写自己的命令，如果命令比较长，就会发现当命令到屏幕边缘之后不会自动换行，而是又返回到这一行的最前面重新覆盖前面的字符；这不会影响命令的实际效果，但是很恼人。 这种情况用 setwinsize() 就可以解决，找到自己终端支持的长度，重新设置一下，比如 setwinsize(25, 96 )，如果设置的正确的话就可以解决了。 2.16 wait() - 执行等待 直到被调用的子程序执行完毕之前，程序都停止（或者说等待）执行。它不会从被调用的子程序中读取任何内容。 2.17 waitnoecho() 它使用的地方比较特殊，唯一匹配的地方就是：当子程序的 echo 功能被设置为 Fals 时。 看起来很奇怪？其实这个功能是基于一个很让人难以置信但的确是真实的情况： 在命令行模式下，很多要求输入密码的地方，比如 FTP/SSH 等，密码实际上都会在你输入之后又重新返回并打印出来的，但是为什么我们看不到我们自己输入的密码呢？这就是因为密码在要打印出来之前被程序将 echo 功能设置为 False 了。 现在知道为什么有这么一个方法了吧？比如要进行一个 ssh 连接时，如何检查是否要输入密码？用关键字 password 是一个方法，但还有一个方法就是这样： # 启动ssh连接 process = pexpect.spawn(&quot;ssh user@example.com&quot;) # 等待echo被设置为False，这就意味着本地不会有回显 process.waitnoecho() process.sendline('mypassword') 可以设置超时时间，默认是：waitnoecho(timeout=-1)，表示和系统设置的超时时间相同，也可以设置为 None 表示永远等待，直到回显被设置为 False ，当然还可以设置其他的数字来表示超时时间。 2.18 write() - 发送字符串 类似于send()命令，只不过不会返回发送的字符数。 2.19 writelines() - 发送包含字符串的列表 类似于 write() 命令，只不过接受的是一个字符串列表， writelines() 会向子程序一条一条的发送列表中的元素，但是不会自动在每个元素的最后加上回车换行符。 与 write() 相似的是，这个方法也不会返回发送的字符数量。 句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。（参见封装）。通俗的说就是我们调用句柄就是调用句柄所提供的服务，即句柄已经把它能做的操作都设定好了，我们只能在句柄所提供的操作范围内进行操作，但是普通指针的操作却多种多样，不受限制。 ↩︎ ","link":"https://hwang.top/post/python-pexpect-ku-de-jian-dan-ru-men/"},{"title":"去思考，去理解，去猜测，《xxx快速入门》指北 ","content":" 本文发布于少数派：https://beta.sspai.com/post/52935 2018年，于我而言是人生中最非同一般的一年，我从大三升到了大四，更为重要的是我从「学习」的状态转变为了「工作」状态。说出来我自己也不信，2018年初我还是一个立志成为「经济学家」的学子，2018年底我却深度参与到了一项创业活动中。我的文档库中从文献笔记，变为了代码与日志。在这之中，需要去适应许多的改变，少数派是一个讲求「效率」的网站，各种「酸甜苦辣」自然按下不表，作为2018年的年度总结，下文我会尝试梳理这一年中对我产生影响的学习「陌生概念」的思路，希望能够为大家提供一些参考。 事先需要声明的是，效率思维看起来太过「空洞」，而本人对于各种思考范式的认识也并非「专家」，所以撰文、用词、举例之中有偏颇之处也请包涵。本文叙述的也只是我本人的经验，并不一定适用于他人。 这一年，我做的最多的事就是在不断做新的事。我是经济学的在读本科生，6个月前，我连 vim 编辑器需要先按 「i」 进入编辑模式才能修改文本都不知道；而现在，我已经能够实现基本的诸如 apache 、nginx 的各种配置了。2018年，我第一次学习了使用命令行的方式操作系统，第一次知道原来有配置文件这种东西，第一次知道了虚拟化这种东西，第一次写了网页，第一次编写了程序，我甚至知道了 Windows 系统在执行打印操作是把文件暂存在C:\\\\WINDOWS\\Spool\\printers 系统文件夹内，然后慢慢发给打印机进行处理的。而且这之中大多数东西，都是下半年才发生的，因为2018年上半年，我每周还有三天是上课的。同事都认为这是因为我「学习能力强」，但是你凭什么就「学习能力强」了？ 我并不觉得，这之中有任何一件事情对我来说是简单的、容易的。 2018年第一次进机房部署服务 这些事都是有外力推动你去做的。大多数人，需要进入一个新的领域时，会选择先从诸如《xxx快速入门》、《xxx快速上手》这样的内容出发，去学习这个领域的东西。但是，由于我往往是有这个需求时，这个项目就要求你需要快速上手，解决问题。基本上不可能让你一步一个脚印的去学习然后等你学会了再去解决这个需求。也就是说，一个外生的变量迫使你不得不快速的进入状态。这个外生变量，直接拒绝「不积跬步，无以至千里」这样的想法。我的解决方法是第一步，先去思考「需要的是什么」；第二步，再去理解你所需要的「对象」大体上是长得什么样的，最后描绘出符合自己需求学习清单，按照理解的步骤学习，按照重要程度进行精力的分配。这种像蜻蜓点水的学习方法，帮助我较为快速的上手解决问题。下面我总结了一些自己的经验： （一）需要的是什么 首先，是明确「需要的是什么」。一开始思考的「需要的是什么」，应当是从需求出发的思考，就是做这件事目的是什么。这个话术的前提是，你对这个需求所需要的背景知识几乎「一无所知」。所以需要优先构建的是这个需求的背景知识。也就是说要先与这个陌生的概念建立联系，并且能够基本定位到这些背景知识在自己已有的知识体系的未知。所以，我一般会进行两步： **1.利用搜索引擎，建立与陌生概念的联系。 **许多时候是相对明确的。例如一个经济学学生，被老师要求学习 Stata ，那么他需要的其实就是：学会使用这个软件进行计量分析。这个就是「目标」，那么假设我是一个对于 Stata 一片空白人。我需要的首先就是 「Stata 是什么？」，这个问题很容易就能在搜索引擎中找到。不过，当我在进行空白的概念理解时，我会多搜索几个关键词，例如「stata 经济学」（空格在一般搜索引擎中都是「和」的意思）。**这是非常重要的一步，因为当你把一个未知概念（stata）与你所知概念（经济学）结合时，出现的内容，大概率是你知晓大半但是不全懂的东西。**也许这个技巧，你觉得这并没有什么了不起的，但是这个习惯就能一下将陌生概念变得更加清晰，消除令人恐惧的陌生感，下图展示了这一步的重要性。 经济学学生在「stata 经济学」的搜索结果中能够很直接获取他正真需要的信息。 简单几轮下来，当你很容易就能把「 Stata 」与「计量经济学」相联系。现实中遇到问题可能并不那么快速，但是这样的方法能够让你更加快速的理解「陌生概念」对于「你所需要的是什么」的相对位置。即这个「陌生概念」，对于你已有的知识体系，所处的位置。例如使用 Stata 是更加「靠近」计量经济学，而不是数理经济学或者其他什么的。这样在头脑地图中有一个比较明确的标的，上手起真正的「未知概念」会有莫大的帮助。 合格的搜索引擎会提供了许多维度的过滤方式——高级检索语法，能够更加快速的搜到你真正需要的东西，在这里提供了一个我自己收集整理的 Google高级语法表 。 **2.把握「规律」来迁移已有的知识。**我一直将知识想象成一个多层的网状的结构，这样的一个「库」，里面的各个元素之间都会有复杂的链接，而我相信这之中会有某种「规律」，能够在较大程度上去解释这些「链接」。而这些「规律」，可以理解为各种思维方法，这些思维方法能够帮助你进行知识点与知识点的链接。这里说的可能有些玄妙了，举例来说，类比的思维方式能够在你理解一个逻辑的前提下，快速理解另一个逻辑。例如当你理解「外网」，是通过 IP 地址来识别各种请求的，这样你去理解内网就非常容易了。再比如，你知道 Stata 中回归的命令是 reg y x1 x2 x3 ，其中 reg 是命令，后面的 y x1 x2 x3 是参数，那么你就能理解ssh -p 10022 admin@192.168.1.1 ，类似的 ssh 也是某种命令， -p 1022 admin@192.168.1.1 都是类似的不同参数。这就是类比的思维去迁移。当然例子中提到的仅仅是类比的思维而已，许多学科的「方法论」内容能够在一定程度上去理解其他的内容（至少经济学在这一方面做的相对不错）。 这两步写了这么大段的文字，但其实在真正操作起来并不复杂，用搜索引擎去搜索不知道的和你知道的关键词，然后去猜测这个「需要的是什么」，在实际中可能只是你坐在电脑前面按两下 Ctrl 键，唤起 Alfred ，键入关键词然后回车，再拿笔写写画画，再按两下 Ctrl 键，再次唤起 Alfred ，键入关键词然后回车的过程。 理解了这个位置概念的基本背景知识，并且有所标的的迁移到已有的知识体系后，你就能基本明确这个陌生概念对于自己目标的实现需要的是什么了。 最后，如果你对自己模式化思维的能力有所怀疑，可以看看几年前的畅销书《思考的快与慢》，应该会有所帮助，如果对经济学的解释感兴趣，可以看看张五常的《经济解释》，非科班出生看第一本就能看到很多关于经济学方法论的内容（虽然没有目前主流的计量内容）。 （二）「对象」长什么样 这种迁移不仅仅对理解「需要什么」有帮助，其实也对厘清「对象长什么样」有帮助。对象长什么样，就是要对这个位置概念又一个较为整体的认识。只要较为整体即可，并不需要非常完整的认识，因为这个认识总是随着知识水平的提高，不断完善的。那些与目前需求无关的连接点，并不需要在快速入门的情况下被关注。 **首先，阅读「前言」性质的内容，快速形成概念的整体认识。 **看前言或者摘要这一类性质的内容，是理解一个概念、一篇文章的捷径。一般作者都会在这里就先整理好这个概念的历史。例如 URL Schemes 使用详解 中，前3部分就是这个性质的内容。阅读这些内容，并不需要多大的基础，集中精力基本都能看懂。这里也没有太多的技巧，唯一有的建议就是看优秀的内容生产者生产的文字会更加节省时间。 其次，对于这些「知识点」的认识，我的思考角度一般是这样的，先从对于员工的我来说这个「陌生概念」是怎么样的，其次是对于公司来说这个「陌生概念」起到的重要程度是怎么样的： **1.这个「陌生概念」在我所做的工作流程中应当处于什么位置。**因为这个「对象长什么样」是对于我来说的，也就是说，我需要理解他对于我来说到底有多重要，然后是对于公司业务来说有多重要。所以，这里「什么位置」主要是为其贴上重要程度的分类、业务流程的分类、技能结构的分类以及其他有助于梳理的标签。例如，我有一段时间被要求去学习 R 语言。那么我基本了解到了，R 主要应用于大数据处理相关的工作，例如大数据的计量、画图等，还在机器学习方面有一定的应用。而我的背景是学习了一些 Python 基础，Python 的应用比 R 广泛，能够覆盖到我一些运维的工作。所以这是一个在我的工作流程中相对不那么重要的事情，但是我依然需要去解决它。在业务上，这是一项我们必须要做的业务，所以我需要的就是把它放在一个「需要被解决的需求」的位置上就可以了。解决完这个问题后，我并不需要过多的再去关注其他领域的东西。第一步就界定好这个「位置」，才能做到下手又轻重，避免不必要的精力花费。 3. 尝试去理解团队对这个需求的要求是什么。 最后一个，对于小团队来说非常适用，因为产品信息可能相对透明。当领导让你去实现一个陌生的需求时，如果有可能，那么去揣度一些产品真正的需求是什么，能够帮助我们判断哪里是需要精益求精的，哪里是会有「加工余量」的，这样能够更加快速的安排工作。这里的建议就是，能够偷懒的地方，需要慎重，因为「坑」一般是要自己填的。理解上级需求的前提是，你是知道公司的产品是怎么样的产品。如果连这个都不知道，那么还是不要做过多的揣度。 除了从个人、团队角度的思考外，还有一种普遍性很强的思维方式，即横向的思考和纵向的思考。1.所谓横向的思考，就是与其他东西做横向的比较，然后得出差异，来标定这个「陌生概念」到底需要多少投入。2.所谓纵向思考，就是在时间线上去理解思考。在学习新事物这件事上，其实主要是考虑未来这个「陌生概念」中会不会有几个部分是对团队非常重要的内容。 最后，总结一下，这一步的思考其实就是需要肢解这个「陌生概念」，然后去理解这个「陌生概念」中的知识点，并尝试划分轻重缓急，为后续有重点的快速入门作准备。我认为这一样是一个思考、理解、猜测的过程。 （三）为自己写下清单 在思考「需要什么」时，可以理解为 GTD 的「收集」工作，因为这些关键词的结果，其实是进行具体的学习与操作的素材。在定位「对象」时，也可以认为在「处理」与「组织」，重点是为厘清后续的操作。在思考完这些事情后，我一般会在 Todoist 中创建具体的任务。一般我至少会打上以下标签： 重要程度：Todoist 中 p1 表示重要，没有标注就表示一般。 难度：困难、简单 时间范围：DDL 表示截止日、 FT（free time）表示闲暇时、Hold 表示需要注意再次安排的，以及具体的时间 精力：专注 ，表示要集中精力做的，没有标注就表示一般。 其他根据具体情况会再添加辅助分类用的标签。 清单写完后，就是根据 Todoist 的任务一项一项进行学习与操作。 少数派之前关于精力管理的文章，让我开始意识到学习中投入精力这件事。以我自己的经验来说，我现在仍然清晰的记着在小学的时候，就习惯在下午 2:30 的时候，搬着小板凳开始写作业，所以我一直以来的习惯就是在下午2-3点的时候精力较为集中，Todoist 的纪录同样验证了这一点。以前自己并没有刻意关注这个问题，但是实际的体验在说明，精力集中时，我自己的脑子就是会更加清晰。自己精力最为充沛的时间段做那些需要集中精力的事情才是最优决策。所以筛选出需要集中精力的任务非常有必要。如果你对于自己何时精力充沛没有认识，可以尝试此前少数派介绍过的精力管理模板。然后这个结果也许会是一种安慰剂，暗示自己能够实现高效的集中精力，完成自己的目标。 大胆的猜测，需要你有更多信息这样能够更好的辅助自己的判断。所以更多的阅读是有必要的。少数派上有不少关于阅读流程的内容，我也参照着学习过，对于 Web 内容我依然使用 RSS 作为主要的信息摄入方式，我也没有将其精简，因为对于我来说，内容没读完并不会让我感到焦虑，我也没有一定要在 RSS 中获得什么的想发，更多的是一种眼界的拓宽，思维的拓展。我十分习惯也热衷于「刷 RSS」 。简单来说，我的阅读流程大概是这样的：在 Reeder 中看简单文章，觉得好的保存道印象笔记中，需要仔细看的发到 Instapaper 中，需要学习的发送到 Goodnotes 中，最后都归档到印象笔记中。我希望自己看到更加看到更加多元的东西，但是我也不想让算法暴露我的癖好，所以我选择用 RSS 来作为主要的信息摄入渠道。 总体来说，我的经验是，如果你需要快速入门一个东西，那么比起抓紧时间，更为重要时期是去思考，去理解。而面对陌生概念，要勇敢的去猜测，去迁移自己的知识，之后才是按照轻重缓急的去学习，去操作。就像前文提到的，本文所提到的方法，并不一定适用于他人。但是，于我而言，这些都是有效的，这些都是影响我的。所以，请去思考，去理解，去猜测，大胆践行自己的思考，为自己所做承担即可。 ","link":"https://hwang.top/post/qu-si-kao-qu-li-jie-qu-cai-ce-lesslessxxx-kuai-su-ru-men-greatergreater-zhi-bei/"},{"title":"Ubuntu 配置VNC服务","content":" 参考资料：https://blog.csdn.net/m0_37041325/article/details/80516041 1. 在服务器中配置 VNC 服务 1.1 安装 xfce4 和 vnc4server $ sudo apt-get install xfce4 $ sudo apt-get install vnc4server 1.2 启动VNC Server $ vncserver 输入后，会提示你需要输入VNC的登录密码，密码至少6位数，并且会生成一份配置文件。配置文件在user的目录下~\\.vnc\\，文件名称是 xstartup 1.3 编辑配置文件 $ vim .vnc/xstartup 内容如下： #!/bin/sh unset SESSION_MANAGER unset DBUS_SESSION_BUS_ADDRESS startxfce4 &amp; [ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources xsetroot -solid grey 默认就会有内容，查看比较一下添加即可。 1.4 删除此前的默认桌面 $ vncserver -kill :1 1.5 重启一下 vncserver vncserver 通过 vncserver -geometry 1920x1080 可以设置分辨率 1.6 使用支持vnc连接的软件连接主机 Ip地址+桌面编号 这么配置的桌面编号是:2 例如： 192.168.50.189:2 然后再输入此前设置的密码即可。 Windows可以使用VNCview 桌面安装的是xfce4所以，和ubuntu默认的桌面样子不太一样。 ","link":"https://hwang.top/post/ubuntu-pei-zhi-vnc-fu-wu/"},{"title":"2018 - 我的主屏","content":" 2018年，对我来说变化太多了。首先总结一下自己手机的软件使用。 第一排 微信：糟糕的高墙。 倍洽：办公用的聊天工具。工作用。 Castro：一个高效便捷好看的播客应用。已订阅。💰 Copied：剪贴板工具。Mac 和 iPhone 上双平台在用。利用一些脚本，可以自动记录一些特殊信息，例如颜色（#0068B8）、淘宝分享信息，并且用以存放常用的文本信息（邮件模板、日常工作等）。iOS上，输入法中切换能够快速输入，对我来说很方便。 第二排 Trello：项目管理工具。工作用。 Outlook：目前主力的邮件 App。邮件处理坚持 「Inbox Zero」，要么去 Todoist，要么去 Evernote，剩下的就是通通进入 achieve。 并不做整理，因为需要整理的都在 Evernote 里。 App store ：🌚 tweetbot ： 用来刷tweet的第三方客户端。只看不发的那种，twitter 第三方政策变动对我来说，其实并没有什么影响。 第三排 文件夹。跳过。 第四排 Evernote ：国区高级版用户+国际版普通用户。是我数字生活的归档箱。所有能够归档的都是归档于此。国际版只是为方便我的阅读流程使用。 Instapaper ： 依然没有换 Pocket ... 是我阅读输入流程中的一环，也是对我来说最重要的软件之一。 Moneywiz ：记账软件。最近开销有点大…… telegram ：主要拿来联系亲人。加了一堆群，几乎不发言。以及用来看各种 channel。 第五排 Timepage ： 老用户，免费送了 iPad 版，相比（其他转订阅的厂商）而言，尽然有些不好意思。用以查看各种日程，离开学校后，明显还没有找到使用日历的节奏。需求并没有那么强了。 Ulysses ： 用「Markdown XL」写作的写作软件。日常工作的文档，非常方便。平时写东西，习惯分节写作，这样能够减少长篇大论的压力感。 极光字典 ：一个查单词的应用，满足我点开即用的需求，并且能够导出历史记录、收藏记录。 NOMO ：拍照软件，满足的需求了打开就能拍。并且一个个好看的相机也满足了收藏癖的虚荣心。VSCO 设置后也能直接打开相机，NOMO 给我的那种精致感，让我选择留它在主页。（说得好像我多会拍照似的） 第六排 Spotify ： 听歌软件。 捷径 ： iPhone、iPad上处理许多流程的重要工具。 Pythonista ：即买了Jsbox，又买了 Pythonista……我也不知道为什么。还不熟悉，能够在捷径中运行python，所以买了。 hyperapp ：经常需要临时操作一下服务器。总体感觉还行，比较而言，在终端的使用体验上，还是 termius 操作更便利一些（一些在手机上的手势操作，让人用的更加舒服）。优势是一些服务的快速部署，以及非常棒的连接方式。 Dock 栏 Todoist ：任务管理，GTD。 Drafts ：碎片收集与整理。 Launch ：启动器。 Reeder ：RSS阅读器。 Launch 中的动作 上至下左至右 Time ：看倒计时 翻译：输入文本翻译 即刻 立即开始番茄钟倒计时 快速创建长截图 切换apple store地区 剪贴板相关的动作：清空剪贴板、剪贴板搜索（ai search、淘宝两个动作）；发送剪贴板内容到Twitter、微博；查单词； Workflow （捷径）相关：主要用来存放一些定期执行的任务。 Person ： 一些个人常用的动作 📱：一个人常用的比较复杂一些的快捷操作 QuickS：搜索聚合。各种搜索。 国内：各种 pay 、扫描二维码、充话费等服务。 Newspaper：用来打开软件看下载客户端的媒体的文章，好奇心日报、Medium、少数派、数字尾巴。 冗余：一些需要打开，又不需要出现在首页上的app。 App 兑换 ：并不常用。 Pic：和图像处理有关的动作：白描、picsew、pico、vsco 等 Bose：连接音箱。 ","link":"https://hwang.top/post/2018-wo-de-zhu-ping/"},{"title":"Qt for Python 学习 —— 看看别人的项目","content":" picpong 一个PyQt 写的图床应用； 项目地址：https://github.com/shuoGG1239/PicPong 文件目录 ./PicPong-master ├── ConfigWidget.py ├── PicPong.py ├── README.md ├── UploadWidget.py ├── ViewWidget.py ├── asset │ ├── config.png │ ├── ... │ └── view_hover.png ├── main.py ├── pyinstaller.py ├── screen_capture.py ├── shuoGG_re.ico ├── ui_ConfigWidget.py ├── ui_...//省略UI ├── ui_ViewWidget.ui └── util ├── __init__.py ├── sm_util.py └── system_util.py 文件1-main.py 程序入口，就20行代码。 from PyQt5.QtGui import QIcon from PyQt5.QtWidgets import QApplication from PicPong import PicPong if __name__ == '__main__': import sys app = QApplication(sys.argv) mainWindow = PicPong() mainWindow.setWindowTitle('PicPong') mainWindow.setWindowIcon(QIcon('./asset/myicon.ico')) mainWindow.setStyleSheet(&quot;QFrame#WindowWithTitleBar{background: #33CCCC}&quot;) mainWindow.setStyleSheet(&quot;QWidget#uploadWidget{background: #FFFFFF}&quot;) # fixSize mainWindow.setSupportStretch(False) mainWindow.setMaxEnable(False) # 不然快捷键失效 mainWindow.mainwidget.setFocus() mainWindow.show() sys.exit(app.exec_()) 设置mianWindow实例 然后设置一些样式、ico 等内容。 修复一些内容。 文件2-PicPong.py 共150行代码，一个 class PicPong 0. 导出的库 from PyQt5.QtCore import pyqtSlot, QSize, QRect, Qt from PyQt5.QtGui import QPixmap, QIcon from PyQt5.QtWidgets import QWidget from QCandyUi.CandyWindow import colorful import ui_PicPong from ConfigWidget import ConfigWidget from UploadWidget import UploadWidget from ViewWidget import ViewWidget from screen_capture import CaptureScreen Qt 相关内容，不太用的是 QRect： QRect类定了平面上的矩形。 一个矩形在内部是由左上角和右下角表示的，但是通常它所表达到是一个左上角和一个大小。 QCandyUi ：一个UI样式库，快速添加UI：https://github.com/shuoGG1239/QCandyUi ConfigWidget、UploadWidget、ViewWidget： 自定义的 Widget 内容 screen_capture： 截图功能 接着是静态资源路径： # 资源路径 ROOT_URL = './asset/' CUT_ICON_URL = 'scissors.png' CONFIG_ICON_URL = 'config.png' SET_ICON_URL = 'set.png' VIEW_ICON_URL = 'view.png' OPEN_FILE_ICON_URL = 'file.png' FRAME_FILE_ICON_URL = 'frame.png' 按规范这里的变量需要大写。 @colorful('blueGreen') class PicPong(QWidget): @colorful('blueGreen') QCandy—UI 提供的装饰器，能够快速的创建颜色UI。 1. 初始化： QWidget.__init__(self) self.ui = ui_PicPong.Ui_picPong() self.ui.setupUi(self) UI初始化 self.widgetUpload = UploadWidget(self) self.widgetUpload.setGeometry(QRect(41, 0, 450, 360)) self.widgetView = ViewWidget(self) self.widgetView.setGeometry(QRect(41, 0, 450, 360)) self.widgetView.hide() self.widgetConfig = ConfigWidget(self) self.widgetConfig.setGeometry(QRect(41, 0, 450, 360)) self.widgetConfig.hide() 将widget设置在布局的位置中 self.widgetUpload = UploadWidget(self) 上面import 的内容 widget 初始化为 传入 self 类。 hide 其他的 widget。 self.widgetUpload.signal_img.connect(self.widgetView.slot_recv_img) self.widgetUpload.signal_response.connect(self.widgetView.slot_recv_resp) self.widgetUpload.signal_fail.connect(self.__slot_showTip) 信号槽绑定，均为自定义信号，具体需要参见 uploadwidget 内的内容。 主要是3个内容，一个是图片，一个是响应，一个是失败的回复 @pyqtSlot(str) def __slot_showTip(self, msg): self.parent().showTip(msg, 'red') 绑定显示信息的咨询 self.__init_style() self.ui.pushButtonCut.setToolTip('ctrl+shift+alt+F8') 接下来是初始化UI 设置按钮提示 2.美化相关： def __init_style(self): self.ui.widgetSide.setStyleSheet(&quot;QWidget{background: #33CCCC;border:none}&quot;) self.widgetUpload.setStyleSheet(&quot;QWidget#uploadWidget{background: #FFFFFF;border:none}&quot;) self.__btn_style3() 设置 styleSheet，进行 __btn_style3() def __btn_style3(self): self.beautify_button3(self.ui.pushButtonUp, ROOT_URL, 'up.png', 'up_hover.png', 'up.png', 'up.png') self.beautify_button3(self.ui.pushButtonView, ROOT_URL, 'view.png', 'view_hover.png', 'view.png', 'view.png') self.beautify_button3(self.ui.pushButtonCut, ROOT_URL, 'scissors.png', 'scissors_hover.png', 'scissors.png', 'scissors.png') self.beautify_button3(self.ui.pushButtonConfig, ROOT_URL, 'config.png', 'config_hover.png', 'config.png', 'config.png') 这里均为运行 self.beautify_button3() def beautify_button3(self, button, root, norm, hover, press, disable): qss = str() qss += &quot;QPushButton{background:transparent; background-image:url(%s); border:none}&quot; % ( root + norm) qss += &quot;QPushButton:hover{background:transparent; background-image:url(%s)}&quot; % ( root + hover) qss += &quot;QPushButton:pressed{background:transparent; background-image:url(%s)}&quot; % ( root + press) qss += &quot;QPushButton:disabled{background:transparent; background-image:url(%s)}&quot; % ( root + disable) button.setStyleSheet(qss) button.setText('') 以上均为设置按钮样式 3.按钮功能 pushButtonUp 的 clicked 事件： @pyqtSlot() def on_pushButtonUp_clicked(self): self.widgetUpload.show() self.widgetConfig.hide() self.widgetView.hide() 点击按钮时，显示 widgetUpload，隐藏其他的 widget pushButtonCut 的 clicked 事件： @pyqtSlot() def on_pushButtonCut_clicked(self): self.minimize() self.capture = CaptureScreen() self.capture.signal_complete_capture.connect(self.__slot_screen_capture) 先最小化主窗口，见 minimize 函数： def minimize(self): if self.widgetConfig.minWhenCut: self.parentWidget().showMinimized() 实例化 CaptureScreen() 绑定自定义信号槽self.capture.signal_complete_capture.connect(self.__slot_screen_capture) 而self.__slot_screen_capture，如下： @pyqtSlot(QPixmap) def __slot_screen_capture(self, pixmap): temp_img_path = 'screenShot.png' pixmap.save(temp_img_path, 'png') self.widgetUpload.run_upload_async(temp_img_path) self.widgetUpload.signal_img.emit(pixmap) 接受QPixmap 对象； 定义文件名称 screenShot.png 保存为png，调用了 QPixmap 的 save 方法：pixmap.save(temp_img_path, 'png') 运行self.widgetUpload 的 run_upload_async(temp_img_path)方法（该方法负责开进程上传，然后显示动画），然后发送自定义信号signal_img.emit(pixmap)，该信号绑定了：self.widgetUpload.signal_img.connect(self.widgetView.slot_recv_img) 需要参考 widgetView中的函数； pushButtonView 的 clicked 动作 显示 widgetView，隐藏其他的 widget。 pushButtonConfig 的 clicked动作 一样是显示widget 键盘事件 def keyPressEvent(self, e): 键盘事件，不是很会，下次再学。 文件3 UploadWidget.py import json import os import threading from PyQt5.QtCore import pyqtSlot, QFileInfo, pyqtSignal, QSize from PyQt5.QtGui import QMovie, QPixmap, QIcon from PyQt5.QtWidgets import QWidget, QFileDialog, QLabel import ui_UploadWidget from util import sm_util from util import system_util ` 倒入内置库，Qt相关库以及 自己写的 util 包 开始依然是全局路径。 初始化 先定义了几个信号槽： class UploadWidget(QWidget): signal_fail = pyqtSignal(str) signal_response = pyqtSignal(str) # sm应答信号 signal_img = pyqtSignal(QPixmap) 第一个是失败时的信号，接受 str 字符串 第二个是响应，接受str字符串 第三个是接受 QPixmap对象 def __init__(self, parent): QWidget.__init__(self, parent) self.ui = ui_UploadWidget.Ui_uploadWidget() self.ui.setupUi(self) self.setAcceptDrops(True) self.ui.pushButtonUpload.setAcceptDrops(False) self.signal_response.connect(self.__slot_sm_response) self.__init_loading_gif() self.__init_style() 初始化UI，传入了一个 parent 参数。 设置允许拖拽。不允许按钮 .ui.pushButtonUpload.拖拽。 绑定信号到槽的，槽函数 self.__slot_sm_respons。 初始化加载动画，初始化样式： 初始化style： def __init_style(self): &quot;&quot;&quot; 带button外壳的imageButton :return: &quot;&quot;&quot; self.setStyleSheet(&quot;QWidget#widgetView{background: #FFFFFF;border:none}&quot;) self.__btn_style3() 这里面self.__btn_style3(): def __btn_style3(self): &quot;&quot;&quot; 三态button :return: &quot;&quot;&quot; self.beautify_button3(self.ui.pushButtonUpload, ROOT_URL, 'upload.png', 'upload_hover.png', 'upload.png', 'upload.png') def beautify_button3(self, button, root, norm, hover, press, disable): qss = str() qss += &quot;QPushButton{background:transparent; background-image:url(%s); border:none}&quot; % ( root + norm) qss += &quot;QPushButton:hover{background:transparent; background-image:url(%s)}&quot; % ( root + hover) qss += &quot;QPushButton:pressed{background:transparent; background-image:url(%s)}&quot; % ( root + press) qss += &quot;QPushButton:disabled{background:transparent; background-image:url(%s)}&quot; % ( root + disable) button.setStyleSheet(qss) button.setText('') 初始化 加载动画 def __init_loading_gif(self): &quot;&quot;&quot; 初始化loading动画 :return: &quot;&quot;&quot; gif = QMovie(ROOT_URL + LOADING_GIF_URL) gif.start() x, y = 190, 110 self.loadingLabel = QLabel(self) self.loadingLabel.setMovie(gif) self.loadingLabel.adjustSize() self.loadingLabel.setGeometry(x, y, self.loadingLabel.width(), self.loadingLabel.height()) self.loadingLabel.setVisible(False) 这个初始化函数，生成了一个 父对象为 'self' 的 self.loadingLabel QLabel 的对象。 按钮与信号 pushButtonUpload 的 clicked @pyqtSlot() def on_pushButtonUpload_clicked(self): self.ui.lineEdit.clear() img_full_path = QFileDialog.getOpenFileName()[0] if img_full_path is None or img_full_path == '': return _, name = os.path.split(img_full_path) self.signal_img.emit(QPixmap(img_full_path)) self.run_upload_async(img_full_path) self.ui.lineEdit.clear() self.ui 是 ui_uploadWidget 的 ui。清除 lineEdit。 img_full_path = QFileDialog.getOpenFileName()[0] 打开 GUI 文件选择器 （QFileDialog） 获得打开的文件路径。 .getOpenFileName()[0] 切出来的就是文件路径了。 -if img_full_path is None or img_full_path == '': 检查非空。如果是空的话 return ，直接跳过。 -_, name = os.path.split(img_full_path) 没有 -self.signal_img.emit(QPixmap(img_full_path)) 发送信号 -self.run_upload_async(img_full_path) 运行上传动作，上传动作上面以及解释过来。 @pyqtSlot(str) def __slot_sm_response(self, resp_json): self.loadingLabel.hide() if resp_json is not '': ret = json.loads(resp_json) md_image = '![' + ret['filename'] + '](' + ret['url'] + ')' self.ui.lineEdit.setText(md_image) system_util.set_clipboard_text(md_image) self.loadingLabel.hide() 隐藏加载项 if resp_json is not '': 传入参数不为空： 读取字符串为为dict，命名ret； md_image: md 的字符串模板； 将lineEdit 的文本设置为 md_image system_util.set_clipboard_text(md_image) 拷贝到剪贴板。 这里注意下 util 下的文件结构： util 内有一个空的__init__.py文件，导入时执行。 system_util.py 内没有class 类，都是函数。 这样导入时可以避免实例化 def dragEnterEvent(self, event): if (event.mimeData().hasUrls()): event.acceptProposedAction() def dragMoveEvent(self, event): if (event.mimeData().hasUrls()): event.acceptProposedAction() def dropEvent(self, event): if (event.mimeData().hasUrls()): self.ui.lineEdit.clear() urlList = event.mimeData().urls() fileInfo = QFileInfo(urlList[0].toLocalFile()) img_full_path = fileInfo.filePath() self.signal_img.emit(QPixmap(img_full_path)) self.run_upload_async(img_full_path) event.acceptProposedAction() 拖拽动作，前面两个至接受mimeData() 内带有 Urls的内容。 def dropEvent(self, event): 为需要执行的动作： 清理 lineEdit； 获取 Url list 获取文件信息：fileInfo = QFileInfo(urlList[0].toLocalFile()) 获取图片路径： img_full_path = fileInfo.filePath() 发送信号：self.signal_img.emit(QPixmap(img_full_path)) 运行上传背景动作； event.acceptProposedAction() 完成拖放动作。 文件4 ViewWidget.py 0.初始化 def __init__(self, parent): QWidget.__init__(self, parent) self.ui = ui_ViewWidget.Ui_widgetView() self.ui.setupUi(self) self.del_url = str() 前三行，初始化UI self.del_url = str() 初始化一个字符串 1.信号槽函数： slot_recv_img，接收一个 QPixmap 对象。 @pyqtSlot(QPixmap) def slot_recv_img(self, pixmap): self.__set_image(pixmap) 对 QPixmap 执行__set_image()方法： def __set_image(self, pixmap): &quot;&quot;&quot; pixmap适应label :param label: :param pixmap: :return: &quot;&quot;&quot; label = self.ui.labelImage if pixmap.width() &gt; self.ui.labelImage.width() or pixmap.height() &gt; self.ui.labelImage.height(): label.setPixmap(pixmap.scaled(label.width(), label.height(), Qt.KeepAspectRatio)) else: label.setPixmap(pixmap) 这里首先是初始化了一个 labelImage 对象，在 UI 文件中： self.labelImage = QtWidgets.QLabel(widgetView) self.labelImage.setGeometry(QtCore.QRect(18, 10, 411, 261)) self.labelImage.setFrameShape(QtWidgets.QFrame.Box) self.labelImage.setText(&quot;&quot;) self.labelImage.setAlignment(QtCore.Qt.AlignCenter) self.labelImage.setObjectName(&quot;labelImage&quot;) 这是一个父类是 widgetView 的 QLabel 对象。 之后比较传入的 QPixmap 和 Qlabel 对象的宽度、高度：如果传入太大，则以缩略图设置QLabel对象。 @pyqtSlot(str) def slot_recv_resp(self, resp_json): if resp_json is not '': ret = json.loads(resp_json) self.del_url = ret.get('delete') 接着：slot_recv_resp 信号槽接受 一个 json 格式的字符串。如果非空，则： 改为字典，设置 self.del_url 为 字典中的 'delete' 文本。 然后是一个删除按钮： @pyqtSlot() def on_pushButtonDel_clicked(self): print('del: ' + self.del_url) if self.del_url is not None and self.del_url is not '': threading.Thread(target=sm_util.delete_img, args=(self.del_url,)).start() self.del_url = '' self.ui.labelImage.clear() 如果 self.del_url 不为空： 进行进程： target=sm_util.delete_img ： def delete_img(del_url): requests.get(del_url) 传入的参数为：args=(self.del_url,) 然后将 self.del_url 这个变量清空； 再将 labelImage 清空； 其他么的了。 文件5 ConfigWidget.py def __init__(self, parent): QWidget.__init__(self, parent) self.ui = ui_ConfigWidget.Ui_configWidget() self.ui.setupUi(self) self.minWhenCut = self.ui.checkBoxMin.isChecked() @pyqtSlot(int) def on_checkBoxMin_stateChanged(self, state): if state == 0: self.minWhenCut = False else: self.minWhenCut = True 这里有一个知识点，checkBox 的状态为数值状态记录的，所以型号槽绑定的时候可以用int来接受state状态。 文件6 screen_capture.py 这个是实现截图功能的 from PyQt5.QtGui import QPixmap, QGuiApplication, QColor, QPen, QPainter from PyQt5.QtWidgets import QWidget, QApplication from PyQt5.QtCore import Qt, pyqtSlot, pyqtSignal, qAbs, QRect 导入诸如 QPen、QPainter qAbs这我不怎么熟悉的库。 首先是函数的功能都是写在一个类 CaptureScreen 里面的 class CaptureScreen(QWidget): &quot;&quot;&quot; 截屏: 使用时仅需直接new一个该实例即可出现全屏的截屏界面 &quot;&quot;&quot; load_pixmap = None screen_width = None screen_height = None is_mouse_pressed = None begin_pos = None end_pos = None capture_pixmap = None painter = QPainter() signal_complete_capture = pyqtSignal(QPixmap) 一些布尔值之的设定，都是 None，然后是实例化一个 QPainter对象。 S 定义一个信号signal_complete_capture 具体的，初始化中： def init(self): QWidget.init(self) self.init_window() self.load_background_pixmap() self.setCursor(Qt.CrossCursor) self.show() 实例化一个 QWidget 对象。 运行init_window() ``` def init_window(self): self.setMouseTracking(True) self.setWindowFlags(Qt.FramelessWindowHint) self.setWindowState(Qt.WindowActive | Qt.WindowFullScreen) ``` 这里有一些设置： 1.`setMouseTracking(True)`这个属性保存的是窗口部件跟踪鼠标是否生效。 2.设置无边框 3.设置桌面窗口处于激活状态。设置激活为全屏。 load_background_pixmap() 截取当前屏幕的图片： def load_background_pixmap(self): # 截下当前屏幕的图像 self.load_pixmap = QGuiApplication.primaryScreen().grabWindow(QApplication.desktop().winId()) self.screen_width = self.load_pixmap.width() self.screen_height = self.load_pixmap.height() 1. QGuiApplication.primaryScreen().grabWindow(QApplication.desktop().winId()) 截图操作。 2. 获取截图的长度与宽度。 setCursor参考：https://doc-snapshots.qt.io/qtforpython/PySide2/QtGui/QCursor.html 是用来设置鼠标样式的。这里就是把鼠标设置为十字架样式。 初始化结束后，应当是获取一张当前全屏幕的截图，然后获得self.screen_width 与 self.screen_height 全局变量，鼠标变为十字架样式。开始监控鼠标行为。 接下来为鼠标行为： def mousePressEvent(self, event): if event.button() == Qt.LeftButton: self.is_mouse_pressed = True self.begin_pos = event.pos() if event.button() == Qt.RightButton: self.close() return QWidget.mousePressEvent(self, event) def mouseMoveEvent(self, event): if self.is_mouse_pressed is True: self.end_pos = event.pos() self.update() return QWidget.mouseMoveEvent(self, event) def mouseReleaseEvent(self, event): self.end_pos = event.pos() self.is_mouse_pressed = False return QWidget.mouseReleaseEvent(self, event) def mouseDoubleClickEvent(self, event): if self.capture_pixmap is not None: self.signal_complete_capture.emit(self.capture_pixmap) self.close() 一共四个函数，需要后续再学习鼠标事件的相关内容。 mousePressEvent： 先判断点击事件，如果是leftButton 左键点击，那么开始，右键点击则取消。 记住位置 envt.pos() ：由pos()获取的位置是主窗口（widget窗口）左上角（边框的左上角，外左上角）相对于电脑屏幕的左上角的（x=0,y=0）偏移位置 2.mouseMoveEvent ： 做鼠标移动事件，如果已经点击来左键，就开始记录 end_pos 的位置。 mouseReleaseEvent 鼠标释放的动作，获取的self.end_pos的位置； 将变量self.is_mouse_pressed = False重置为 False。 4.mouseDoubleClickEvent 鼠标双击动作，如果 self.capture_pixmap 不为空，则发送信号，并关闭。 接下来是重绘事件： def paintEvent(self, event): self.painter.begin(self) shadow_color = QColor(0, 0, 0, 100) # 阴影颜色设置 self.painter.setPen(QPen(Qt.blue, 1, Qt.SolidLine, Qt.FlatCap)) # 设置画笔 self.painter.drawPixmap(0, 0, self.load_pixmap) # 将背景图片画到窗体上 self.painter.fillRect(self.load_pixmap.rect(), shadow_color) # 画影罩效果 if self.is_mouse_pressed: selected_rect = self.get_rect(self.begin_pos, self.end_pos) self.capture_pixmap = self.load_pixmap.copy(selected_rect) self.painter.drawPixmap(selected_rect.topLeft(), self.capture_pixmap) self.painter.drawRect(selected_rect) self.painter.end() # 重绘结束 注释已经写了，大致就是将背景图画出来，并且根据鼠标事件得到的：self.begin_pos, self.end_pos位置。 这里用到来 get_rect 函数： def get_rect(self, beginPoint, endPoint): width = qAbs(beginPoint.x() - endPoint.x()) height = qAbs(beginPoint.y() - endPoint.y()) x = beginPoint.x() if beginPoint.x() &lt; endPoint.x() else endPoint.x() y = beginPoint.y() if beginPoint.y() &lt; endPoint.y() else endPoint.y() selected_rect = QRect(x, y, width, height) # 避免宽或高为零时拷贝截图有误 # 可以看QQ截图，当选取截图宽或高为零时默认为2 if selected_rect.width() == 0: selected_rect.setWidth(1) if selected_rect.height() == 0: selected_rect.setHeight(1) return selected_rect ","link":"https://hwang.top/post/qt-for-python-xue-xi-kan-kan-bie-ren-de-xiang-mu/"},{"title":"ML - Python 实现 OLS","content":" 几种回归的尝试 标准回归 OLS from numpy import * def loadDataSet(fileName): #general function to parse tab -delimited floats numFeat = len(open(fileName).readline().split('\\t')) - 1 #get number of fields dataMat = []; labelMat = [] fr = open(fileName) for line in fr.readlines(): lineArr =[] curLine = line.strip().split('\\t') for i in range(numFeat): lineArr.append(float(curLine[i])) dataMat.append(lineArr) labelMat.append(float(curLine[-1])) return dataMat,labelMat def standRegres(xArr,yArr): xMat = mat(xArr); yMat = mat(yArr).T xTx = xMat.T*xMat if linalg.det(xTx) == 0.0: print #&quot;This matrix is singular, cannot do inverse&quot; return ws = xTx.I * (xMat.T*yMat) return ws def lwlr(testPoint,xArr,yArr,k=1.0): xMat = mat(xArr); yMat = mat(yArr).T m = shape(xMat)[0] weights = mat(eye((m))) for j in range(m): #next 2 lines create weights matrix diffMat = testPoint - xMat[j,:] # weights[j,j] = exp(diffMat*diffMat.T/(-2.0*k**2)) xTx = xMat.T * (weights * xMat) if linalg.det(xTx) == 0.0: print #&quot;This matrix is singular, cannot do inverse&quot; return ws = xTx.I * (xMat.T * (weights * yMat)) return testPoint * ws def lwlrTest(testArr,xArr,yArr,k=1.0): #loops over all the data points and applies lwlr to each one m = shape(testArr)[0] yHat = zeros(m) for i in range(m): yHat[i] = lwlr(testArr[i],xArr,yArr,k) return yHat xArr,yArr=loadDataSet('ex0.txt') ws=standRegres(xArr,yArr) xMat=mat(xArr) yMat=mat(yArr) yHat = xMat*ws import matplotlib.pyplot as plt fig=plt.figure() ax =fig.add_subplot(111) ax.scatter(xMat[:,1].flatten().A[0],yMat.T[:,0].flatten().A[0]) xCopy = xMat.copy() xCopy.sort(0) yHat=xCopy*ws ax.plot(xCopy[:,1],yHat,'cx--') plt.show() from numpy import * def loadDataSet(fileName): # general function to parse tab -delimited floats numFeat = len(open(fileName).readline().split('\\t')) - 1 # get number of fields dataMat = []; labelMat = [] fr = open(fileName) for line in fr.readlines(): lineArr =[] curLine = line.strip().split('\\t') for i in range(numFeat): lineArr.append(float(curLine[i])) dataMat.append(lineArr) labelMat.append(float(curLine[-1])) return dataMat,labelMat def standRegres(xArr,yArr): xMat = mat(xArr); yMat = mat(yArr).T xTx = xMat.T*xMat if linalg.det(xTx) == 0.0: print #&quot;This matrix is singular, cannot do inverse&quot; return ws = xTx.I * (xMat.T*yMat) return ws def lwlr(testPoint,xArr,yArr,k=1.0): xMat = mat(xArr); yMat = mat(yArr).T m = shape(xMat)[0] weights = mat(eye((m))) for j in range(m): # next 2 lines create weights matrix diffMat = testPoint - xMat[j,:] # weights[j,j] = exp(diffMat*diffMat.T/(-2.0*k**2)) xTx = xMat.T * (weights * xMat) if linalg.det(xTx) == 0.0: print # &quot;This matrix is singular, cannot do inverse&quot; return ws = xTx.I * (xMat.T * (weights * yMat)) return testPoint * ws def lwlrTest(testArr,xArr,yArr,k=1.0): # loops over all the data points and applies lwlr to each one m = shape(testArr)[0] yHat = zeros(m) for i in range(m): yHat[i] = lwlr(testArr[i],xArr,yArr,k) return yHat xArr , yArr = loadDataSet('ex0.txt') lwlr(xArr[0],xArr,yArr,1.0) lwlr(xArr[0],xArr,yArr,0.001) yHat=lwlrTest(xArr,xArr,yArr,0.03) yHat2=lwlrTest(xArr,xArr,yArr,0.01) yHat3=lwlrTest(xArr,xArr,yArr,0.1) xMat=mat(xArr) yMat=mat(yArr) strInd = xMat[:,1].argsort(0) xSort=xMat[strInd][:,0,:] import matplotlib.pyplot as plt fig=plt.figure() ax=fig.add_subplot(111) ax.plot(xSort[:,1],yHat[strInd],label='k=0.03') ax.plot(xSort[:,1],yHat2[strInd],label='k=0.01') ax.plot(xSort[:,1],yHat3[strInd],label='k=0.1') ax.scatter(xMat[:,1].flatten().A[0],yMat.T[:,0].flatten().A[0],s=2,c='green') plt.legend() plt.show() ","link":"https://hwang.top/post/ml-python-shi-xian-ols/"},{"title":"ML- Python 岭回归","content":"def ridgeRegres(xMat,yMat,lam=0.2): xTx = xMat.T*xMat denom = xTx + eye(shape(xMat)[1])*lam if linalg.det(denom) == 0.0: print &quot;This matrix is singular, cannot do inverse&quot; return ws = denom.I * (xMat.T*yMat) return ws def ridgeTest(xArr,yArr): xMat = mat(xArr); yMat=mat(yArr).T yMean = mean(yMat,0) yMat = yMat - yMean #to eliminate X0 take mean off of Y #regularize X's xMeans = mean(xMat,0) #calc mean then subtract it off xVar = var(xMat,0) #calc variance of Xi then divide by it xMat = (xMat - xMeans)/xVar numTestPts = 30 wMat = zeros((numTestPts,shape(xMat)[1])) for i in range(numTestPts): ws = ridgeRegres(xMat,yMat,exp(i-10)) wMat[i,:]=ws.T return wMat ","link":"https://hwang.top/post/ml-python-ling-hui-gui/"},{"title":"Kepler.gl 不需要一行代码！玩转酷炫的数据地图","content":"本文以及发布在 少数派：https://beta.sspai.com/post/55655 在处理数据的过程中，如何“优雅”的展示这些数据一直是一个重要的技巧。而为基于地理坐标为数据打点更是一个重要的技能。在过去，我们的常见的做法是通过诸如 Stata、R、或者是 Python 这些工具来进行这一步的。而这些方法无一例外，都需要对一定的编程技巧。此次我们介绍的数据可视化工具，可以让你不需要任何编程基础，即可实现数据地图的可视化！ 简介 Kepler.gl is a powerful open source geospatial analysis tool for large-scale data sets. Kepler.gl 是一个图形化的数据可视化工具，基于 Uber 的大数据可视化开源项目 deck.gl (http://uber.github.io/deck.gl/#/) 创建的 demo app。 使用 简单介绍了 Kepler.gl 的来历后，我们着重介绍一下，如何使用这个酷炫的开源工具。 一、访问 Kepler.gl Kepler.gl 是一个网页应用，只要在浏览器中输入** Kepler.gl **即可开始使用这个工具。需要提醒的是，最好使用 Chrome 浏览器访问。 （域名就是 Kepler.gl） 点击 GET STARTED 即可开始使用_（如果点击后无法打开，请尝试切换到 Chrome 浏览器）_ 。 二、添加数据 如果没有数据，想先学习一下这个工具，可以参考后面关于网站提供的 sample data 的内容。 （选择准准备好的数据） 支持的数据类型 Kepler.gl 支持 3 种数据格式，分别是： csv、JSON、GeoJSON 。部分地图种类只支持 GeoJSON 格式的数据。 1. 关于 CSV 文件 我们常用的 Excel 文件格式是 xlsx， 需要另存为 csv 文件。 （另存为格式选为 csv） 关于csv 文件，这里还需要说明一下： Kepler.gl 目前对中文支持并不那么好，所以变量名称最好用英文，不然在显示时会乱码。导致自己都不知道这组数据是哪个变量。 Kepler.gl 的地理信息即经纬度信息需要经度一个组，纬度一个组。并且，Kepler.gl 能够自动识别经纬度信息，不过需要你在给经纬度命名时采用：&lt;name&gt;_lat 和 &lt;name&gt;_lng 或者 &lt;name&gt;_latitude 和 &lt;name&gt;_longitude，或者 &lt;name&gt;_lat and &lt;name&gt;_lon。 其中&lt;name&gt;是自选的变量名称。 关于 csv 文件的更多说明，可参加官方文档的内容：https://github.com/uber/kepler.gl/blob/master/docs/b-kepler-gl-workflow/a-add-data-to-the-map.md 2. 关于 JSON 文件 JSON 格式是常见的用于数据传输的文件格式。语言描述容易显得太过复杂，我们举一个简单的例子（一看就会的那种）： 一份JSON格式文件是这样的[1]： { &quot;people&quot;: [ { &quot;firstName&quot;: &quot;王&quot;, &quot;lastName&quot;: &quot;小明&quot; }, { &quot;firstName&quot;: &quot;陈&quot;, &quot;lastName&quot;: &quot;小红&quot; } ] } 这么看，大概有些人已经猜到了，其实这个数据列成表格就是这样的： 这就是JSON 格式文件所实现的功能。可以简单的理解为将“一个表格的数据，用文字表述”。 2. 关于 GeoJSON 文件 而 GeoJSON 是常见的一种地理信息的文件格式，在原有的json格式基础上，添加了地理信息相关的内容。如何添加的呢？就是基于大家约定俗成的规范，然后声明地理位置信息。其实 GeoJSON 是 JSON 的一个子集。基本的语法结构上，两者其实是一样的，都是一个 Dictionary 对应一个 Value 。但是不同点在于，GeoJSON 通过特定的 Dictionary 来确定特定类型、特点功能的 Value。 为了理解 GeoJSON ，我们来看一个实例： { &quot;type&quot;: &quot;Feature&quot;, &quot;properties&quot;: { &quot;adcode&quot;: 110000, &quot;name&quot;: &quot;北京市&quot;, &quot;center&quot;: [ 116.405285, 39.904989 ], &quot;centroid&quot;: [ 116.41989, 40.189913 ], &quot;childrenNum&quot;: 16, &quot;level&quot;: &quot;province&quot;, &quot;subFeatureIndex&quot;: 0, &quot;acroutes&quot;: [ 100000 ], &quot;parent&quot;: { &quot;adcode&quot;: 100000 } }, &quot;geometry&quot;: { &quot;type&quot;: &quot;MultiPolygon&quot;, &quot;coordinates&quot;: [...(篇幅限制，省略)... ] } } 这是一份记录北京市信息的GeoJSON文件。首先，我们能够看到，最外层是三个Dictionary：“type”、“properties”、“geometry”。其中type确定的是其下 Dictionary 的类型。 “Feature” 表示 其对象为“特征对象”。“特征对象”必须包含 “properties”和“geometry”两个类型的成员，两者之间并没有顺序的差异。 **“properties”**里包含的各种「变量」和「值」。例如案例中：“adcode”，表示邮编，北京为110000；“na me”，表示名称，北京市；“center”为地理中心，经纬度坐标需用[]包裹住，这样才是完整的一组数据。其他信息也是类似的，这里不再赘述。 **“geometry”**则是表示几何信息。几何信息有多种类型，“type”标注了这些信息的种类，具体的主要有以下几种： Point 即点图。相当于在地图上画一个点。 Multipoint 即多点图，用于地图打点，可以包含多个点的集合。 LineString 即线。相当于在地图上画一条线。 MultiLineString 同理，多天线。 Polygon 多边形。在地图上用一个多边形围住一个范围。 MultiPolygon 多组多边形。 GeometryCollection 几何集合。（相当于多层嵌套） 更多信息可参考： 使用 sample data 来学习 如果没有数据怎么办？ 网站很贴心的提供了9个数据集，供大家学习上手。其中有诸如加利福尼亚地震数据、2017年美国失业率数据等内容，这些数据都提供下载。其中部分数据采用的是 GeoJSON 格式的数据，可供大家下载学习。 编辑数据地图 我们选择一了地震数据集来做演示。首先简单介绍一下这个数据： 这个数据集主要包括了时间信息（DataTime）、地理位置信息（Latitude 和 Longitude）、以及其他描述地震的信息。 所以，在数据地图中他是如何展示的呢？ Kepler.gl 根据地理位置信息和地震信息标注点的位置和大小颜色。然后更加下方的时间轴范围展示一张图里显示的数量。并且可以根据时间轴“动起来”，效果如下： 看完了效果，我们大致能够了解 Kepler.gl 能够将数据可视化实现到怎么样的程度。接着让我看看更为具体的编辑界面吧，这才是我们需要学习的内容： 工具栏 Kepler.gl 设置项分为4个工具栏，左其分别是 Layers （图层）、Filters （过滤）、Interaction（交互）、Base map （底层地图）。 四者的作用可以概括为： Layers （图层）：数据展示的图层， 位于底层地图上面。就是我们导入的数据后，控制样式的图层。 Filters （过滤器）：用以过滤数据。例如，上图中时间轴就是一个过滤器，用以过滤时间段，显示相同时间段的数据。 Interaction（交互）：即鼠标移动时显示的数据信息。 Base map （底层地图）：就是最底层地图样式。有4种样式可选。 Layers 的设置 所以，我们需要着重注意的是 Layers 的设置。 图层可以设置多个，上面的图层会遮盖下面的图层。可以通过左边的眼睛按钮选择显示或者隐藏图层。 鼠标移动到图层横条后可以对其进行排序（按住左边几个小方格点，拖拽即可）、重命名或者删除等操作。 1. 图层中的 Basic 设置。 这里可以选择需要地图类型： 一共有9种。每一种地图的类型对于数据要求也不同。例如 Arc 和 Line 图，就需要有两组经纬度坐标。 Polygon 就要求使用 geojson 格式的文件。具体设置大同小异，本文就以最基础的 Point 点图为例讲解。 选择了 Point 后，如果没有自动匹配经纬度，那么需要手动选择经纬度变量： lat：纬度 （加* 为必填项目） lng: 经度 altitude ：海拔 （选填项） 2.图层中的 color 设置 Kepler.gl 提供了丰富的色彩设置选项。首先是有多种组合完成的配色方案可供选择。我们还能够选择最高20种颜色的搭配。 color based on 的选项是决定色彩的变量。例如地震案例中选择 magnitude （级数）来确定颜色。 color scale 选择颜色的分布形式。有 quantize （量化） 和 quantile （四分位数）两组分布 opacity 透明度。控制点的透明度。 3. Radius 半径设置 radius range 设置半径范围 radius based on 半径依据。案例中依然是按照震级来的 fixed radius to meter 确定到地图实际的米数。就是将点标记到实际地理位置上按比例设置半径。如下图： **4.Draw Outline 描边 ** 打开这个按钮会将实色圈变为空心的圈： 5. High Precision Rendering 高精度绘图 打开按钮会使得绘图精度更高。 6. enable height 高度 部分种类的地图还提供高度选项，这样就能绘制出3D的数据地图了，如图： 这是用震源深度最为作为高度的数据地图。 Filters Filters 除了为地图增加时间轴外，更为主要功能还是针对某一变量进行数据的过滤，例如过滤掉浅源的地震： Interactions Interactions 其实就是设置鼠标点击时，显示的样式。通过 dataset 中的变量，选择添加显示的内容。 Base map 最后的 Base map 其实也很简单，选择深色或者浅色主题的底层地图： 通过 map layers 选择要显示在地图上的内容： 当然高级玩家也可以自定义地图样式： 最后，如果还有其他问题，可以参考：https://github.com/uber/kepler.gl/blob/master/docs/a-introduction.md Kepler.gl 的官方说明文档。 小tips： 地图经纬度信息，可以通过百度地图的这个网址查找：http://api.map.baidu.com/lbsapi/getpoint/index.html。也可通过百度地图api 获得相关信息。 当然，网上下载的文件可能并不那么“清晰”，你可以搜索在线的json编辑器，将其格式化（就是按照规范换行）。本文提供一个简单的链接：http://tool.oschina.net/codeformat/json ↩︎ ","link":"https://hwang.top/post/keplergl-bu-xu-yao-yi-xing-dai-ma-wan-zhuan-ku-xuan-de-shu-ju-di-tu/"},{"title":"《会读才会写》的读书笔记——利用标签来整理阅读内容","content":" 本文以及发布于少数派：https://beta.sspai.com/post/45883 引子 社会科学的写作，一直都有相对固定的「范式」。彭玉生在《“洋八股”与社会科学规范》中将其划分为：问题、文献、假设、测量、数据、方法、分析、结论。 对于社会科学类专业的学生来说，这些内容应该再熟悉不过了。面对这样泾渭分明的文章结构，需要从何处着手呢？ 打表格是多数老师会建议你去做的方式。打表其实是在让你去筛选阅读中的关键信息。这些信息对于某一类文章都是普遍适用的，而如何选择需要的关键信息的类别，师门不同，就会有不同的方式。 《会读才会写》中提供了一个非常有意思的思路——利用「阅读密码」来做文献阅读的技巧，并且基于这些「密码」，来整理你的文献。作为读书笔记，本文会先介绍这本书的关键内容，再结合自身的使用，谈谈适用于日常阅读如何结合书中的方法。 介绍 本书中的介绍的核心方法，就是添加「阅读密码」的方式，来标记文献的内容。将书中的「阅读密码」，所谓的阅读密码，其实就是将一些常用的标注简化为缩写的字母。将密码理解为「标签」更符合少数派读者的习惯，也更利于将这种方法扩展，所以下文我用标签来代指书中的阅读密码。 关于文献阅读，书中其实总结了两大类标签，首先是基于文献内容的标签，包括了，前言出现的：WTD（ 他们要做什么 ：What They Do ） ；文献综述中出现的：SPL（ 现有文献综述：Summary of Previous Literature ）、CPL（ 现有文献批评 ： Critique of Previous Literature ）、GAP（ 空白：Gap ）、RAT（ 理论依据：Rationale）；研究结果（ 也可能出现在讨论中 ）出现的：ROF（ 研究结果 ：Results of Findings ）；讨论中出现的：RCL（ 与现有文献观点一致的研究发现：Results Consistent with Literature ）、RTC（ 与现有文献观点相反的研究发现 ：Results to The Contrary ）；以及结论中出现的：WTDD（ 他们做了什么：What They Did ）、RFW（ 对未来研究的建议：Recommendations for Future Works ）。 其次是读者需要评注的部分的标签：POC （批评点 ：Point of Critique）、MOP（明显的遗漏点：Missed Obvious Point）、RPP（待探讨的相关问题 ：Relevant Point to Pursue） 、WIL （能否：Will）。书中将这些标签称为阅读策略。 每个标签（密码）对应的更具体含义在下表中给出[1]： 需要注意的是，所谓「洋八股」的社会科学范式，每个部分所侧重的内容其实各有不同，在实际标注中也没有必要每一句话都要套用一个密码。标注标签的目的对于社会科学的文献研究来说，主要还是为了厘清文章的脉络，理解作者的逻辑，并为后续处理做准备。所以如何打标签，应当着重以目的为导向。书中有表格给出，用以识别文本的功能，表格如下[2]： 现在，知道了这些密码就好像是知道了某张考卷的答案，只知道答案，却不解其缘由，显然是不行。 作者两个维度的分类，其实既满足了文献阅读中划出重点的需求也实现了简单的批注。并且，还一个极大的优势是后期的整理： 通过两个维度的整理，即对文章内容有了梳理，也为后续可能会用到的引用文献做了准备。 书中给出的标签，在我实际使用中的感受是十分适用的。可能是因为自己也是社科类的学生，所以基本上的标签在社科类的文献中都很适用。对于如何学习和习惯这种方法，结合我自己的实际使用，我给出一下几点建议： **按图索骥：**将「阅读密码」打印下来，阅读文献时放在边上做参考。（我是简单粗暴的将书中几页直接撕了下来🌚） 注意完成后的归档。 文献阅读，有时候是打印出来在纸上看，有时是导入到 Goodnotes 或者 PDF expert 上用 iPad 看。 对于不同的方式，我的做法是，阅读标注完后，都统一归档到印象笔记中，并且打上标签。 整理中找到问题并改进。 整理文献是每一个从事科研行业都需要做的工作，在前期阅读就已经打好标签的前提下，整理起来会更加方便。但是这其中你也会慢慢发现一些问题，记录这些问题及时修改十分重要。比如我，在一开始用的时候，大多数文章都会有比较多的标记，其实这样反而找不到重点。 针对一个问题，每一次密集阅读在整理文献时，反思一下此前的标签体系，做一些修改，这样在后续的使用中就能够更加习惯和自如了。 利用标签整理文章的想法 除了重点介绍的「阅读密码」，其实书中开始就提到另一套标签。以往每年整理学生的论文，为论文打分都是一件让作者感到头疼的事。因为经常会有人不满于自己的成绩，要与作者理论，这极大的消耗了作者的精力。于是，作者开始使用诸如 AWK（ 变扭：awkward ）、CITE（ 不注明引用：citing ） 、LMG（ 满篇胡言乱语东拉西扯企图蒙混过关：Largely Magnified Generalities ）、JOK（主张稀奇古怪像个笑话：Joke）、TLW（句子过于冗长：Too Long-winded ）等标签，标记学生的文章，指出学生的问题所在，并为每个错误设置扣分值，加之全文的总体感受打上分数。这样做免除了不必要的麻烦的同时节省了宝贵的时间，也帮助学生认识到了自己文章的问题。 作者文中提到的这件事，其实正是验证了通过为文章内容打标签的方式，能够在某些方面实现意想不到的便利。书中提及的上述两套标签，分别帮助作者优雅的解决了文献阅读与文献批改的种种问题。第一套标签，作者利用两个维度设计了用于整理文章内容和用于标记批注类型的两个类型的标签。第二套标签，作者为不同标签赋予权重，为文章打分提供了依据。 对于有相同或者相近需求的学者们来说，上述内容是可以直接参考的。作者在书中通过大段的文本验证了即便是对于哲学研究，本书所设置的标签也是适用的。所以如果从事科学研究，是可以好好看看这本书的。书中其实有较多内容像是作者的碎碎念，如果身在学术共同体，一定会有更深的感受，对于作者的吐槽也会会心一笑。 其实这种方法也能很便捷的融入到自己的阅读体系中。为文章做标记或者高亮（highlight）某一段文字，其实也可以看作是一个标签。这个标签的作用是，提醒自己关注这段文字。这就好像任务管理中的优先级一般，是否高亮其实就是「优先」与「一般」的区别。构建自己的标签（密码）体系，利用诸如 Instapaper、bear、Kindle 等软硬件的标注功能，来为自己阅读流打上标签（密码），实现自己对于阅读摄入的某种需求。 我为自己的日常阅读设计了以下的一些标签，希望能够提供各位参考： eg： 案例。这个标签用来标注一些可能会用到的案例、比喻、观点等等。为自己以后撰文提供参考。简单的说，这是在为自己以后「掉书袋」作准备。 ctu：can’t understand ，不能理解。用来标注一些可能需要去查资料的情况。 ski &amp; tips ：skill、tips 标记一些技巧性的东西，两个标签我都用做一个功能，一些更长的文本，可能标记成skill，一些简短的我就作为tips了。总体来说，自己并没有做特别明显的区分。 tl：即timeline，时间线。阅读一些人物传记、说史类的文章时经常用到。例如最近看的《现代艺术150年》，就频繁使用了「tl」标签。 👉 &amp; —&gt; : 按下不表。即这里提到了，但是先不解释。这个在我阅读张五常的《经济解释》时开始使用，非常有助于理解逻辑。文中经常是提了几个论据，其中一个会按下不表。所以用这个标签先标记，后续回过头来看，就会发现其中可能会存在的问题。 ！！！：表示强烈赞同某个观点。 ？？？：表示对某个观点强烈的不赞同。（和 「！！！」组成的标签，时常被我回顾🌚，很有意思。） 在手机、pad 上的阅读，我一般分两种情况处理。首先是利用 Instapaper 中直接标注法。之后再利用 Workflow 发送到印象笔记，进行归档。[3] 出现的 Instapaper 中的文章都是经过筛选的，都会有一定的标注的必要。其次是第二种情况，来自诸如 微信公众号、知乎、微博等等地方的文章，我一般的做法是通过发送到 Drafts 标注，再定期处理 Drafts 的 inbox ，发送到印象笔记归档。 Drafts 可以通过 Workflow 、Pin 等等工具实现快速、统一的抓取文字片段，并且添加标注。而在 Kindle 上看时，使用简短的标记，能够实现更为便利的标注体验。标注后再利用 Klib 导出到印象笔记归档即可。 最后，愿本文能够为大家提供有益的参考。 见原书前言，表1 。 ↩︎ 见原书第85页，表 7.3 。原表还有一列是用来统计页数的，这里将其略去了。 ↩︎ workflow 使用的是power+ 中的方法。 ↩︎ ","link":"https://hwang.top/post/lesslesshui-du-cai-hui-xie-greatergreater-de-du-shu-bi-ji-li-yong-biao-qian-lai-zheng-li-yue-du-nei-rong/"},{"title":"ML - Python LASSO 算法实现","content":"import itertools from math import exp import numpy as np import matplotlib.pyplot as plt from numpy import * &lt;!-- more --&gt; ## 库导入 def load_data(filename): ## 加载数据的函数 X, Y = [], [] ##列表存储 with open(filename, 'r') as f: #读取文件 for line in f: splited_line = [float(i) for i in line.split()] #分割行储存到 splited_line 中 x, y = splited_line[: -1], splited_line[-1] #读取第一列和第一行数据，储存为x，y X.append(x) Y.append(y) X, Y = np.matrix(X), np.matrix(Y).T return X, Y #################################### def standarize(X): # 中心化 &amp; 标准化数据 (零均值, 单位标准差) std_deviation = np.std(X, 0) # 利用numpy，计算X的标准差。 # std（a, axis = None） ：同理，计算标准差。 依给定轴axis计算数组a相关元素标准差，其中axis为整数或者元组。 mean = np.mean(X, 0)# 对数组a的第1维度的数据进行求平均 return (X - mean)/std_deviation ####################################### # 一般线性回归函数 OLS； def std_linreg(X, Y): xTx = X.T*X # 利用numpy 做矩阵的装置。 if np.linalg.det(xTx) == 0: print('xTx is a singular matrix') return return xTx.I*X.T*Y ####################################### def get_corrcoef(X, Y): # X Y 的协方差 cov = np.mean(X*Y) - np.mean(X)*np.mean(Y) return cov/(np.var(X)*np.var(Y))**0.5 ####################################### def lasso_regression(X, y, lambd=0.2, threshold=0.1): # 通过坐标下降(coordinate descent)法获取LASSO回归系数 # 计算残差平方和 rss = lambda X, y, w: (y - X*w).T*(y - X*w) # 初始化回归系数w. m, n = X.shape w = np.matrix(np.zeros((n, 1))) r = rss(X, y, w) # 使用坐标下降法优化回归系数w niter = itertools.count(1) for it in niter: for k in range(n): # 计算常量值z_k和p_k z_k = (X[:, k].T*X[:, k])[0, 0] p_k = 0 for i in range(m): p_k += X[i, k]*(y[i, 0] - sum([X[i, j]*w[j, 0] for j in range(n) if j != k])) if p_k &lt; -lambd/2: w_k = (p_k + lambd/2)/z_k elif p_k &gt; lambd/2: w_k = (p_k - lambd/2)/z_k else: w_k = 0 w[k, 0] = w_k r_prime = rss(X, y, w) delta = abs(r_prime - r)[0, 0] r = r_prime print('Iteration: {}, delta = {}'.format(it, delta)) if delta &lt; threshold: break return w ################################## # 定义lasso算法 def lasso_traj(X, y, ntest=30): # 获取回归系数轨迹矩阵 _, n = X.shape ws = np.zeros((ntest, n)) for i in range(ntest): w = lasso_regression(X, y, lambd=exp(i-10)) ws[i, :] = w.T print('lambda = e^({}), w = {}'.format(i-10, w.T[0, :])) return ws #################################### if '__main__' == __name__: #模块是对象，并且所有的模块都有一个内置属性 __name__。一个模块的 __name__ 的值取决于您如何应用模块。如果 import 一个模块，那么模块__name__ 的值通常为模块文件名，不带路径或者文件扩展名。但是您也可以像一个标准的程序样直接运行模块，在这种情况下, __name__ 的值将是一个特别缺省&quot;__main__&quot;。 ## https://www.zhihu.com/question/49136398 X, y = load_data('abalone.txt') X, y = standarize(X), standarize(y) w = lasso_regression(X, y, lambd=10) y_prime = X*w ## 计算相关系数 corrcoef = get_corrcoef(np.array(y.reshape(1, -1)), np.array(y_prime.reshape(1, -1))) ## 计算协方差 print('Correlation coefficient: {}'.format(corrcoef)) ntest = 30 ## 绘制轨迹 ws = lasso_traj(X, y, ntest) fig = plt.figure() ax = fig.add_subplot(111) lambdas = [i - 10 for i in range(ntest)] ax.plot(lambdas, ws) plt.show() ","link":"https://hwang.top/post/ml-python-lasso-suan-fa-shi-xian/"},{"title":" 2017 开始的「数字生活」","content":"我还记得，2016 年的年终、2017 年的年初，在少数派上，关于数字生活的讨论，让我真正开始对于「数字生活」的思考。软件的组合如何实现每一个人的工作流让我着迷。「数字生活」不应只是概念，如何进行实践这个理念，参照少数派教我的，以及我实际需求的，我做了一些尝试，希望能够分享给大家。 我用思维导图整理逻辑 李如一在某一期的「一天世界」的里，提到了「信息游击队」这个词。这是一个很有意思的词语，大家可以自行思考一下。信息时代，让人变得十分碎片。这种碎片化让人变得非常奇怪，人们发表碎片化的观点，也接受碎片化的观点。人总是会做一些逻辑不「自洽」的事情，社交网络上，「打脸」的现象屡见不鲜。 掌握逻辑并不是一件简单的事情。具有「科学性」的逻辑验证是一件十分困难的事情，在对经济学的学习中，我越发体会到「逻辑」之重。许多文章中，段落与段落之间常会有逻辑不自洽。张五常说，大多数人的观点要么无关科学，要么是套套逻辑。「套套逻辑」往往是更加高质量的文章才会有的问题。因为他们往往构建了一个看似严密的体系，实际上一步一步的逻辑其实只是迂回的、简单的「套套」。这样的问题，其实很难被发现，张五常说，能否发现这其中的逻辑问题，这就是「高手」和「低手」的差别之一。 文章的逻辑，主要体现在两个方面，首先是整篇文章的逻辑，段落的逻辑构成一个部分的观点，多个观点构成了一篇文章；其次是段落之中的逻辑，就是每一个段落，都有作者想要表达的部分。例如，我这一段其实是想说，文章的逻辑是一个抽象的概念，并不那么容易掌握，整篇文章的逻辑更加容易理解一些，但是第二部分，段落的逻辑是特别困难的。大多数时候，考察大多数人的观点，在那些需要预备的知识不计的情况下，考察到「段」的逻辑就足够了，已经足够通过他的「论据」判断「观点」是否可靠了。小部分时候，考察一个「论据」是否可靠，也会变得十分重要。但是这样的考察又十分困难。 思维导图，在这一年，成为我考察段落逻辑的主要工具。他可以很清晰的将同级的「观点」展现出来，并且清晰的显示后面论证的逻辑，同时思维导图的样式，其实也是在告诉你去注意这些不同的论点之间的关系。 下面我以之前看的文献：《Does Daughter Deficit Promote Parental Substance Use? Longitudinal Evidence on Smoking from Rural China》 为例。正是在阅读这篇文章的时候，我才真正意识到了思维导图其实非常适合这样用（因为看英文水平并不好，所以为了理清文章，做了一些微小的尝试。在以往阅读中文文献时，并没有意识到这些问题，大概是自以为水平很高了)。简单提一下这篇文章的观点，文章认为，性别比失衡会导致更多的吸烟行为，更加具体的表述是：在性别比失衡严重的地区（男性多于女性），有儿子的家庭中，父亲会有更高的概率吸烟。这个结论看起来是意料之外，但是仔细一想似乎又是情理之中。 首先，文章描述了两个事实：中国的性别比失衡现象和中国吸烟的现象。显然，描述现象要用事实说话，所以作者用描述性统计做为论据： 配图 然后这两个现象，在现实中如何关联上？本文描述在中国，家庭需要为子女婚姻付出，并且这个压力主要由家庭中男性承担。具体如下： 配图 这样，对于现状的描述就十分清晰了。然后后续会有更加紧凑的「逻辑」： 配图 至于后续实证部分，由于非科班出生阅读比较无趣，也就不再举例了（但其实经济学的论证，后续的才是精华，前面只能证明你研究的问题是「事实」）。上面是一个正面的例子，其实，我们也能通过思维导图，发现逻辑上的漏洞，例如下面这段话： 这段话的问题是，A定义了B（个人消费物品）是什么，所以我们找不到C（公共物品）的案例。所以这里明显是有逻辑上的跳跃的（后来询问了作者，他说当时文章比较长，被编辑删除了一些语句，这里大概是后续修改中没有注意到的），论证是有跳跃的。 在实际使用中，我是这么做的： 第一次阅读时，简单标注，看是否是重要的文献。这是只是标注标黄观点，横线划出论据，大致过一遍。如果需要琢磨透彻，会直接做出思维导图。不得不说，工具选择上，我是十分随意。有时用幕布，有时用 Lighten ，有时是 Xmind。软件各有特色，但是对我来说，其实作用都一样。有时，我会边看边做思维导图，这是我会直接用幕布，但是幕布做好后，往往会需要各种调整。因为边看文献，边用幕布，其本质是做文章摘录，所以在一些复杂的情况下，逻辑上时常排错位置。 所以，我更多的是边看边用 Markdown 做笔记。然后，再通过 Popclip 的一个插件（需要标准的 Markdown 语法才行，简单的讲，就是不能少了空格）实现 Markdown 转化为带缩进的富文本，粘贴到思维导图工具中的。文章的导图做好后，我就会直接归档到 Evernote 中。 配动图 我用 Evernote 归档我的信息流 终于想到了应该如何形容 Evernote 了， Evernote 是我整个「数字生活」的归档箱。对的，是我整个「数字生活」的归档箱。 为什么是 Evernote ？ 简单的说就是1. 全平台 + 2. 强大的检索 + 3. 足够用的存储与分类。 Evernote 支持几乎所有的平台。即便是最极端的数字游民，也能很便捷的访问自己的归档箱——这是其他服务所无法提供的。 Evernote 便捷的搜索功能，是其足以胜任归档箱的第二个理由。 Evernote 支持笔记内容搜索；支持部分附件格式内容的搜索，例如PDF、Docx等常见文件格式；还支持图片中文字的搜索，甚至是手写笔记内容的搜索。再加上一些简单的搜索语法， 对我来说，能够足够便捷的找到我需要翻阅的存档。第三个理由，存储上，Evernote 虽然主要储存富文本格式的内容，但是其能够支持诸如 PDF、Docx 等格式内容的预览显示，以及支持其他各种文件格式的附件形式存储。分类上，标签和笔记本两个方向的维度，也足够使用了。 我是这样使用 Evernote 的 Evernote 在生活中存储了我所接触的来自各处的信息。首先就是来自网络的内容，诸如 RSS 里的文章、微信公众号的文章、微博的文章、Medium 的文章等等。其次是作为学生必然接触到的各种PDF文献。最后，是书籍这种系统的信息，这里也有分类，就是 1.kindle 为代表的电子书的内容；2. 纯正的纸本图书。 RSS的流程其实就是参考了此前子不语的Live。简单的说就是，RSS源—过滤到稍后读软件—处理后归档。 使用工具上会有不同，首先就是RSS的使用上，我还是更习惯直接看一些较浅的内容，而非直接「刷」标题筛选。阅读对我来说，本身就是一种精彩进行也乐于进行的娱乐活动。（我相信有很多人都有强烈的「信息摄取癖」）当然，对于需要仔细看的、学习的内容，我会先存档到 Instapaper ，利用 Instapaper 的标记功能进行标记。标记后的内容，通过 Workflow 存储到 Evernote （动作来自 Power+ ）。如果简单的标记不能满足需求，我会用 Workflow 转成 PDF 再导入到 Goodnotes ，再在 iPad 边看边标记。处理完同样发到印象笔记。一般这样的内容，我还会顺带做一张简单的思维导图，便于我回忆本文的内容。同样会附在 Evernote。 PDF内容，在实际使用上，我也有多种处理方式。但最终的路径都归于存档到Evernote 。最为直接的就是在 Goodnotes 上标记后归档。还有一种情况，是为了看得更仔细，我会边看边做笔记。做笔记同样有几种方式，例如用 Goodnotes 记笔记，然后导出成PDF到 Evernote ；用 Markdown 记录，并且导出为 PDF 到Evernote （顺带导出思维导图，方法同上）；用纸笔记录，再用印象笔记的扫描宝，扫描后，存储到 Evernote 等。大多数情况选择用 PDF 格式保存，因为搜索足够便捷。 电子书，我用 Klib 整理到 Evernote 。Klib 足够好用，也足够便捷。支持 Kindle、多看、iBooks 等地方笔记摘录的导入。并且，能够很便捷的导出到 Evernote 。Kilb 直接解决了对于看故事为主的电子阅读的大多数情况。对于纸书，同样用扫描宝扫入 Evernote。 通过这些方式，Evernote 归档了我「看」的大多数内容。 除此之外，我还用 IFTTT 和 Workflow 实现了 Evernote 的自动化： 存储我的微博、Twitter、Instagram 存储我的日记 自动储存一些邮件 本文就这样了 😉 ","link":"https://hwang.top/post/2017-kai-shi-de-shu-zi-sheng-huo/"}]}