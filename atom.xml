<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hwang.top</id>
    <title>Hwang&apos;s Blog</title>
    <updated>2019-09-29T02:16:36.569Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hwang.top"/>
    <link rel="self" href="https://hwang.top/atom.xml"/>
    <subtitle>欢迎来到 Hwang 的小博客</subtitle>
    <logo>https://hwang.top/images/avatar.png</logo>
    <icon>https://hwang.top/favicon.ico</icon>
    <rights>All rights reserved 2019, Hwang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[ML- Python 岭回归]]></title>
        <id>https://hwang.top/post/ml-python-ling-hui-gui</id>
        <link href="https://hwang.top/post/ml-python-ling-hui-gui">
        </link>
        <updated>2019-09-29T02:12:51.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-python">def ridgeRegres(xMat,yMat,lam=0.2):
	xTx = xMat.T*xMat
	denom = xTx + eye(shape(xMat)[1])*lam
	if linalg.det(denom) == 0.0:
		print &quot;This matrix is singular, cannot do inverse&quot;
		return
	ws = denom.I * (xMat.T*yMat)
	return ws
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-python">def ridgeRegres(xMat,yMat,lam=0.2):
	xTx = xMat.T*xMat
	denom = xTx + eye(shape(xMat)[1])*lam
	if linalg.det(denom) == 0.0:
		print &quot;This matrix is singular, cannot do inverse&quot;
		return
	ws = denom.I * (xMat.T*yMat)
	return ws
</code></pre>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="Image%202018-7-11%20%E4%B8%8B%E5%8D%886-36.jpeg" alt=""></figure>
<pre><code class="language-python">def ridgeTest(xArr,yArr):
	xMat = mat(xArr); yMat=mat(yArr).T
	yMean = mean(yMat,0)
	yMat = yMat - yMean     #to eliminate X0 take mean off of Y
	#regularize X's
	xMeans = mean(xMat,0)   #calc mean then subtract it off
	xVar = var(xMat,0)      #calc variance of Xi then divide by it
	xMat = (xMat - xMeans)/xVar
	numTestPts = 30
	wMat = zeros((numTestPts,shape(xMat)[1]))
	for i in range(numTestPts):
		ws = ridgeRegres(xMat,yMat,exp(i-10))
		wMat[i,:]=ws.T
	return wMat
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 的虚拟环境管理  virtualenv & pyenv]]></title>
        <id>https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv</id>
        <link href="https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv">
        </link>
        <updated>2019-09-29T02:11:01.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
<!-- more -->
<p>由于生产需要，用 PyQt5 写了小程序，打包成 <code>.app</code> 过程中发现，打包后竟然有200多M，应该是因为之前使用的python环境中其他包比较多的关系。所以就想到建虚拟环境，来打包。</p>
<p>首先想到的是按项目建虚拟环境，那就用virtualenv 。简单看了一下，实践如下：</p>
<h2 id="virtualenv">virtualenv</h2>
<h3 id="1-安装virtualenv">1. 安装virtualenv</h3>
<p>用pip进行安装。</p>
<pre><code class="language-bash">$ pip install virtualenv 
</code></pre>
<p>先建文件夹，再<code>cd</code>到需要的文件夹中，运行下面的命令：</p>
<pre><code class="language-bash">$ virtualenv --python=&quot;/usr/local/bin/python3.7&quot; --no-site-packages venv
</code></pre>
<p>其中：</p>
<pre><code class="language-bash">--python （-p） # 用于指定版本
--no-site-packges # 表示不需要包
venv # 虚拟环境的名称
</code></pre>
<p>其它选项：</p>
<pre><code class="language-bash">--version
#显示当前版本号。
-h, --help
#显示帮助信息。
-v, --verbose
#显示详细信息。
-q, --quiet
#不显示详细信息。
-p PYTHON_EXE, --python=PYTHON_EXE
#指定所用的python解析器的版本，比如 --python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前系统安装(/usr/bin/python)的python解析器
--clear
#清空非root用户的安装，并重头开始创建隔离环境。
--no-site-packages
#令隔离环境不能访问系统全局的site-packages目录。
--system-site-packages
#令隔离环境可以访问系统全局的site-packages目录。
--unzip-setuptools
#安装时解压Setuptools或Distribute
--relocatable
#重定位某个已存在的隔离环境。使用该选项将修正脚本并令所有.pth文件使用相当路径。
--distribute
#使用Distribute代替Setuptools，也可设置环境变量VIRTUALENV_DISTRIBUTE达到同样效要。
--extra-search-dir=SEARCH_DIRS
#用于查找setuptools/distribute/pip发布包的目录。可以添加任意数量的–extra-search-dir路径。
--never-download
#禁止从网上下载任何数据。此时，如果在本地搜索发布包失败，virtualenv就会报错。
--prompt==PROMPT
#定义隔离环境的命令行前缀。
#环境变量和配置文件
</code></pre>
<h3 id="2-激活虚拟环境">2. 激活虚拟环境</h3>
<pre><code class="language-bash">$ . venv/bin/activate
</code></pre>
<figure data-type="image" tabindex="1"><img src="DraggedImage.png" alt=""></figure>
<p>前面出现<code>(venv)</code> 即可。</p>
<h3 id="一些发现">一些发现</h3>
<ul>
<li>virtualenv 默认似乎是从原环境中下载包的。就是优先直接从原有库中拷贝，不通过下载。这样速度会比较快。</li>
</ul>
<blockquote>
<p>由于本地环境除了 anaconda 的以为， Python 3.7。在打包中出现了一些兼容性问题，具体可见：<br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/1957">https://github.com/pyinstaller/pyinstaller/issues/1957</a><br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/3753">https://github.com/pyinstaller/pyinstaller/issues/3753</a><br>
即便按照issues里说的做了，我也没能解决问题。所以想到下载 3.6版本的 Python 来使用。所以就想到了用 pyenv</p>
</blockquote>
<h2 id="pyenv">pyenv</h2>
<p>基本过程可参考：<a href="https://www.jianshu.com/p/4646dedaaff5">https://www.jianshu.com/p/4646dedaaff5</a></p>
<h3 id="1-安装">1. 安装</h3>
<p>我是通过 Homebrew 下载的（可参考：<a href="https://zhuanlan.zhihu.com/p/27294128">https://zhuanlan.zhihu.com/p/27294128</a>）。</p>
<blockquote>
<p>备份一下 <code>.bash_profile</code></p>
</blockquote>
<pre><code class="language-bash"># Setting PATH for Python 3.7
# The original version is saved in .bash_profile.pysave
PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}&quot;
export PATH

# added by Anaconda3 5.2.0 installer
export PATH=&quot;/Users/wangxuexi/anaconda3/bin:$PATH&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
</code></pre>
<pre><code class="language-bash">$ brew install pyenv
</code></pre>
<p>有可能需要：</p>
<pre><code class="language-bash">$ echo 'export PYENV_ROOT=&quot;$HOME/.pyenv&quot;' &gt;&gt; ~/.bash_profile
$ echo 'export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile
$ echo 'eval &quot;$(pyenv init -)&quot;' &gt;&gt; ~/.bash_profile
</code></pre>
<p>写完后，用以下命令重新登录一下：</p>
<pre><code class="language-bash">$ source ~/.bash_profile
</code></pre>
<p>如果有需要可以安装 pyenv-virtualenv:</p>
<pre><code class="language-bash">$ brew install pyenv-virtualenv
</code></pre>
<p>同样的：</p>
<pre><code class="language-bash">$ echo 'eval &quot;$(pyenv virtualenv-init -)&quot;' &gt;&gt; ~/.bash_profile
# 写入 profile
$ source  ~/.bash_profile
# 重新进登录一遍
</code></pre>
<p>命令参数如下</p>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt; # 建虚拟环境
pyenv virtualenv activate &lt;virtualenv-name&gt; # 激活虚拟环境
pyenv virtualenv-delete &lt;virtualenv-name&gt; # 删除虚拟环境
</code></pre>
<h3 id="2-pyenv-的使用">2. pyenv 的使用</h3>
<p>基本的下载、删除 命令：</p>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v # 用国内源安装很快
</code></pre>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install
</code></pre>
<hr>
<pre><code class="language-bash">$ pyenv install -v 3.6.0  # 安装

$ pyenv uninstall 2.7.10 # 删除
</code></pre>
<p>激活，pyenv 有几种激活方式：</p>
<pre><code class="language-bash">local       Set or show the local application-specific Python version
global      Set or show the global Python version
shell       Set or show the shell-specific Python version
</code></pre>
<p>通过<code>version</code> 、  <code>versions</code>  查看版本。</p>
<p>其他：</p>
<pre><code class="language-bash">Usage: pyenv &lt;command&gt; [&lt;args&gt;]

Some useful pyenv commands are:
   commands    List all available pyenv commands
   local       Set or show the local application-specific Python version
   global      Set or show the global Python version
   shell       Set or show the shell-specific Python version
   install     Install a Python version using python-build
   uninstall   Uninstall a specific Python version
   rehash      Rehash pyenv shims (run this after installing executables)
   version     Show the current Python version and its origin
   versions    List all Python versions available to pyenv
   which       Display the full path to an executable
   whence      List all Python versions that contain the given executable

See `pyenv help &lt;command&gt;' for information on a specific command.
For full documentation, see: https://github.com/yyuu/pyenv#readme
</code></pre>
<h3 id="3-pyenv-virtualenv-的使用">3. Pyenv virtualenv 的使用</h3>
<h4 id="31-创建">3.1 创建：</h4>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [-u|--upgrade] [VIRTUALENV_OPTIONS] &lt;version&gt; &lt;virtualenv-name&gt;
</code></pre>
<ul>
<li><code>-f</code> 表示强制的（假如虚拟环境已存在，将会覆盖这个虚拟环境）</li>
<li><code>-u</code> 表示upgrade，用于修改已经存在的虚拟环境的Python版本</li>
<li><code>VIRTUALENV_OPTIONS</code> 是传递给virtualenv的选项，可以通过virtualenv的帮助获取选项的含义</li>
<li><code>version</code> 表示Python版本</li>
<li><code>virtualenv-name</code> 指定虚拟环境名</li>
</ul>
<h4 id="32-使用">3.2 使用</h4>
<p>pyenv的virtual不用手动去激活环境；当把本地目录与环境相关联起来后，将自动激活虚拟环境，离开目录时自动退出虚拟环境</p>
<h3 id="注意事项">注意事项：</h3>
<ol>
<li>pyenv 下载慢：<a href="http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/">http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/</a></li>
</ol>
<blockquote>
<p>先去官网下载对应版本的源码：https://www.python.org/downloads/source/<br>
然后创建/.pyenv/cache目录： mkdir /.pyenv/cache (如果已经有该目录直接进入: cd /.pyenv/cache) 然后 <code>pyenv install 3.6.0</code></p>
</blockquote>
<ol start="2">
<li>打包出错，提示需要 python-dev：<a href="https://github.com/pyenv/pyenv/issues/1095">https://github.com/pyenv/pyenv/issues/1095</a></li>
</ol>
<blockquote>
<p>使用以下命令进行安装：</p>
<pre><code class="language-bash">PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install 3.6.0
</code></pre>
</blockquote>
<h3 id="删除虚拟环境">删除虚拟环境</h3>
<pre><code class="language-bash">$ pyenv local system
$ pyenv virtualenv-delete venv
pyenv-virtualenv: remove /home/will/.pyenv/versions/3.4.1/envs/venv? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.1
  3.4.2

$ pyenv uninstall 3.4.1
pyenv: remove /home/will/.pyenv/versions/3.4.1? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.2
</code></pre>
<h2 id="windows-上的虚拟环境管理">Windows 上的虚拟环境管理</h2>
<p>Windows 上同样支持 Virtualenv 进行虚拟环境的管理的。步骤与上述差不多。</p>
<p>Windows 不支持 Pyenv 。</p>
<h3 id="安装-virtualenvwrapper">安装  virtualenvwrapper</h3>
<p>使用 virtualenvwrapper 能够比较容易的使用虚拟环境。</p>
<pre><code class="language-bash">$ pip install virtualenvwrapper-win
</code></pre>
<h3 id="创建-虚拟环境">创建 虚拟环境</h3>
<p>使用 <code>mkvirtualenv</code> 创建虚拟环境。</p>
<pre><code class="language-bash">$ mkvirtualenv -p [python路径] [虚拟环境名称]
</code></pre>
<p>环境默认创建地址为：<code>C:\Users\[username]\envs</code></p>
<h3 id="激活-虚拟环境">激活 虚拟环境</h3>
<p>使用 <code>workon + [虚拟环境名称]</code> 命令进行激活。</p>
<pre><code class="language-bash">$ workon env1
</code></pre>
<p>使用 <code>workon</code> 列出当前的虚拟环境：</p>
<pre><code class="language-bash">$ workon
</code></pre>
<p>退出虚拟环境：</p>
<pre><code class="language-bash">$ deactivate
</code></pre>
<p>删除环境：</p>
<pre><code class="language-bash">$ rmvirtualenv
</code></pre>
<p>复制虚拟环境：</p>
<pre><code class="language-bash">$ cpvirtualenv env1 env3
</code></pre>
<ul>
<li>参考：<a href="https://www.jianshu.com/p/60f361822a7e">https://www.jianshu.com/p/60f361822a7e</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hwang 的低质阅读单 New 1]]></title>
        <id>https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1</id>
        <link href="https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1">
        </link>
        <updated>2019-09-27T01:37:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="hwang-的低质阅读单-new">Hwang 的低质阅读单 New</h1>
<h6 id="这些文章来自-hwang-的-instapaper-从-rss-微博-微信等地方看到觉得自己应该仔细看看的文章收集进-instapaper-归档这些文章后才会出现这里-故而主观又缺乏时效性-很遗憾没有帮到你们">这些文章来自 Hwang 的 Instapaper 。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper ，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。</h6>
<ul>
<li><a href="https://ift.tt/2KP9jma"> 来自 Petra Collins 的“驱魔仪式” | 异视异色｜i-D 中国｜来自VICE的时尚频道</a></li>
<li><a href="https://ift.tt/2Jk8uyy"> 公众号「信息流」改版一周年，有人说没有想的那么糟糕 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2XAAcAp"> 复盘 Evernote：笔记 App 的开山鼻祖，为什么没落了？</a></li>
<li><a href="https://ift.tt/2Xb7HoL"> 苹果的后 iPhone 时代</a></li>
<li><a href="https://ift.tt/2YlJ2PI"> 无大台的时代</a></li>
<li><a href="https://ift.tt/2NxjMVH"> 苹果的跨平台计划：如何用 App 打通 iPad 和 Mac</a></li>
<li><a href="https://ift.tt/30hEzOj"> PyQt + QML 快速开发GUI总结</a></li>
<li><a href="https://ift.tt/2XvPdnd"> 2019中国α世代线上娱乐价值观念洞察 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2YyeXMJ"> 机器学习能成为因果推断的“圣杯”吗？</a></li>
<li><a href="https://ift.tt/2JnoboO"> 如何用 Python 和 BERT 做多标签（multi-label）文本分类？</a></li>
<li><a href="https://ift.tt/30kBQnD"> 怎么选择数据服务器？请记住这五条</a></li>
<li><a href="https://ift.tt/2Sz79YR"> 如何用约会软件进行艺术创作？</a></li>
<li><a href="https://ift.tt/2Y1EuwI"> 亚马逊中国停售纸质书／李楠宣布从魅族离职／京都动画大火已造成 33 人遇难</a></li>
<li><a href="https://ift.tt/2YIO4FW"> 社交围城里的刷新机器</a></li>
<li><a href="https://ift.tt/31I1TWt"> 马斯克的脑机接口来了，USB 连大脑，用 iPhone 操控 | 近未来 ⑫</a></li>
<li><a href="https://ift.tt/2YqQImZ"> 早报 | 明年 iPhone 或全线支持 5G vivo 首款 5G 手机或将亏本卖 《哪吒》破动画票房纪录</a></li>
<li><a href="https://ift.tt/2KIHh9H"> 港真，乱么？ | 可能吧</a></li>
<li><a href="https://ift.tt/301BHsJ"> win10引导错误的修复（内容系转载） - 技术经验 - W3xue</a></li>
<li><a href="https://ift.tt/2HJC7JV"> AI 语音模仿老板声音要求转账，成功骗走了 173 万</a></li>
<li><a href="https://ift.tt/2LcUqIn"> Designing Dark Mode</a></li>
<li><a href="https://ift.tt/2M7vv9w"> 一篇文章让你彻底搞清楚Python中self的含义 - jessonsh - 博客园</a></li>
<li><a href="https://ift.tt/332qNAv"> 出身清华姚班，斯坦福博士毕业，她的毕业论文成了「爆款」</a></li>
<li><a href="https://ift.tt/1PzbZyK"> 高清图标SVG解决方案全总结（上） - 文章 - 伯乐在线</a></li>
<li><a href="https://ift.tt/1PzL3P8"> 高清图标SVG解决方案全总结（下） - 文章 - 伯乐在线</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 在 Windows 的共享文件夹中创建文件图标]]></title>
        <id>https://hwang.top/post/ru-he-zai-windows-de-gong-xiang-wen-jian-jia-zhong-chuang-jian-wen-jian-tu-biao</id>
        <link href="https://hwang.top/post/ru-he-zai-windows-de-gong-xiang-wen-jian-jia-zhong-chuang-jian-wen-jian-tu-biao">
        </link>
        <updated>2019-07-11T02:06:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Windows 系统中可以通过右键文件夹属性的方式创建文件夹图标。然而，在共享文件夹中并不能直接创建。</p>
<p>🎬 <a href="https://www.youtube.com/watch?v=oFHkWfXbxYo">Apply an Icon to a Folder on a NetWork Drive </a><br>
视频中演示了一种相对曲折的方法在共享文件夹中，创建带有图标的文件夹。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Windows 系统中可以通过右键文件夹属性的方式创建文件夹图标。然而，在共享文件夹中并不能直接创建。</p>
<p>🎬 <a href="https://www.youtube.com/watch?v=oFHkWfXbxYo">Apply an Icon to a Folder on a NetWork Drive </a><br>
视频中演示了一种相对曲折的方法在共享文件夹中，创建带有图标的文件夹。</p>
<!-- more -->
<p>究其原理，其实就是共享文件夹中系统没有创建 <code>desktop.ini</code> 文件的设置（可能是安全原因的考虑？）。</p>
<p>参考：<a href="https://superuser.com/questions/685732/set-custom-folder-icon-for-a-network-folder-in-windows-file-explorer">Set custom folder icon for a network folder in Windows file explorer</a></p>
<h2 id="做法">做法：</h2>
<p>这种方法的前提就是你有共享文件夹的写入权限，在windows 10 上已经不能正常使用了</p>
<ol>
<li>在本地创建一个有 icon 的文件夹；</li>
<li>移动该文件夹到 共享文件夹中；</li>
<li>在弹出窗口中 允许 <code>desktop.ini</code> 的相关选项；</li>
<li>刷新一下共享文件夹</li>
<li>OK</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL 的一些内容]]></title>
        <id>https://hwang.top/post/sql-de-yi-xie-nei-rong</id>
        <link href="https://hwang.top/post/sql-de-yi-xie-nei-rong">
        </link>
        <updated>2019-05-07T02:11:54.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mysql-累计求和">MySQL 累计求和</h2>
<pre><code class="language-sql">SET @csum := 0;
SELECT ADCODE, NAME, (@csum := @csum + ADCODE) AS CUMSUM
FROM all_location_data LIMIT 20;
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mysql-累计求和">MySQL 累计求和</h2>
<pre><code class="language-sql">SET @csum := 0;
SELECT ADCODE, NAME, (@csum := @csum + ADCODE) AS CUMSUM
FROM all_location_data LIMIT 20;
</code></pre>
<!-- more -->
<p>首先 是设置一个变量 @csum 为0<br>
接着 选择要显示的字段，设置一个公式<code>(@csum := @csum + ADCODE)</code> 这里 ADCODE 就是想要 累积加总的变量，将其记为 CUMSUM。<br>
最后加上 <code>FROM all_location_data LIMIT 20;</code> 限制了现实20条。</p>
<hr>
<h2 id="mysql-统计某个-字段-不重复的行数">MySQL 统计某个 字段 不重复的行数</h2>
<pre><code class="language-sql">SELECT count(DISTINCT name) AS nu FROM company;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python Pexpect 库的简单入门]]></title>
        <id>https://hwang.top/post/python-pexpect-ku-de-jian-dan-ru-men</id>
        <link href="https://hwang.top/post/python-pexpect-ku-de-jian-dan-ru-men">
        </link>
        <updated>2019-03-26T02:04:35.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>2019.03.26<br>
Hwang<br>
参考：<br>
1.<a href="https://www.jianshu.com/p/cfd163200d12">https://www.jianshu.com/p/cfd163200d12</a><br>
2.<a href="https://blog.csdn.net/Cloud_Strife0/article/details/82217494">https://blog.csdn.net/Cloud_Strife0/article/details/82217494</a></p>
</blockquote>
<h2 id="1-pexpect-是什么">1. Pexpect  是什么</h2>
<blockquote>
<p>pexpect 是 Python 语言的类 Expect 实现。<br>
而 expect 主要用于模拟人机对话，简单地说就是可以使用正则匹配捕捉系统的提问（ssh登录需要输入密码等），并且根据捕捉到的提问进行不同的操作。<br>
例子：</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>2019.03.26<br>
Hwang<br>
参考：<br>
1.<a href="https://www.jianshu.com/p/cfd163200d12">https://www.jianshu.com/p/cfd163200d12</a><br>
2.<a href="https://blog.csdn.net/Cloud_Strife0/article/details/82217494">https://blog.csdn.net/Cloud_Strife0/article/details/82217494</a></p>
</blockquote>
<h2 id="1-pexpect-是什么">1. Pexpect  是什么</h2>
<blockquote>
<p>pexpect 是 Python 语言的类 Expect 实现。<br>
而 expect 主要用于模拟人机对话，简单地说就是可以使用正则匹配捕捉系统的提问（ssh登录需要输入密码等），并且根据捕捉到的提问进行不同的操作。<br>
例子：</p>
</blockquote>
<!-- more -->
<pre><code class="language-python">import pexpect
import sys

# 用spawn来执行一个指令
child = pexpect.spawn('ftp ftp.openbsd.org')
# 用expect等待指定的关键字’name‘
child.expect('(?i)name .*: ')
# 若上一步匹配到了，则向计算机输入name
child.sendline('anonymous')
# 用expect等待指定的关键字’password‘
child.expect('(?i)password')
# 若上一步匹配到了，则向计算机输入password
child.sendline('pexpect@sourceforge.net')
# 用expect等待指定的关键字’ftp&gt;‘
child.expect('ftp&gt; ')
# 若上一步成功匹配，则意味着进入了ftp连接，现在做一些操作
child.sendline('cd /pub/OpenBSD/3.7/packages/i386')
child.expect('ftp&gt; ')
child.sendline('bin')
child.expect('ftp&gt; ')
child.sendline('prompt')
child.expect('ftp&gt; ')
child.sendline('pwd')
child.expect('ftp&gt; ')
print(&quot;Escape character is '^]'.\n&quot;)
sys.stdout.write (child.after)
sys.stdout.flush()
child.interact() # Escape character defaults to ^]
# At this point this script blocks until the user presses the escape character
# or until the child exits. The human user and the child should be talking
# to each other now.

# At this point the script is running again.
print('Left interactve mode.')

# The rest is not strictly necessary. This just demonstrates a few functions.
# This makes sure the child is dead; although it would be killed when Python exits.
if child.isalive():
    child.sendline('bye') # Try to ask ftp child to exit.
    child.close()
# Print the final state of the child. Normally isalive() should be FALSE.
if child.isalive():
    print('Child did not exit gracefully.')
else:
    print('Child exited gracefully.')
</code></pre>
<h2 id="2-用法">2. 用法</h2>
<h3 id="21-spawn">2.1 spawn()</h3>
<pre><code class="language-python">demo_ssh = pexpect.spawn('ssh xxx@&lt;ip&gt;')
</code></pre>
<p>如上例中，spawn() 返还的是句柄（handle）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，一般用法：<code>spawn(&lt;cmd 命令&gt;)</code> ， 后续的操作都会基于这里定义的变量 <code>demo_ssh</code>	。</p>
<blockquote>
<p>注意: spawn() ，或者说 pexpect 并不会转译任何特殊字符 比如 <code>| *</code>字符在Linux的shell中有特殊含义，但是在 pexpect 中不会转译它们，如果在 linux 系统中想使用这些符号的正确含义就必须加上 shell 来运行，这是很容易犯的一个错误。<br>
正确的方式：</p>
<pre><code class="language-python">process = pexpect.spawn('/bin/bash -c &quot;ls -l | grep LOG &gt; log_list.txt&quot;')
process.expect(pexpect.EOF)
</code></pre>
</blockquote>
<h4 id="参数">参数</h4>
<ul>
<li>timeout</li>
</ul>
<p>设置超时时间（30默认）</p>
<ul>
<li>
<p>maxread 缓存设置<br>
默认 2000 字符</p>
</li>
<li>
<p>searchwindowsize - 模式匹配阀值</p>
</li>
<li>
<p>logfile - 运行输出控制</p>
</li>
<li>
<p>logfile_read - 获取标准输出的内容</p>
</li>
<li>
<p>logfile_send - 获取发送的内容</p>
</li>
<li>
<p>cwd - 指定命令执行的目录</p>
</li>
<li>
<p>env - 指定环境变量</p>
</li>
<li>
<p>ignore_sighup - 是否过滤 SIGHUP 信号</p>
</li>
<li>
<p>delaybeforesend - 字符发送延时</p>
</li>
</ul>
<h3 id="22-expect">2.2 expect()</h3>
<p>关键字匹配，当spawn 启动一个程序并且返回程序控制句柄后，可以用expect() 来指定匹配内容。 使用 expect() 使用正则表达式来匹配。</p>
<h3 id="221-expect_exact">2.2.1 expect_exact()</h3>
<p>精确匹配，它的使用和 expect() 是一样的，唯一不同的就是它的匹配列表中不再使用正则表达式。<br>
从性能上来说 expect_exact() 要更好一些，因为即使你没有使用正则表达式而只是简单的用了几个字符 expect() 也会先将它们转换成正则表达式模式然后再搜索，但 expect_exact() 不会，而且也不会把一些特殊符号转换掉。</p>
<h3 id="222expect_list">2.2.2expect_list()</h3>
<p>预转换匹配，使用方式和 expect() 一样，唯一不同的就是它里面接受的正则表达式列表只会转换一次。</p>
<h3 id="223-expect_loop">2.2.3 expect_loop()</h3>
<p>用于从标准输入中获取内容，loop这个词代表它会进入一个循环，必须要从标准输入中获取到关键字才会往下继续执行。</p>
<h3 id="23-send">2.3 send()</h3>
<p>发送关键字。用来向程序发送指定的字符串。</p>
<h3 id="231-sendline">2.3.1 sendline()</h3>
<p>发送带回车符的字符串。</p>
<h3 id="232-sendcontrol">2.3.2 sendcontrol()</h3>
<p>发送控制信号</p>
<h3 id="233-sendeof">2.3.3 sendeof()</h3>
<p>发送 EOF 信号</p>
<h3 id="234-sendintr">2.3.4 sendintr()</h3>
<p>发送终止信号</p>
<h3 id="24-interact-将控制权交给用户">2.4 interact() - 将控制权交给用户</h3>
<center><span style="font-size:40px">🧡</span></center>
<p>interact() 表示将控制权限交给用户（或者说标准输入）。一般情况下 pexpect 会接管所有的输入和输出，但有的时候还是希望用户介入，或者仅仅是为了完成一部分工作的时候， interact() 就很有用了。</p>
<h3 id="25-close">2.5 close()</h3>
<p>停止应用程序<br>
如果想中途关闭子程序，那么可以用 close 来完成，调用这个方法后会返回这个程序的返回值。<br>
如果设置 force=True 会强行关闭这个程序，大概的过程就是先发送 SIGHUP 和 SIGINT 信号，如果都无效的话就发 SIGKILL 信号，反正不管怎么样都会保证这个程序被关闭掉。<br>
多次调用这个方法是允许的，但是不保证每次都能返回正确的返回值。尽量不要这么做，如果想保证程序被关闭的话只要设置force的值就可以了。</p>
<h3 id="26-terminate">2.6 terminate()</h3>
<p>可以看作是上面 close() 的别名</p>
<h3 id="27-kill">2.7 Kill()</h3>
<p>发送 SIGKILL 信号，向子程序发送 SIGKILL 的信号。</p>
<h3 id="28-flush">2.8 flush()</h3>
<p>什么都不干，只是为了与文件方法兼容而已。</p>
<h3 id="29-isalive">2.9 isalive()</h3>
<p>检查子程序运行状态。<br>
检查被调用的子程序是否正在运行，这个方法是运行在非阻断模式下面的。<br>
如果获得的返回是 True 表示子程序正在运行；返回 False 则表示程序运行终止。</p>
<h3 id="210-isatty">2.10 isatty()</h3>
<p>检查是否运行在 TTY （即控制台）设备上</p>
<h3 id="211-next">2.11 next()</h3>
<p>返回下一行内容，和操作文件一样，这个方法也是返回缓存中下一行的内容。</p>
<h3 id="212-read">2.12 read()</h3>
<p>返回剩下的所有内容。</p>
<p>获取子程序返回的所有内容，一般情况下我们可以用 expect 来期待某些内容，然后通过 process.before 这样的方式来获取，但这种方式有一个前提：那就是必须先 expect 某些字符，然后才能用 process.before 来获取缓存中剩下的内容。</p>
<p>read() 的使用很不同，它期待一个 EOF 信号，然后将直到这个信号之前的所有输出全部返回，就像读一个文件那样。<br>
一般情况下，交互式程序只有关闭的时候才会返回 EOF ，比如用 by 命令关闭 ftp 服务器，或者用 exit 命令关闭一个 ssh 连接。<br>
这个方法使用范围比较狭窄，因为完全可以用 expect.EOF 方式来代替。当然如果是本机命令，每执行完一次之后都会返回 EOF ，这种情况下倒是很有用：</p>
<pre><code>process = pexpect.spawn('ls -l')output = process.read()print output
</code></pre>
<p>看起来这么做有点无聊？但我想一定有什么理由支持这个方法。<br>
可以用指定 read(size=-1) 的方式来设置返回的字符数，如果没有设置或者设置为负数则返回所有内容，正数则返回指定数量的内容，返回的内容是字符串形式。</p>
<h3 id="213-readlines-返回列表模式的所有输出">2.13 readlines() - 返回列表模式的所有输出</h3>
<p>返回一个列表，列表中的每个元素都是一行（包括\r\n字符）。</p>
<h3 id="214-setecho-子程序响应模式">2.14 setecho() - 子程序响应模式</h3>
<p>设置子程序运行时的响应方式，一般情况下向子程序发送字符的时候，这些字符都会在标准输出上显示出来，这样你可以看到你发送出去的内容，但是有的时候，我们不需要显示，那么就可以用这个方法来设置了。<br>
注意，必须在发送字符之前设置，设置之后在之后的代码中都一直有效。比如：</p>
<pre><code>process = pexpect.spawn('cat')# 默认情况下，下面的1234这个字符串会显示2次，一次是pexpect返回的，一次是cat命令返回的process.sendline(&quot;1234&quot;)# 现在我们关闭pexpect()的echo功能process.setecho(False)# 下面的字符只会显示一次了，这是由cat返回的process.sendline(&quot;abcd&quot;)# 现在重新开启echo功能，就可以再次看到我们发送的字符了process.setecho(True)
</code></pre>
<h3 id="215-setwinsize-控制台窗口大小">2.15 setwinsize() - 控制台窗口大小</h3>
<p>如果子程序是一个控制台（TTY），比如 SSH 连接、 Telnet 连接这种通过网络登陆到系统并发送命令的都算控制台，那么可以用这个方法来设置这个控制太的大小（或者说长宽）。<br>
它的调用方式是 <code>process.setwinsize(r, c)</code><br>
默认值是 <code>setwinsize(24, 80)</code>，其中 24 是高度，单位是行； 80 是宽度，单位是字符。<br>
为什么要用它？想像下面的场景：<br>
有的时候你通过pexpect登陆到某个ssh控制台之后，又用 interact() 来将控制权交给用户，然后用户到控制台里面写自己的命令，如果命令比较长，就会发现当命令到屏幕边缘之后不会自动换行，而是又返回到这一行的最前面重新覆盖前面的字符；这不会影响命令的实际效果，但是很恼人。<br>
这种情况用 setwinsize() 就可以解决，找到自己终端支持的长度，重新设置一下，比如 setwinsize(25, 96 )，如果设置的正确的话就可以解决了。</p>
<h3 id="216-wait-执行等待">2.16 wait() - 执行等待</h3>
<p>直到被调用的子程序执行完毕之前，程序都停止（或者说等待）执行。它不会从被调用的子程序中读取任何内容。</p>
<h3 id="217-waitnoecho">2.17 waitnoecho()</h3>
<p>它使用的地方比较特殊，唯一匹配的地方就是：当子程序的 echo 功能被设置为 Fals 时。<br>
看起来很奇怪？其实这个功能是基于一个很让人难以置信但的确是真实的情况：<br>
在命令行模式下，很多要求输入密码的地方，比如 FTP/SSH 等，密码实际上都会在你输入之后又重新返回并打印出来的，但是为什么我们看不到我们自己输入的密码呢？这就是因为密码在要打印出来之前被程序将 echo 功能设置为 False 了。<br>
现在知道为什么有这么一个方法了吧？比如要进行一个 ssh 连接时，如何检查是否要输入密码？用关键字 password 是一个方法，但还有一个方法就是这样：</p>
<pre><code class="language-python"># 启动ssh连接
process = pexpect.spawn(&quot;ssh user@example.com&quot;)
# 等待echo被设置为False，这就意味着本地不会有回显
process.waitnoecho()
process.sendline('mypassword')
</code></pre>
<p>可以设置超时时间，默认是：<code>waitnoecho(timeout=-1)</code>，表示和系统设置的超时时间相同，也可以设置为 None 表示永远等待，直到回显被设置为 False ，当然还可以设置其他的数字来表示超时时间。</p>
<h3 id="218-write-发送字符串">2.18  write() - 发送字符串</h3>
<p>类似于send()命令，只不过不会返回发送的字符数。</p>
<h3 id="219-writelines-发送包含字符串的列表">2.19 writelines() - 发送包含字符串的列表</h3>
<p>类似于 write() 命令，只不过接受的是一个字符串列表， writelines() 会向子程序一条一条的发送列表中的元素，但是不会自动在每个元素的最后加上回车换行符。<br>
与 write() 相似的是，这个方法也不会返回发送的字符数量。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。（参见封装）。通俗的说就是我们调用句柄就是调用句柄所提供的服务，即句柄已经把它能做的操作都设定好了，我们只能在句柄所提供的操作范围内进行操作，但是普通指针的操作却多种多样，不受限制。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2018 - 我的主屏]]></title>
        <id>https://hwang.top/post/2018-wo-de-zhu-ping</id>
        <link href="https://hwang.top/post/2018-wo-de-zhu-ping">
        </link>
        <updated>2019-01-17T02:09:55.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyja5mmnd3j30u01no4fr.jpg" alt=""></figure>
<p>2018年，对我来说变化太多了。首先总结一下自己手机的软件使用。</p>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyja5mmnd3j30u01no4fr.jpg" alt=""></figure>
<p>2018年，对我来说变化太多了。首先总结一下自己手机的软件使用。</p>
<!-- more -->
<h2 id="第一排">第一排</h2>
<ol>
<li>微信：糟糕的高墙。</li>
<li>倍洽：办公用的聊天工具。工作用。</li>
<li>Castro：一个高效便捷好看的播客应用。已订阅。💰</li>
<li>Copied：剪贴板工具。Mac 和 iPhone 上双平台在用。利用一些脚本，可以自动记录一些特殊信息，例如颜色（#0068B8）、淘宝分享信息，并且用以存放常用的文本信息（邮件模板、日常工作等）。iOS上，输入法中切换能够快速输入，对我来说很方便。</li>
</ol>
<h2 id="第二排">第二排</h2>
<ol>
<li>Trello：项目管理工具。工作用。</li>
<li>Outlook：目前主力的邮件 App。邮件处理坚持 「Inbox Zero」，要么去 Todoist，要么去 Evernote，剩下的就是通通进入 achieve。 并不做整理，因为需要整理的都在 Evernote 里。</li>
<li>App store ：🌚</li>
<li>tweetbot ： 用来刷tweet的第三方客户端。只看不发的那种，twitter 第三方政策变动对我来说，其实并没有什么影响。</li>
</ol>
<h2 id="第三排">第三排</h2>
<p>文件夹。跳过。</p>
<h2 id="第四排">第四排</h2>
<ol>
<li>Evernote ：国区高级版用户+国际版普通用户。是我数字生活的归档箱。所有能够归档的都是归档于此。国际版只是为方便我的阅读流程使用。</li>
<li>Instapaper ： 依然没有换 Pocket ... 是我阅读输入流程中的一环，也是对我来说最重要的软件之一。</li>
<li>Moneywiz ：记账软件。最近开销有点大……</li>
<li>telegram ：主要拿来联系亲人。加了一堆群，几乎不发言。以及用来看各种 channel。</li>
</ol>
<h2 id="第五排">第五排</h2>
<ol>
<li>Timepage ： 老用户，免费送了 iPad 版，相比（其他转订阅的厂商）而言，尽然有些不好意思。用以查看各种日程，离开学校后，明显还没有找到使用日历的节奏。需求并没有那么强了。</li>
<li>Ulysses ： 用「Markdown XL」写作的写作软件。日常工作的文档，非常方便。平时写东西，习惯分节写作，这样能够减少长篇大论的压力感。</li>
<li>极光字典 ：一个查单词的应用，满足我点开即用的需求，并且能够导出历史记录、收藏记录。</li>
<li>NOMO ：拍照软件，满足的需求了打开就能拍。并且一个个好看的相机也满足了收藏癖的虚荣心。VSCO 设置后也能直接打开相机，NOMO 给我的那种精致感，让我选择留它在主页。（说得好像我多会拍照似的）</li>
</ol>
<h2 id="第六排">第六排</h2>
<ol>
<li>Spotify ： 听歌软件。</li>
<li>捷径 ： iPhone、iPad上处理许多流程的重要工具。</li>
<li>Pythonista ：即买了Jsbox，又买了 Pythonista……我也不知道为什么。还不熟悉，能够在捷径中运行python，所以买了。</li>
<li>hyperapp ：经常需要临时操作一下服务器。总体感觉还行，比较而言，在终端的使用体验上，还是 termius 操作更便利一些（一些在手机上的手势操作，让人用的更加舒服）。优势是一些服务的快速部署，以及非常棒的连接方式。</li>
</ol>
<h2 id="dock-栏">Dock 栏</h2>
<ol>
<li>Todoist ：任务管理，GTD。</li>
<li>Drafts ：碎片收集与整理。</li>
<li>Launch ：启动器。</li>
<li>Reeder ：RSS阅读器。</li>
</ol>
<h2 id="launch-中的动作">Launch 中的动作</h2>
<figure data-type="image" tabindex="2"><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fyja5xap7tj30u01nogpf.jpg" alt=""></figure>
<blockquote>
<p>上至下左至右</p>
</blockquote>
<ol>
<li>Time ：看倒计时</li>
<li>翻译：输入文本翻译</li>
</ol>
<hr>
<ol>
<li>即刻</li>
<li>立即开始番茄钟倒计时</li>
<li>快速创建长截图</li>
</ol>
<hr>
<ol>
<li>切换apple store地区</li>
<li>剪贴板相关的动作：清空剪贴板、剪贴板搜索（ai search、淘宝两个动作）；发送剪贴板内容到Twitter、微博；查单词；</li>
<li>Workflow （捷径）相关：主要用来存放一些定期执行的任务。</li>
<li>Person ： 一些个人常用的动作</li>
<li>📱：一个人常用的比较复杂一些的快捷操作</li>
<li>QuickS：搜索聚合。各种搜索。</li>
<li>国内：各种 pay 、扫描二维码、充话费等服务。</li>
<li>Newspaper：用来打开软件看下载客户端的媒体的文章，好奇心日报、Medium、少数派、数字尾巴。</li>
<li>冗余：一些需要打开，又不需要出现在首页上的app。</li>
<li>App 兑换 ：并不常用。</li>
<li>Pic：和图像处理有关的动作：白描、picsew、pico、vsco 等</li>
<li>Bose：连接音箱。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ML - Python LASSO 算法实现]]></title>
        <id>https://hwang.top/post/ml-python-lasso-suan-fa-shi-xian</id>
        <link href="https://hwang.top/post/ml-python-lasso-suan-fa-shi-xian">
        </link>
        <updated>2018-07-13T02:15:38.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-python">import itertools
from math import exp
import numpy as np
import matplotlib.pyplot as plt
from numpy import *</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-python">import itertools
from math import exp
import numpy as np
import matplotlib.pyplot as plt
from numpy import *


&lt;!-- more --&gt;


## 库导入

def load_data(filename):
## 加载数据的函数
	X, Y = [], [] ##列表存储
	with open(filename, 'r') as f: #读取文件
		for line in f:
			splited_line = [float(i) for i in line.split()] #分割行储存到 splited_line 中
			x, y = splited_line[: -1], splited_line[-1] #读取第一列和第一行数据，储存为x，y
			X.append(x)
			Y.append(y)
	X, Y = np.matrix(X), np.matrix(Y).T
	return X, Y

####################################


def standarize(X):
# 中心化 &amp; 标准化数据 (零均值, 单位标准差)

	std_deviation = np.std(X, 0) 

# 利用numpy，计算X的标准差。
# std（a, axis = None） ：同理，计算标准差。 依给定轴axis计算数组a相关元素标准差，其中axis为整数或者元组。
	
	mean = np.mean(X, 0)# 对数组a的第1维度的数据进行求平均 
	return (X - mean)/std_deviation 


#######################################

# 一般线性回归函数 OLS；

def std_linreg(X, Y):
	xTx = X.T*X # 利用numpy 做矩阵的装置。
	if np.linalg.det(xTx) == 0:
		print('xTx is a singular matrix')
		return
	return xTx.I*X.T*Y


#######################################


def get_corrcoef(X, Y):
	# X Y 的协方差
	cov = np.mean(X*Y) - np.mean(X)*np.mean(Y)
	return cov/(np.var(X)*np.var(Y))**0.5

 


#######################################


def lasso_regression(X, y, lambd=0.2, threshold=0.1):

# 通过坐标下降(coordinate descent)法获取LASSO回归系数

	# 计算残差平方和
	rss = lambda X, y, w: (y - X*w).T*(y - X*w)
	# 初始化回归系数w.
	m, n = X.shape
	w = np.matrix(np.zeros((n, 1)))
	r = rss(X, y, w)
	# 使用坐标下降法优化回归系数w
	niter = itertools.count(1)
	for it in niter:
		for k in range(n):
			# 计算常量值z_k和p_k
			z_k = (X[:, k].T*X[:, k])[0, 0]
			p_k = 0
			for i in range(m):
				p_k += X[i, k]*(y[i, 0] - sum([X[i, j]*w[j, 0] for j in range(n) if j != k]))
			if p_k &lt; -lambd/2:
				w_k = (p_k + lambd/2)/z_k
			elif p_k &gt; lambd/2:
				w_k = (p_k - lambd/2)/z_k
			else:
				w_k = 0
			w[k, 0] = w_k
		r_prime = rss(X, y, w)
		delta = abs(r_prime - r)[0, 0]
		r = r_prime
		print('Iteration: {}, delta = {}'.format(it, delta))
		if delta &lt; threshold:
			break
	return w


##################################


# 定义lasso算法

def lasso_traj(X, y, ntest=30):
#  获取回归系数轨迹矩阵

	_, n = X.shape
	ws = np.zeros((ntest, n))
	for i in range(ntest):
		w = lasso_regression(X, y, lambd=exp(i-10))
		ws[i, :] = w.T
		print('lambda = e^({}), w = {}'.format(i-10, w.T[0, :]))
	return ws

####################################


if '__main__' == __name__: #模块是对象，并且所有的模块都有一个内置属性 __name__。一个模块的 __name__ 的值取决于您如何应用模块。如果 import 一个模块，那么模块__name__ 的值通常为模块文件名，不带路径或者文件扩展名。但是您也可以像一个标准的程序样直接运行模块，在这种情况下, __name__ 的值将是一个特别缺省&quot;__main__&quot;。
## https://www.zhihu.com/question/49136398


	X, y = load_data('abalone.txt')
	X, y = standarize(X), standarize(y)
	w = lasso_regression(X, y, lambd=10)
	y_prime = X*w
	## 计算相关系数

	corrcoef = get_corrcoef(np.array(y.reshape(1, -1)),
							np.array(y_prime.reshape(1, -1)))
								## 计算协方差

	print('Correlation coefficient: {}'.format(corrcoef))
	ntest = 30

	## 绘制轨迹

	ws = lasso_traj(X, y, ntest)
	fig = plt.figure()
	ax = fig.add_subplot(111)
	lambdas = [i - 10 for i in range(ntest)]
	ax.plot(lambdas, ws)
	plt.show()


</code></pre>
]]></content>
    </entry>
</feed>