<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hwang.top</id>
    <title>Hwang&apos;s Blog</title>
    <updated>2019-10-07T12:23:54.914Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hwang.top"/>
    <link rel="self" href="https://hwang.top/atom.xml"/>
    <subtitle>欢迎来到 Hwang 的小博客</subtitle>
    <logo>https://hwang.top/images/avatar.png</logo>
    <icon>https://hwang.top/favicon.ico</icon>
    <rights>All rights reserved 2019, Hwang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Docker 的入门「指北」]]></title>
        <id>https://hwang.top/post/docker-de-ru-men-zhi-bei</id>
        <link href="https://hwang.top/post/docker-de-ru-men-zhi-bei">
        </link>
        <updated>2019-10-07T12:21:51.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>本文以发布于少数派：https://beta.sspai.com/post/56893<br>
推荐在少数派阅读</p>
</blockquote>
<p>如果你购买过 VPS 云主机，那么或多或少，你都可能听说过 Docker。如果你从未听说过Docker，那么本文可能能够为你开启新世界。</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>本文以发布于少数派：https://beta.sspai.com/post/56893<br>
推荐在少数派阅读</p>
</blockquote>
<p>如果你购买过 VPS 云主机，那么或多或少，你都可能听说过 Docker。如果你从未听说过Docker，那么本文可能能够为你开启新世界。</p>
<!-- more -->
<p>利用Docker，你能够哦非常轻松的部署各类服务，无论是个人云盘（<a href="https://sspai.com/post/55217">Nextcloud：打造属于自己的网盘服务 Docker 版(附带视频</a>）、个人的RSS服务（<a href="https://sspai.com/post/53072">利用 Docker 搭建 Tiny Tiny RSS 服务</a>）、HomeKit 桥接（<a href="https://sspai.com/post/53071">利用 Docker 搭建 HomeKit 智能家居</a>），亦或者搭建一个个人博客（<a href="https://sspai.com/post/36751">使用 Docker 部署 Ghost 教程</a>），甚至是做一个自己的维基百科、自己的社交软件，都能够轻松的实现。</p>
<p>是的，Docker 就好像是 服务器端的「应用商店」，你能够通过Docker，轻松的部署各种属于个人、团队的服务。而现如今，无论是利用各个平台的云主机，还是 树莓派、群晖、威联通等这些物理的服务器主机，甚至是自己废旧的老电脑，都能够很容易的使用上 Docker。</p>
<p>在正式开启前，本文默认读者了解基本的命令行操作，以及了解基本的Linux相关知识，如果您还不了解这些，可以通过 B站 这个 UP 主的视频有所了解：<a href="https://www.bilibili.com/video/av56233347">https://www.bilibili.com/video/av56233347</a></p>
<h2 id="那么开启-docker-之旅吧">那么开启 Docker 之旅吧！</h2>
<p>Docker 可以理解为寄存在主机上的特殊的虚拟机。它利用特殊的虚拟化技术，比一般的虚拟化技术能够更加高效合理的利用资源。一台主机上可以创建众多的容器，这些容器通过特定的方式与主机共享硬件资源，并且访问特定的文件，使用特定的端口。通过 Docker ，一台主机能够运行多种不同的服务。</p>
<h3 id="第一步安装或者启用-docker">第一步，安装或者启用 Docker</h3>
<p>一般来说，Docker 会运行在 Linux 服务器上，无论是哪种发行版本，你都可以非常容易的在搜索引擎中找到其他平台的安装方法。这里我以 Ubuntu 为例：</p>
<pre><code class="language-bash">$ sudo apt update # 先更行一下软件包缓存
$ sudo apt install docker-ce # ce 代表社区版
</code></pre>
<p>接着启动 Docker 服务</p>
<pre><code class="language-bash">$ sudo systemctl enable docker
$ sudo systemctl start docker
</code></pre>
<p>这样，你就可以尝试一下运行 <code>docker</code> 命令了</p>
<pre><code class="language-bash">$ sudo docker run hello-world
</code></pre>
<blockquote>
<p>默认情况下，docker 命令需要使用 <code>root</code> 用户或者在<code>docker</code>组下的用户才能使用（<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯）。也就是说，如果不设置，默认情况下，所有的 <code>docker</code> 命令都需要加 <code>sudo</code>。<br>
一般情况下，你可以创建一个名为  <code>docker</code> 的用户组，再将当前用户加入到 <code>docker</code> 组中，使得操作更为安全。</p>
</blockquote>
<blockquote>
<pre><code class="language-bash">$ sudo groupadd docker #创建 Docker 组。
$ sudo usermod -aG docker $USER #添加当前用户到 docker 用户组中，也可将 $USER 替换为你想加入到 docker 组中的用户。
</code></pre>
</blockquote>
<h3 id="第二步拉取你的第一个-image">第二步，拉取你的第一个 Image</h3>
<p>其实你可以这么理解 Docker，你可以在一个名为 <a href="https://hub.docker.com/">Docker Hub</a> 的网站中，查找Docker 镜像（image），这个过程就好像是在 App Store 中搜索自己需要下载的应用一样。查找完想要下载的镜像后，在终端中输入：</p>
<pre><code class="language-bash">$ docker pull [镜像名称]
</code></pre>
<p>可以拉取镜像的到本地。是的，你就下载了这个应用，只不过是在服务端。当然，一般来说这个过程会比较缓慢，你可以<a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html">替换国内源</a>加速这一过程。</p>
<h3 id="第三步启动你的服务">第三步，启动你的服务</h3>
<p>与一般应用下载打开不同，Docker 的镜像可以重复的被打开成不同的容器。你可以简单的理解为这是「应用双开」，或者说是「应用多开」。我们使用 <code>docker run</code> 命令来启动容器。</p>
<p>这个启动的过程可以是一次性的启动，即直接使用 <code>docker run</code> + 一些列参数的方式启动服务，也可以通过 <code>docker compose</code> 来编排你的项目。由于 compose 会相对专业，本文就不做过多的介绍了，这里只以 <code>docker run</code> 为例作为讲解，以下是常见的参数：</p>
<ol>
<li><code>-d</code> ：正常情况下，启动一个服务区，我们都会让其在后台运行，所以使用参数 <code>-d</code> 来告诉 Docker，在后台默默奉献即可。</li>
<li><code>--name=</code> ：前面已经提到了，你可以对一个 Docker 镜像进行多开操作，所以通过 <code>dockr run -d --name=[你的名字]</code> 的方式，可以指定开启的这个容器的名称，这样在多开的情况下，能够更为方便的进行管理。</li>
<li><code>-p</code> : 指定端口的映射。</li>
</ol>
<p>这里简单讲解一下端口的含义：以用户输入在浏览器中输入<code>www.sspai.com</code> 为例，首先浏览器会通过 DNS 服务器把这个 Url 翻译为 IP 地址，再通过 IP 地址，找到少数派的服务器，再通过端口号确定开启的服务，例如如果你输入的是：<code>https:\\www.sspai.com</code>，那么对应的端口就是 443。端口号就相当于服务器的柜台，同个服务区会有多个柜台提供服务。诸如 <code>http</code> 服务，默认是 <code>80</code> 端口， <code>https</code> 默认是 <code>443</code> 端口，类似的 <code>FTP</code> 服务是 <code>21</code> 等等。 并且<strong>一个端口只能支持一个服务，就是说一个柜台只支持办理一项服务</strong>。</p>
<p>回到 <code>-p</code> 这个参数，<code>-p 8080:80</code> 就是指将 docker 中开启的端口，映射到主机的 <code>8080</code> 端口中。也就是说通过主机的IP地址的<code>8080</code> 端口，可以访问到 docker 容器的<code>80</code> 端口服务。 服务器的 <code>8080</code> 柜台接收到的服务，会发送到容器的<code>80</code>柜台中。是的，容器也相当于是一个服务器，在 Docker 内部，他们之间也是有 IP 地址的说法的，所以容器也是需要开「柜台」来管理服务的。</p>
<p>理解这一步非常重要，和一般的使用应用不同，服务器上的应用就是一直在运行，然后让你去访问的，所以 <code>-p</code> 参数设置不对，可就找不到柜台办理正确的服务器了。例如运行：</p>
<pre><code class="language-bash">$ docker run -d --name=nextcloud_demo -p 8080:80 nextcloud
</code></pre>
<p>那么你可以通过 <code>http://localhost:8080</code> 访问到你的 nextcloud 服务。这里的 <code>loaclhost</code> 指的是在 Docker 服务器上访问。如果你想通过自己的电脑，访问 Docker 服务器上的服务，把 <code>loaclhost</code> 替换为服务器的 IP 地址即可。</p>
<ol start="4">
<li><code>-v</code> ：建立主机于docker容器内的文件关联。通过<code>-v</code> 能够 主机的文件映射到 docker 容器中，例如：</li>
</ol>
<pre><code class="language-bash">$ docker run -d \
-v nextcloud:/var/www/html \
nextcloud
</code></pre>
<p>就是将本地本地文件夹 <code>nextcloud</code> 映射到容器中的 <code>/var/www/html</code> 目录。</p>
<p>这 4 个参数就是docker 最基础也是最常用的参数了。了解了这四个参数，再参照 Docker Hub 下每一个镜像的使用说明，你就可以尽情的拥抱和享受开源社区的各种服务了。</p>
<h2 id="推荐一些好用的-docker-镜像">推荐一些好用的 Docker 镜像</h2>
<p>除了开篇提到的 NextCloud、Tiny Tiny RSS、Ghost 等服务外，还有一些镜像值得尝试：</p>
<ol>
<li><a href="https://hub.docker.com/_/mediawiki">MediaWiki</a>： 和维基百科一样的属于个人或者团队的维基服务。</li>
<li><a href="https://hub.docker.com/r/wekanteam/wekan">Wekan</a>：属于个人或者团队的开源看板应用。参考Trello等服务。</li>
<li><a href="https://hub.docker.com/_/wordpress">WordPress</a>：为人所知的、被广泛使用的、收购了tumblr的博客服务，可以用来搭建个人博客，甚至商用网站。</li>
<li>gitlab、gitea 等 Git 服务：如果有团队代码管理需求，可以使用 Docker 快速部署一个私用的 Git 服务。</li>
</ol>
<h2 id="部署一时爽运维火葬厂">部署一时爽，运维「火葬厂」</h2>
<p>Docker 让服务的安装变得异常容易，但是选择一项服务后，后面的运维才是真正折腾人的地方。</p>
<p>首先是管理容器中，最常使用到：</p>
<pre><code class="language-bash">$ docker ps #查看运行中的容器。
$ docker ps -a #查看所有容器，包括停止的。
$ docker images #查看安裝的镜像
</code></pre>
<p>然后是停止、启动已有的容器：</p>
<pre><code class="language-bash">$ docker stop &lt;容器名称/ID&gt; # 正常停止容器
$ docker start &lt;容器名称/ID&gt; # 启动已有容器
$ docker kill &lt;容器名称/ID&gt; # 强制停止容器
</code></pre>
<p>一般容器运行后，会有一个 ID，用以区分容器，这个ID 一般都是乱序的，所以之前的 <code>--name</code> 参数，能够使你更加方便对容器进行管理。</p>
<p>除此之外，还有就是进入 Docker 容器中，修改一些配置文件：</p>
<pre><code class="language-bash">$ sudo docker exec -it &lt;容器名称/ID&gt; /bin/bash
</code></pre>
<p>就是说你可以通过这个命令，进入到 容器的 <code>bash</code> 中，对容器内进行一些修改。</p>
<p>最后 docker 还有许多其他的命令和方法可供学习。作为当今最受欢迎的容器化解决方案，docker 在业界发光发亮的同时，也为一般用户，「一键」启用某些服务提供了契机。利用开源社区，你可以比以往任何时候都更为容易的实现许多互联网服务的「自给自足」。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hwang 的低质阅读单 New 2]]></title>
        <id>https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-2</id>
        <link href="https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-2">
        </link>
        <updated>2019-10-06T07:47:27.000Z</updated>
        <content type="html"><![CDATA[<h6 id="这些文章来自-hwang-的-instapaper-从-rss-微博-微信等地方看到觉得自己应该仔细看看的文章收集进-instapaper-归档这些文章后才会出现这里-故而主观又缺乏时效性-很遗憾没有帮到你们">这些文章来自 Hwang 的 Instapaper 。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper ，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。</h6>
<ul>
<li><a href="https://jonuknownothingsnow.github.io/2019/04/13/%E8%B0%90%E9%97%A8%E6%AD%A6%E5%AD%A6%EF%BC%9A%E4%BD%BF%E7%94%A8JupyterHub%E6%90%AD%E5%BB%BA%E5%A4%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E5%8F%B0/index.html"> 谐门武学：使用JupyterHub搭建多用户数据控制台</a></li>
<li><a href="https://ift.tt/2mGOpv0"> 使用 Python 函数进行模块化</a></li>
<li><a href="https://ift.tt/2mLmHxh"> 约定式提交</a></li>
<li><a href="https://ift.tt/2NRTWeO"> PyQt5 tutorial - Python GUI programming examples - Like Geeks</a></li>
<li><a href="https://ift.tt/2zphOwJ"> 为什么你的SaaS会“失败”？_36氪</a></li>
<li><a href="https://ift.tt/2LL5u0F"> 香港：（曾经的）实践中有限政府的最好例子</a></li>
<li><a href="https://ift.tt/30Ikele"> 12条经验，让你在机器学习的路上避免很多坑</a></li>
<li><a href="https://ift.tt/2Yi3L6P"> 苹果不再需要 Jony Ive</a></li>
<li><a href="https://ift.tt/2LVP077"> Qt for Python &amp; PyInstaller — Qt for Python</a></li>
<li><a href="https://ift.tt/2LMRZgT"> 整容的人越来越年轻了，自拍是罪魁祸首</a></li>
<li><a href="https://ift.tt/2OnjbF0"> 刘林平 | 规律与因果：大数据对社会科学研究冲击之反思</a></li>
<li><a href="https://ift.tt/32WXsro"> 组策略应用——安装软件-Rainy`s IT Tech Blog-51CTO博客</a></li>
<li><a href="https://ift.tt/3209O1C"> PyQt 5信号与槽的几种高级玩法 - 博文视点</a></li>
<li><a href="https://ift.tt/2Vcqsc0"> Python 工匠：使用数字与字符串的技巧</a></li>
<li><a href="https://ift.tt/2LLMTBK"> 5代防火墙 -- 网络系统 -- IT技术博客大学习 -- 共学习 共进步！</a></li>
<li><a href="https://ift.tt/2OmMI1e"> 我的书桌——先砸一块砖</a></li>
<li><a href="https://ift.tt/2APiRXf"> 漫话中文自动分词和语义识别（下）：句法结构和语义结构 -- 算法 -- IT技术博客大学习 -- 共学习 共进步！</a></li>
<li><a href="https://ift.tt/34qeNur"> Type is Beautiful » 孔雀计划：中文字体排印的思路</a></li>
<li><a href="https://ift.tt/2MeDdP1"> 简明Vim练级攻略 -- Linux -- IT技术博客大学习 -- 共学习 共进步！</a></li>
<li><a href="https://ift.tt/2pNiASF"> 数据科学入门后，该做什么？</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Qt for Python 的小Tips —— 外部加载 QSS]]></title>
        <id>https://hwang.top/post/qt-for-python-de-xiao-tips-wai-bu-jia-zai-qss</id>
        <link href="https://hwang.top/post/qt-for-python-de-xiao-tips-wai-bu-jia-zai-qss">
        </link>
        <updated>2019-10-06T07:37:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pyqt5pyside2-加载-qss-文件">PyQt5/PySide2 —— 加载 QSS 文件</h2>
<pre><code class="language-python">class beautifyUI(object):
    def __init__(self):
        pass
    def readQss(self, qssfile):
        &quot;&quot;&quot;
        加载 QSS 文件；
        qssfile：qss文件路径；
        &quot;&quot;&quot;
        with open(qssfile, &quot;r&quot;) as f:
            return f.read()   
</code></pre>
<p>定义一个函数，基本上就可以通过这个 读取 QSS 作为字符串，然后存为变量，读取进去就OK了。</p>
<p>当然这个文件在打包时也要特殊处理：要么作为字符串储存于某个变量中，要么直接在特定目录下去读取这个文件。在mac的应用打包中，格外需要注意这点。请尽量使用绝对路径记录信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Qt for Python 的小 Tips - 不显示软件的「大下巴」— QStatus]]></title>
        <id>https://hwang.top/post/qt-for-python-bu-xian-shi-ruan-jian-de-da-xia-ba-qstatus</id>
        <link href="https://hwang.top/post/qt-for-python-bu-xian-shi-ruan-jian-de-da-xia-ba-qstatus">
        </link>
        <updated>2019-10-06T07:35:37.000Z</updated>
        <content type="html"><![CDATA[<p>这里设置 软件的底部信息栏，PySide 中称为 QStatusbar。</p>
<p>利用 QT Creator 生成的 mainWindows 软件会自动添加该部件。如果不需要底部状态栏，注释掉就可以了。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/10/06/3iQ5fJxY1rZNEgb.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Procreate 练习]]></title>
        <id>https://hwang.top/post/procreate-lian-xi</id>
        <link href="https://hwang.top/post/procreate-lian-xi">
        </link>
        <updated>2019-10-01T12:17:19.000Z</updated>
        <content type="html"><![CDATA[<p>画图，画图。</p>
<p>好久没有动笔了。线条画的一点都不流畅了。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/10/01/xwQ8BVtOInGfvW7.png" alt="IMG_0404.PNG"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Update 了一下 figma 的封面]]></title>
        <id>https://hwang.top/post/update-liao-yi-xia-figma-de-feng-mian</id>
        <link href="https://hwang.top/post/update-liao-yi-xia-figma-de-feng-mian">
        </link>
        <updated>2019-09-30T10:00:58.000Z</updated>
        <content type="html"><![CDATA[<p>更新了一下figma的封面：<br>
<img src="https://hwang.top/post-images/1569837778140.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个用了 3 个月 PyQt 的人，在学 Vue.js 基础]]></title>
        <id>https://hwang.top/post/yi-ge-yong-liao-3-ge-yue-pyqt-de-ren-zai-xue-vuejs-ji-chu</id>
        <link href="https://hwang.top/post/yi-ge-yong-liao-3-ge-yue-pyqt-de-ren-zai-xue-vuejs-ji-chu">
        </link>
        <updated>2019-09-30T01:53:10.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>el:</p>
</li>
<li>
<p>data:</p>
</li>
<li>
<p>methods: 用于存放 事件内的方法。 可以理解为 PyQt 中 存放 槽函数 的一个字典。</p>
</li>
<li>
<p>v-cloak 能够解决插值表达式（<code>{{}}</code>） 闪烁 的问题<br>
<code>&lt;v-test='msg'&gt;</code></p>
</li>
<li>
<p>v-test 没有闪烁问题，会覆盖元素中原本的内容，但是，插值表达式只会替换自己的占位符。</p>
</li>
<li>
<p>v-html : 输出闪烁问题</p>
</li>
<li>
<p>v-blind : 绑定 属性 的指令，简写为 <code>:</code> ; v-blind 可以写合法的 js 表达式</p>
</li>
<li>
<p>v-on : 绑定 事件的 （类似 qt 中的 信号与槽的绑定），简写为 <code>@</code></p>
</li>
<li>
<p>v-model: 双向数据绑定，只能用在表单元素（input（radio、text、address、email...） select checkbox textarea）中。</p>
</li>
<li>
<p>v-for: 循环操作</p>
<ul>
<li><code>&lt;p v-for =&quot;item in list&quot;&gt;{{item}}&lt;/p&gt;</code></li>
<li><code>&lt;p v-for =&quot;(item, i) in list&quot;&gt;索引值:{{i}} --- 项目：{{item}}&lt;/p&gt;</code></li>
<li>可以迭代 1.普通数组；2.对象数组；3.对象；4. 数字（起始是1）</li>
<li>在组件中使用 V-for 循环的时候，必须使用 v-for 的同时，制定唯一的字符串/数字类型的 key 值</li>
</ul>
</li>
<li>
<p>v-if</p>
<ul>
<li>每次都会重新删除或者创建元素</li>
<li>有较高的切换性能消耗</li>
</ul>
</li>
<li>
<p>v-show</p>
<ul>
<li>切换元素的 display:none 样式</li>
<li>有较高的初始渲染消耗</li>
</ul>
</li>
</ul>
<h2 id="事件修饰符">事件修饰符</h2>
<ul>
<li>@click.stop 阻止事件的冒泡（从内到外，触发事件）</li>
<li>@click.prevent 阻止默认行为的使用</li>
<li>.capture 以捕获机制触发行为（从外到里，触发事件）</li>
<li>.self 只有自身的时候执行</li>
<li>.once 只触发一次</li>
</ul>
<h2 id="vue-中使用样式">vue 中使用样式</h2>
<ul>
<li>使用数组 <code>:class = ['style1','style2']</code> 会给出style1和style2的合并样式效果</li>
<li><code>:class = ['style1','style2',{'style3':flag}]</code>使用 v-blind ，伪 Class 表达可以使用对象的方式赋值，能够更好的实现样式变化的情况,在data中：<br>
<code>data flag: true }</code><br>
此时能够通过js来控制这个样式的实现与否。</li>
<li>在数组中可以使用 <a href="#">三元表达式</a>(https://baike.baidu.com/item/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/1394210)，python 中 类是 if 的判断语句</li>
<li>可以直接使用对象的方式调用样式。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 的虚拟环境管理  virtualenv & pyenv]]></title>
        <id>https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv</id>
        <link href="https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv">
        </link>
        <updated>2019-09-29T02:11:01.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
<!-- more -->
<p>由于生产需要，用 PyQt5 写了小程序，打包成 <code>.app</code> 过程中发现，打包后竟然有200多M，应该是因为之前使用的python环境中其他包比较多的关系。所以就想到建虚拟环境，来打包。</p>
<p>首先想到的是按项目建虚拟环境，那就用virtualenv 。简单看了一下，实践如下：</p>
<h2 id="virtualenv">virtualenv</h2>
<h3 id="1-安装virtualenv">1. 安装virtualenv</h3>
<p>用pip进行安装。</p>
<pre><code class="language-bash">$ pip install virtualenv 
</code></pre>
<p>先建文件夹，再<code>cd</code>到需要的文件夹中，运行下面的命令：</p>
<pre><code class="language-bash">$ virtualenv --python=&quot;/usr/local/bin/python3.7&quot; --no-site-packages venv
</code></pre>
<p>其中：</p>
<pre><code class="language-bash">--python （-p） # 用于指定版本
--no-site-packges # 表示不需要包
venv # 虚拟环境的名称
</code></pre>
<p>其它选项：</p>
<pre><code class="language-bash">--version
#显示当前版本号。
-h, --help
#显示帮助信息。
-v, --verbose
#显示详细信息。
-q, --quiet
#不显示详细信息。
-p PYTHON_EXE, --python=PYTHON_EXE
#指定所用的python解析器的版本，比如 --python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前系统安装(/usr/bin/python)的python解析器
--clear
#清空非root用户的安装，并重头开始创建隔离环境。
--no-site-packages
#令隔离环境不能访问系统全局的site-packages目录。
--system-site-packages
#令隔离环境可以访问系统全局的site-packages目录。
--unzip-setuptools
#安装时解压Setuptools或Distribute
--relocatable
#重定位某个已存在的隔离环境。使用该选项将修正脚本并令所有.pth文件使用相当路径。
--distribute
#使用Distribute代替Setuptools，也可设置环境变量VIRTUALENV_DISTRIBUTE达到同样效要。
--extra-search-dir=SEARCH_DIRS
#用于查找setuptools/distribute/pip发布包的目录。可以添加任意数量的–extra-search-dir路径。
--never-download
#禁止从网上下载任何数据。此时，如果在本地搜索发布包失败，virtualenv就会报错。
--prompt==PROMPT
#定义隔离环境的命令行前缀。
#环境变量和配置文件
</code></pre>
<h3 id="2-激活虚拟环境">2. 激活虚拟环境</h3>
<pre><code class="language-bash">$ . venv/bin/activate
</code></pre>
<figure data-type="image" tabindex="1"><img src="DraggedImage.png" alt=""></figure>
<p>前面出现<code>(venv)</code> 即可。</p>
<h3 id="一些发现">一些发现</h3>
<ul>
<li>virtualenv 默认似乎是从原环境中下载包的。就是优先直接从原有库中拷贝，不通过下载。这样速度会比较快。</li>
</ul>
<blockquote>
<p>由于本地环境除了 anaconda 的以为， Python 3.7。在打包中出现了一些兼容性问题，具体可见：<br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/1957">https://github.com/pyinstaller/pyinstaller/issues/1957</a><br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/3753">https://github.com/pyinstaller/pyinstaller/issues/3753</a><br>
即便按照issues里说的做了，我也没能解决问题。所以想到下载 3.6版本的 Python 来使用。所以就想到了用 pyenv</p>
</blockquote>
<h2 id="pyenv">pyenv</h2>
<p>基本过程可参考：<a href="https://www.jianshu.com/p/4646dedaaff5">https://www.jianshu.com/p/4646dedaaff5</a></p>
<h3 id="1-安装">1. 安装</h3>
<p>我是通过 Homebrew 下载的（可参考：<a href="https://zhuanlan.zhihu.com/p/27294128">https://zhuanlan.zhihu.com/p/27294128</a>）。</p>
<blockquote>
<p>备份一下 <code>.bash_profile</code></p>
</blockquote>
<pre><code class="language-bash"># Setting PATH for Python 3.7
# The original version is saved in .bash_profile.pysave
PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}&quot;
export PATH

# added by Anaconda3 5.2.0 installer
export PATH=&quot;/Users/wangxuexi/anaconda3/bin:$PATH&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
</code></pre>
<pre><code class="language-bash">$ brew install pyenv
</code></pre>
<p>有可能需要：</p>
<pre><code class="language-bash">$ echo 'export PYENV_ROOT=&quot;$HOME/.pyenv&quot;' &gt;&gt; ~/.bash_profile
$ echo 'export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile
$ echo 'eval &quot;$(pyenv init -)&quot;' &gt;&gt; ~/.bash_profile
</code></pre>
<p>写完后，用以下命令重新登录一下：</p>
<pre><code class="language-bash">$ source ~/.bash_profile
</code></pre>
<p>如果有需要可以安装 pyenv-virtualenv:</p>
<pre><code class="language-bash">$ brew install pyenv-virtualenv
</code></pre>
<p>同样的：</p>
<pre><code class="language-bash">$ echo 'eval &quot;$(pyenv virtualenv-init -)&quot;' &gt;&gt; ~/.bash_profile
# 写入 profile
$ source  ~/.bash_profile
# 重新进登录一遍
</code></pre>
<p>命令参数如下</p>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt; # 建虚拟环境
pyenv virtualenv activate &lt;virtualenv-name&gt; # 激活虚拟环境
pyenv virtualenv-delete &lt;virtualenv-name&gt; # 删除虚拟环境
</code></pre>
<h3 id="2-pyenv-的使用">2. pyenv 的使用</h3>
<p>基本的下载、删除 命令：</p>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v # 用国内源安装很快
</code></pre>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install
</code></pre>
<hr>
<pre><code class="language-bash">$ pyenv install -v 3.6.0  # 安装

$ pyenv uninstall 2.7.10 # 删除
</code></pre>
<p>激活，pyenv 有几种激活方式：</p>
<pre><code class="language-bash">local       Set or show the local application-specific Python version
global      Set or show the global Python version
shell       Set or show the shell-specific Python version
</code></pre>
<p>通过<code>version</code> 、  <code>versions</code>  查看版本。</p>
<p>其他：</p>
<pre><code class="language-bash">Usage: pyenv &lt;command&gt; [&lt;args&gt;]

Some useful pyenv commands are:
   commands    List all available pyenv commands
   local       Set or show the local application-specific Python version
   global      Set or show the global Python version
   shell       Set or show the shell-specific Python version
   install     Install a Python version using python-build
   uninstall   Uninstall a specific Python version
   rehash      Rehash pyenv shims (run this after installing executables)
   version     Show the current Python version and its origin
   versions    List all Python versions available to pyenv
   which       Display the full path to an executable
   whence      List all Python versions that contain the given executable

See `pyenv help &lt;command&gt;' for information on a specific command.
For full documentation, see: https://github.com/yyuu/pyenv#readme
</code></pre>
<h3 id="3-pyenv-virtualenv-的使用">3. Pyenv virtualenv 的使用</h3>
<h4 id="31-创建">3.1 创建：</h4>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [-u|--upgrade] [VIRTUALENV_OPTIONS] &lt;version&gt; &lt;virtualenv-name&gt;
</code></pre>
<ul>
<li><code>-f</code> 表示强制的（假如虚拟环境已存在，将会覆盖这个虚拟环境）</li>
<li><code>-u</code> 表示upgrade，用于修改已经存在的虚拟环境的Python版本</li>
<li><code>VIRTUALENV_OPTIONS</code> 是传递给virtualenv的选项，可以通过virtualenv的帮助获取选项的含义</li>
<li><code>version</code> 表示Python版本</li>
<li><code>virtualenv-name</code> 指定虚拟环境名</li>
</ul>
<h4 id="32-使用">3.2 使用</h4>
<p>pyenv的virtual不用手动去激活环境；当把本地目录与环境相关联起来后，将自动激活虚拟环境，离开目录时自动退出虚拟环境</p>
<h3 id="注意事项">注意事项：</h3>
<ol>
<li>pyenv 下载慢：<a href="http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/">http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/</a></li>
</ol>
<blockquote>
<p>先去官网下载对应版本的源码：https://www.python.org/downloads/source/<br>
然后创建/.pyenv/cache目录： mkdir /.pyenv/cache (如果已经有该目录直接进入: cd /.pyenv/cache) 然后 <code>pyenv install 3.6.0</code></p>
</blockquote>
<ol start="2">
<li>打包出错，提示需要 python-dev：<a href="https://github.com/pyenv/pyenv/issues/1095">https://github.com/pyenv/pyenv/issues/1095</a></li>
</ol>
<blockquote>
<p>使用以下命令进行安装：</p>
<pre><code class="language-bash">PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install 3.6.0
</code></pre>
</blockquote>
<h3 id="删除虚拟环境">删除虚拟环境</h3>
<pre><code class="language-bash">$ pyenv local system
$ pyenv virtualenv-delete venv
pyenv-virtualenv: remove /home/will/.pyenv/versions/3.4.1/envs/venv? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.1
  3.4.2

$ pyenv uninstall 3.4.1
pyenv: remove /home/will/.pyenv/versions/3.4.1? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.2
</code></pre>
<h2 id="windows-上的虚拟环境管理">Windows 上的虚拟环境管理</h2>
<p>Windows 上同样支持 Virtualenv 进行虚拟环境的管理的。步骤与上述差不多。</p>
<p>Windows 不支持 Pyenv 。</p>
<h3 id="安装-virtualenvwrapper">安装  virtualenvwrapper</h3>
<p>使用 virtualenvwrapper 能够比较容易的使用虚拟环境。</p>
<pre><code class="language-bash">$ pip install virtualenvwrapper-win
</code></pre>
<h3 id="创建-虚拟环境">创建 虚拟环境</h3>
<p>使用 <code>mkvirtualenv</code> 创建虚拟环境。</p>
<pre><code class="language-bash">$ mkvirtualenv -p [python路径] [虚拟环境名称]
</code></pre>
<p>环境默认创建地址为：<code>C:\Users\[username]\envs</code></p>
<h3 id="激活-虚拟环境">激活 虚拟环境</h3>
<p>使用 <code>workon + [虚拟环境名称]</code> 命令进行激活。</p>
<pre><code class="language-bash">$ workon env1
</code></pre>
<p>使用 <code>workon</code> 列出当前的虚拟环境：</p>
<pre><code class="language-bash">$ workon
</code></pre>
<p>退出虚拟环境：</p>
<pre><code class="language-bash">$ deactivate
</code></pre>
<p>删除环境：</p>
<pre><code class="language-bash">$ rmvirtualenv
</code></pre>
<p>复制虚拟环境：</p>
<pre><code class="language-bash">$ cpvirtualenv env1 env3
</code></pre>
<ul>
<li>参考：<a href="https://www.jianshu.com/p/60f361822a7e">https://www.jianshu.com/p/60f361822a7e</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hwang 的低质阅读单 New 1]]></title>
        <id>https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1</id>
        <link href="https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1">
        </link>
        <updated>2019-09-27T01:37:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="hwang-的低质阅读单-new">Hwang 的低质阅读单 New</h1>
<h6 id="这些文章来自-hwang-的-instapaper-从-rss-微博-微信等地方看到觉得自己应该仔细看看的文章收集进-instapaper-归档这些文章后才会出现这里-故而主观又缺乏时效性-很遗憾没有帮到你们">这些文章来自 Hwang 的 Instapaper 。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper ，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。</h6>
<ul>
<li><a href="https://ift.tt/2KP9jma"> 来自 Petra Collins 的“驱魔仪式” | 异视异色｜i-D 中国｜来自VICE的时尚频道</a></li>
<li><a href="https://ift.tt/2Jk8uyy"> 公众号「信息流」改版一周年，有人说没有想的那么糟糕 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2XAAcAp"> 复盘 Evernote：笔记 App 的开山鼻祖，为什么没落了？</a></li>
<li><a href="https://ift.tt/2Xb7HoL"> 苹果的后 iPhone 时代</a></li>
<li><a href="https://ift.tt/2YlJ2PI"> 无大台的时代</a></li>
<li><a href="https://ift.tt/2NxjMVH"> 苹果的跨平台计划：如何用 App 打通 iPad 和 Mac</a></li>
<li><a href="https://ift.tt/30hEzOj"> PyQt + QML 快速开发GUI总结</a></li>
<li><a href="https://ift.tt/2XvPdnd"> 2019中国α世代线上娱乐价值观念洞察 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2YyeXMJ"> 机器学习能成为因果推断的“圣杯”吗？</a></li>
<li><a href="https://ift.tt/2JnoboO"> 如何用 Python 和 BERT 做多标签（multi-label）文本分类？</a></li>
<li><a href="https://ift.tt/30kBQnD"> 怎么选择数据服务器？请记住这五条</a></li>
<li><a href="https://ift.tt/2Sz79YR"> 如何用约会软件进行艺术创作？</a></li>
<li><a href="https://ift.tt/2Y1EuwI"> 亚马逊中国停售纸质书／李楠宣布从魅族离职／京都动画大火已造成 33 人遇难</a></li>
<li><a href="https://ift.tt/2YIO4FW"> 社交围城里的刷新机器</a></li>
<li><a href="https://ift.tt/31I1TWt"> 马斯克的脑机接口来了，USB 连大脑，用 iPhone 操控 | 近未来 ⑫</a></li>
<li><a href="https://ift.tt/2YqQImZ"> 早报 | 明年 iPhone 或全线支持 5G vivo 首款 5G 手机或将亏本卖 《哪吒》破动画票房纪录</a></li>
<li><a href="https://ift.tt/2KIHh9H"> 港真，乱么？ | 可能吧</a></li>
<li><a href="https://ift.tt/301BHsJ"> win10引导错误的修复（内容系转载） - 技术经验 - W3xue</a></li>
<li><a href="https://ift.tt/2HJC7JV"> AI 语音模仿老板声音要求转账，成功骗走了 173 万</a></li>
<li><a href="https://ift.tt/2LcUqIn"> Designing Dark Mode</a></li>
<li><a href="https://ift.tt/2M7vv9w"> 一篇文章让你彻底搞清楚Python中self的含义 - jessonsh - 博客园</a></li>
<li><a href="https://ift.tt/332qNAv"> 出身清华姚班，斯坦福博士毕业，她的毕业论文成了「爆款」</a></li>
<li><a href="https://ift.tt/1PzbZyK"> 高清图标SVG解决方案全总结（上） - 文章 - 伯乐在线</a></li>
<li><a href="https://ift.tt/1PzL3P8"> 高清图标SVG解决方案全总结（下） - 文章 - 伯乐在线</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 用 Python 做计量 （一）—— 初识Python 的计量模块： Statsmodels ]]></title>
        <id>https://hwang.top/post/yong-python-zuo-ji-liang-yi-chu-shi-python-de-ji-liang-mo-kuai-statsmodels</id>
        <link href="https://hwang.top/post/yong-python-zuo-ji-liang-yi-chu-shi-python-de-ji-liang-mo-kuai-statsmodels">
        </link>
        <updated>2019-07-16T10:31:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文发布于 「 数据Seminar 」公众号：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1569839526&amp;ver=1884&amp;signature=hxZrP-JJKRnGggkDaM2PDBJc7DJsrqQWkpBciqqbDAEeqjNhRKIc37VK4bPqNUKSDjtXPGV0yto99QK5ywqoagPK1PhKPC0dynzFMNVchJWrQG5X3VUMMBadcyBnh7hi&amp;new=1</p>
</blockquote>
 <script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
 </script>
 <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<blockquote>
<p>阅读本文前需要掌握的基础知识：<br>
Python 的基础知识、 numpy 的基础知识、 pandas 的基础知识<br>
基本的计量知识<br>
如果你还不会，那么本文也会介绍一些 python 语法的基础内容，方便大家理解。</p>
</blockquote>
<p>随着数据资源的日渐丰富，学者们越来越多的需要接触到大数据的处理，许多学者还是习惯使用 Stata 对数据进行处理，而 Stata 由于其自身的限制，在处理大数据集时要么需要强劲的处理性能（昂贵的硬件成本），要么需要等待较长时间（更加昂贵的时间成本）。Python 和 R 也就日渐进入学者的视野，相对于 R ，Python 的语法更为简单，成为一部分学者的首选。</p>
<p>在数据处理上，numpy 和 pandas 的组合，使得 Python 能够轻松应对千万级别的数据处理。在攻克数据处理这一环后，在数据应用上，除了新潮的机器学习、深度学习的方法，对于现阶段社科学者来说，计量可能才是最现实的。在 Python 中处理的数据如果还需要调回到 Stata 中做计量，那未免太「蹩脚」。今天，数据Seminar 公众号将带大家体验 Python 上的第三方计量库：<a href="https://www.statsmodels.org/stable/index.html">Statsmodels</a> 。</p>
<h2 id="简介">简介</h2>
<p>Statsmodels 是一个Python的第三方模块，他封装了许多计量模型，方便学者直接调用。所谓封装，就相当于 Stata 中一个 <code>reg</code> 命令，代表了最基础的 OLS 回归命令，在Statsmodels 中也有类似 <code>reg</code> 的语句，提供给 OLS 估计。另外 Statsmodels 的开源协议为 <a href="https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE">BSD </a>（基本上对于用户来说属于为所欲为协议，你可以任意使用这款扩张包，具体参见链接地址）。</p>
<blockquote>
<p>statsmodels is a Python module that provides classes and functions for the estimation of many different statistical models, as well as for conducting statistical tests, and statistical data exploration. An extensive list of result statistics are available for each estimator. The results are tested against existing statistical packages to ensure that they are correct. The package is released under the open source Modified BSD (3-clause) license. The online documentation is hosted at statsmodels.org.</p>
</blockquote>
<h2 id="安装">安装：</h2>
<p>如果你使用 Anaconda 安装的 python ，那么：</p>
<pre><code class="language-bash">conda install statsmodels
</code></pre>
<p>如果你使用 pip 管理你的python包，那么：</p>
<pre><code class="language-bash">pip install statsmodels # python2 
</code></pre>
<p>或者：</p>
<pre><code class="language-bash">pip3 install statsmodels #python3
</code></pre>
<h2 id="精读代码初探ols">“精读”代码，初探：OLS</h2>
<p>官方的说明文档：<a href="http://www.statsmodels.org/stable/gettingstarted.html">http://www.statsmodels.org/stable/gettingstarted.html</a></p>
<p>首先先看了一下 OLS 的示例：</p>
<pre><code class="language-python">import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf

dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data
results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit()
print(results.summary())
</code></pre>
<p>运行后：<br>
<img src="DraggedImage.png" alt=""><br>
*(本文采用的编辑器为 Google 的 colab) *</p>
<p>是的，OLS就是这么几行，具体来看内容，其实进行 OLS 回归只需要一行内容。为了方便 Python 基础不那么好的同学，我们驻行“精读”一遍这些代码：</p>
<h3 id="1-导入模块">1. 导入模块</h3>
<pre><code class="language-python">import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf
</code></pre>
<p>首先是需要导入 numpy、statsmodels 的相关模块，numpy 推荐的缩写命名 np，statsmodels 推荐的缩写命名是 sm，这样后面的代码就可以通过 <code>np.[具体的函数\方法]</code> ，<code>sm. [具体的函数\方法]</code> 的方式来更加简洁的调用了。</p>
<h3 id="2-生成测试数据集">2. 生成测试数据集</h3>
<pre><code class="language-python">dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data
</code></pre>
<p>由于并没有现成数据，我们可以通过 statsmodels 中自带的数据集，关于该数据集的具体信息可以参考：<a href="https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Guerry.html">https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Guerry.html</a>，简单来说，这是一个关于犯罪、识字等相关内容的社会科学领域的数据集。<br>
<img src="DraggedImage-1.png" alt=""></p>
<p>这个数据集以DataFrame 格式的储存在了 <code>dat</code> 这个变量中。 DataFrame 格式在 Python 中被广泛的使用，可以说无论是机器学习还是本文介绍的计量相关内容，DataFrame 格式相关的操作都需要熟练掌握。关于 DataFrame 的相关内容，需要更加细致的去学习Python的另一个第三方库 pandas ，本文不再赘述。</p>
<h3 id="3-回归操作">3. 回归操作</h3>
<pre><code class="language-python">results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit()
</code></pre>
<p>首先是<code>smf.ols</code>， <code>smf</code> 就是前面的 <code>statsmodels.formula.api</code> ，OLS 回归的方法在 <code>statsmodels.formula.api</code>下，如果前文没有声明 <code>smf</code> 代表<code>statsmodels.formula.api</code> 的话，你这里可就要写成 <code>statsmodels.formula.api.ols</code> 了，可见合理的缩写声明对于代码的简洁美观非常有帮助。</p>
<p>接下来是括号内的内容<code>('Lottery ~ Literacy + np.log(Pop1831)', data=dat)</code><br>
这其实是<code>OLS</code>模型需要传入的参数，以<code>,</code>为区隔，第一个参数是回归模型，第二个参数是数据。</p>
<p>在这行代码中，回归模型是：<code>'Lottery ~ Literacy + np.log(Pop1831)'</code>，数据是前面加载的<code>dat</code> ，比较方便的是，<code>statsmodels</code>，直接从数据<code>dat</code>中读取了变量名称，并不需要进行额外的赋值操作。我们具体看一下这个模型的写法，对于没有接触过 Python 和 R 的读者来说，这种写法可能相对有些陌生，其实这个模型代表了：</p>
<figure data-type="image" tabindex="1"><img src="DraggedImage-2.png" alt=""></figure>
<p>这种写法参考了R的相关内容，具体是由 Python 中的 Patsy 库实现的。上面这个就是一个计量模型（他当然不是计算 <code>Literacy + np.log(Pop1831)</code>的和，<code>Literacy</code> 和 <code>np.log(Pop1831)</code> 都是矩阵）。这就和 Stata 中 <code>reg y x0 x1 x2</code> 是一样，只是在Python 中模型需要写成<code>y~x0+x1+x2</code>，而 reg 需要写成 <code>smf.ols()</code>。</p>
<p>这个模型中还用到了一个知识点：<code>np.log</code> ，就是说引用了 numpy 中的 log 函数，对变量<code>Pop1831</code> 取对数，就是使用 numpy 进行 log 运算。 如果你直接写 <code>log(Pop1831)</code>，Python是不知道 log 是做什么的，所以要告诉 Python，这个 log 来自于 numpy，这样 Python 就能正常处理 <code>Pop1831</code> 这个数据切片（“切片” 是Python数据处理中常用名词，可以理解为一个 DataFrame 的一列、一行或者几列、几行的数据）了。</p>
<p>最后 <code>data=dat</code> 就是声明对于这个模型，使用的数据时 <code>dat</code>， 这样前面的模型中的 <code>Lottery</code> 、<code>Literacy</code> 和 <code>Pop1831</code>，statsmodels 都能智能的去从 DataFrame 切片（切片操作需要学习Pandas哦），然后应用到模型中。</p>
<p>括号内的内容就是进行回归操作的核心。</p>
<p>括号外还有<code>.fit()</code>，就是告诉 Python，可以进行回归计算了。如果没有这个<code>.fit()</code> ，Python 只会记录这个模型和相关的数据信息，而添加了<code>.fit()</code>，记录时回归后的结果。<br>
<img src="DraggedImage-3.png" alt=""><br>
（上图可以看到储存在计算机中的内容是有差异的）</p>
<p>同样，<code>.fit()</code> 后输出的结果也并非像 Stata 那样那样直接输出的事结果，而是将结果储存，可以进行多种方式的调用。</p>
<p>如果想输入结果，那么就使用 <code>results.summary()</code> ，将其打印出来，正如示例中展示的那样：</p>
<figure data-type="image" tabindex="2"><img src="DraggedImage-4.png" alt=""></figure>
<h2 id="ols-实例">OLS 实例</h2>
<p>这里简单演示一下 OLS 回归，数据处理这一部分内容，在 Python 中主要使用 numpy 和 pandas，这里就不演示，本文直接读取处理完的数据来演示 OLS 的内容：</p>
<p>本文的数据来自CFPS，主要研究的内容是子女认知能力和服务是否创业的关系，处理后的第一个回归模型的内容主要是，母亲的创业状态（<code>self_employed_m_16</code>），教育年限(<code>edu</code>)，是否参加课外补习(<code>extra_classes</code>)，家庭药品支出(<code>expend_medical</code>)、自评健康状况(<code>health</code>)、家庭氛围(<code>quarrel</code>)、与母亲同住时长(<code>livewith_m</code>)、与父亲同住时常(<code>livewith_f</code>)、log的家庭收入(<code>lg_fin</code>)、子女数量(<code>num_chd</code>)、母亲的受教育程度(<code>edu_m</code>)、父亲的受教育程度(<code>edu_f</code>)、户口(<code>hukou</code>)、东中西部虚拟变量（<code>east 、 west</code>），然后被解释变量就是认知能力(<code>y_rznl</code>)。</p>
<pre><code class="language-python">import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf

df = pd.read_csv(&quot;testing.csv&quot;)
OLS_1 = smf.ols(&quot;y_rznl~ self_employed_m_16 + edu + extra_classes + \
    expend_medical + health + quarrel + livewith_m + livewith_f + \
    lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot;, data=df).fit()
print(OLS_1.summary())
</code></pre>
<p>最后输出结果：<br>
<img src="%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-07%20%E4%B8%8B%E5%8D%883.04.11.png" alt=""></p>
<p>而stata输出的结果（置信区间是97.5%）：<br>
<img src="%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-07%20%E4%B8%8B%E5%8D%883.11.40.png" alt=""></p>
<p>可以看到，结果基本一致。</p>
<p>最后，在OLS这里案例中，可以看到 Python 输出结果基本与 Stata 相同，在代码的撰写上， Python 同样非常方便，并且由于 Python 是一门编程语言，在一些循环的撰写上非常有优势，例如我需要多次循环某几个变量，以及对应的被解释变量：</p>
<pre><code class="language-python">import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf

df = pd.read_csv(&quot;testing.csv&quot;)
y_list =[y1, y2, y3, y4] # 被解释变量的列表
x0_list = [x0_1, x0_2, x0_3, x0_4, x0_5] # 某一个解释变量的列表
model_list = []
for y in y_list:
	for x0 in x0_list:
		model = &quot;%s ~ %s + edu + extra_classes + \
    expend_medical + health + quarrel + livewith_m + livewith_f + \
    lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot; % (y, x0)
		OLS = smf.ols(model, data = df).fit()
		print(OLS.summary())
		
</code></pre>
<p>这样就能一次性依次输出，以下内容的回归结果：</p>
<ul>
<li>
<p><code>y1 = x0_1 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y1 = x0_2 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y1 = x0_3 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y1 = x0_5 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y2 = x0_1 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y2 = x0_2 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y2 = x0_5 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y4 = x0_5 + edu + extra_calsses +...</code></p>
</li>
</ul>
<p>所以无论是数据处理还是计量回归中，都能给你极大的便利。</p>
<p>相比Stata，Python  是免费开源的，不需要额外的授权费用，并且如果志在机器学习，那么先从相对熟悉的计量入手或许是一个不错的选择。</p>
]]></content>
    </entry>
</feed>