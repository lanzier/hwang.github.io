<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hwang.top</id>
    <title>Hwang&apos;s Blog</title>
    <updated>2019-10-01T12:21:53.286Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hwang.top"/>
    <link rel="self" href="https://hwang.top/atom.xml"/>
    <subtitle>欢迎来到 Hwang 的小博客</subtitle>
    <logo>https://hwang.top/images/avatar.png</logo>
    <icon>https://hwang.top/favicon.ico</icon>
    <rights>All rights reserved 2019, Hwang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Procreate 练习]]></title>
        <id>https://hwang.top/post/procreate-lian-xi</id>
        <link href="https://hwang.top/post/procreate-lian-xi">
        </link>
        <updated>2019-10-01T12:17:19.000Z</updated>
        <content type="html"><![CDATA[<p>画图，画图。</p>
<p>好久没有动笔了。线条画的一点都不流畅了。</p>
<figure data-type="image" tabindex="1"><img src="https://hwang.top/post-images/1569932434983.PNG" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Update 了一下 figma 的封面]]></title>
        <id>https://hwang.top/post/update-liao-yi-xia-figma-de-feng-mian</id>
        <link href="https://hwang.top/post/update-liao-yi-xia-figma-de-feng-mian">
        </link>
        <updated>2019-09-30T10:00:58.000Z</updated>
        <content type="html"><![CDATA[<p>更新了一下figma的封面：<br>
<img src="https://hwang.top/post-images/1569837778140.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个用了 3 个月 PyQt 的人，在学 Vue.js 基础]]></title>
        <id>https://hwang.top/post/yi-ge-yong-liao-3-ge-yue-pyqt-de-ren-zai-xue-vuejs-ji-chu</id>
        <link href="https://hwang.top/post/yi-ge-yong-liao-3-ge-yue-pyqt-de-ren-zai-xue-vuejs-ji-chu">
        </link>
        <updated>2019-09-30T01:53:10.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>el:</p>
</li>
<li>
<p>data:</p>
</li>
<li>
<p>methods: 用于存放 事件内的方法。 可以理解为 PyQt 中 存放 槽函数 的一个字典。</p>
</li>
<li>
<p>v-cloak 能够解决插值表达式（<code>{{}}</code>） 闪烁 的问题<br>
<code>&lt;v-test='msg'&gt;</code></p>
</li>
<li>
<p>v-test 没有闪烁问题，会覆盖元素中原本的内容，但是，插值表达式只会替换自己的占位符。</p>
</li>
<li>
<p>v-html : 输出闪烁问题</p>
</li>
<li>
<p>v-blind : 绑定 属性 的指令，简写为 <code>:</code> ; v-blind 可以写合法的 js 表达式</p>
</li>
<li>
<p>v-on : 绑定 事件的 （类似 qt 中的 信号与槽的绑定），简写为 <code>@</code></p>
</li>
<li>
<p>v-model: 双向数据绑定，只能用在表单元素（input（radio、text、address、email...） select checkbox textarea）中。</p>
</li>
<li>
<p>v-for: 循环操作</p>
<ul>
<li><code>&lt;p v-for =&quot;item in list&quot;&gt;{{item}}&lt;/p&gt;</code></li>
<li><code>&lt;p v-for =&quot;(item, i) in list&quot;&gt;索引值:{{i}} --- 项目：{{item}}&lt;/p&gt;</code></li>
<li>可以迭代 1.普通数组；2.对象数组；3.对象；4. 数字（起始是1）</li>
<li>在组件中使用 V-for 循环的时候，必须使用 v-for 的同时，制定唯一的字符串/数字类型的 key 值</li>
</ul>
</li>
<li>
<p>v-if</p>
<ul>
<li>每次都会重新删除或者创建元素</li>
<li>有较高的切换性能消耗</li>
</ul>
</li>
<li>
<p>v-show</p>
<ul>
<li>切换元素的 display:none 样式</li>
<li>有较高的初始渲染消耗</li>
</ul>
</li>
</ul>
<h2 id="事件修饰符">事件修饰符</h2>
<ul>
<li>@click.stop 阻止事件的冒泡（从内到外，触发事件）</li>
<li>@click.prevent 阻止默认行为的使用</li>
<li>.capture 以捕获机制触发行为（从外到里，触发事件）</li>
<li>.self 只有自身的时候执行</li>
<li>.once 只触发一次</li>
</ul>
<h2 id="vue-中使用样式">vue 中使用样式</h2>
<ul>
<li>使用数组 <code>:class = ['style1','style2']</code> 会给出style1和style2的合并样式效果</li>
<li><code>:class = ['style1','style2',{'style3':flag}]</code>使用 v-blind ，伪 Class 表达可以使用对象的方式赋值，能够更好的实现样式变化的情况,在data中：<br>
<code>data flag: true }</code><br>
此时能够通过js来控制这个样式的实现与否。</li>
<li>在数组中可以使用 <a href="#">三元表达式</a>(https://baike.baidu.com/item/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/1394210)，python 中 类是 if 的判断语句</li>
<li>可以直接使用对象的方式调用样式。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 的虚拟环境管理  virtualenv & pyenv]]></title>
        <id>https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv</id>
        <link href="https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv">
        </link>
        <updated>2019-09-29T02:11:01.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
<!-- more -->
<p>由于生产需要，用 PyQt5 写了小程序，打包成 <code>.app</code> 过程中发现，打包后竟然有200多M，应该是因为之前使用的python环境中其他包比较多的关系。所以就想到建虚拟环境，来打包。</p>
<p>首先想到的是按项目建虚拟环境，那就用virtualenv 。简单看了一下，实践如下：</p>
<h2 id="virtualenv">virtualenv</h2>
<h3 id="1-安装virtualenv">1. 安装virtualenv</h3>
<p>用pip进行安装。</p>
<pre><code class="language-bash">$ pip install virtualenv 
</code></pre>
<p>先建文件夹，再<code>cd</code>到需要的文件夹中，运行下面的命令：</p>
<pre><code class="language-bash">$ virtualenv --python=&quot;/usr/local/bin/python3.7&quot; --no-site-packages venv
</code></pre>
<p>其中：</p>
<pre><code class="language-bash">--python （-p） # 用于指定版本
--no-site-packges # 表示不需要包
venv # 虚拟环境的名称
</code></pre>
<p>其它选项：</p>
<pre><code class="language-bash">--version
#显示当前版本号。
-h, --help
#显示帮助信息。
-v, --verbose
#显示详细信息。
-q, --quiet
#不显示详细信息。
-p PYTHON_EXE, --python=PYTHON_EXE
#指定所用的python解析器的版本，比如 --python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前系统安装(/usr/bin/python)的python解析器
--clear
#清空非root用户的安装，并重头开始创建隔离环境。
--no-site-packages
#令隔离环境不能访问系统全局的site-packages目录。
--system-site-packages
#令隔离环境可以访问系统全局的site-packages目录。
--unzip-setuptools
#安装时解压Setuptools或Distribute
--relocatable
#重定位某个已存在的隔离环境。使用该选项将修正脚本并令所有.pth文件使用相当路径。
--distribute
#使用Distribute代替Setuptools，也可设置环境变量VIRTUALENV_DISTRIBUTE达到同样效要。
--extra-search-dir=SEARCH_DIRS
#用于查找setuptools/distribute/pip发布包的目录。可以添加任意数量的–extra-search-dir路径。
--never-download
#禁止从网上下载任何数据。此时，如果在本地搜索发布包失败，virtualenv就会报错。
--prompt==PROMPT
#定义隔离环境的命令行前缀。
#环境变量和配置文件
</code></pre>
<h3 id="2-激活虚拟环境">2. 激活虚拟环境</h3>
<pre><code class="language-bash">$ . venv/bin/activate
</code></pre>
<figure data-type="image" tabindex="1"><img src="DraggedImage.png" alt=""></figure>
<p>前面出现<code>(venv)</code> 即可。</p>
<h3 id="一些发现">一些发现</h3>
<ul>
<li>virtualenv 默认似乎是从原环境中下载包的。就是优先直接从原有库中拷贝，不通过下载。这样速度会比较快。</li>
</ul>
<blockquote>
<p>由于本地环境除了 anaconda 的以为， Python 3.7。在打包中出现了一些兼容性问题，具体可见：<br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/1957">https://github.com/pyinstaller/pyinstaller/issues/1957</a><br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/3753">https://github.com/pyinstaller/pyinstaller/issues/3753</a><br>
即便按照issues里说的做了，我也没能解决问题。所以想到下载 3.6版本的 Python 来使用。所以就想到了用 pyenv</p>
</blockquote>
<h2 id="pyenv">pyenv</h2>
<p>基本过程可参考：<a href="https://www.jianshu.com/p/4646dedaaff5">https://www.jianshu.com/p/4646dedaaff5</a></p>
<h3 id="1-安装">1. 安装</h3>
<p>我是通过 Homebrew 下载的（可参考：<a href="https://zhuanlan.zhihu.com/p/27294128">https://zhuanlan.zhihu.com/p/27294128</a>）。</p>
<blockquote>
<p>备份一下 <code>.bash_profile</code></p>
</blockquote>
<pre><code class="language-bash"># Setting PATH for Python 3.7
# The original version is saved in .bash_profile.pysave
PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}&quot;
export PATH

# added by Anaconda3 5.2.0 installer
export PATH=&quot;/Users/wangxuexi/anaconda3/bin:$PATH&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
</code></pre>
<pre><code class="language-bash">$ brew install pyenv
</code></pre>
<p>有可能需要：</p>
<pre><code class="language-bash">$ echo 'export PYENV_ROOT=&quot;$HOME/.pyenv&quot;' &gt;&gt; ~/.bash_profile
$ echo 'export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile
$ echo 'eval &quot;$(pyenv init -)&quot;' &gt;&gt; ~/.bash_profile
</code></pre>
<p>写完后，用以下命令重新登录一下：</p>
<pre><code class="language-bash">$ source ~/.bash_profile
</code></pre>
<p>如果有需要可以安装 pyenv-virtualenv:</p>
<pre><code class="language-bash">$ brew install pyenv-virtualenv
</code></pre>
<p>同样的：</p>
<pre><code class="language-bash">$ echo 'eval &quot;$(pyenv virtualenv-init -)&quot;' &gt;&gt; ~/.bash_profile
# 写入 profile
$ source  ~/.bash_profile
# 重新进登录一遍
</code></pre>
<p>命令参数如下</p>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt; # 建虚拟环境
pyenv virtualenv activate &lt;virtualenv-name&gt; # 激活虚拟环境
pyenv virtualenv-delete &lt;virtualenv-name&gt; # 删除虚拟环境
</code></pre>
<h3 id="2-pyenv-的使用">2. pyenv 的使用</h3>
<p>基本的下载、删除 命令：</p>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v # 用国内源安装很快
</code></pre>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install
</code></pre>
<hr>
<pre><code class="language-bash">$ pyenv install -v 3.6.0  # 安装

$ pyenv uninstall 2.7.10 # 删除
</code></pre>
<p>激活，pyenv 有几种激活方式：</p>
<pre><code class="language-bash">local       Set or show the local application-specific Python version
global      Set or show the global Python version
shell       Set or show the shell-specific Python version
</code></pre>
<p>通过<code>version</code> 、  <code>versions</code>  查看版本。</p>
<p>其他：</p>
<pre><code class="language-bash">Usage: pyenv &lt;command&gt; [&lt;args&gt;]

Some useful pyenv commands are:
   commands    List all available pyenv commands
   local       Set or show the local application-specific Python version
   global      Set or show the global Python version
   shell       Set or show the shell-specific Python version
   install     Install a Python version using python-build
   uninstall   Uninstall a specific Python version
   rehash      Rehash pyenv shims (run this after installing executables)
   version     Show the current Python version and its origin
   versions    List all Python versions available to pyenv
   which       Display the full path to an executable
   whence      List all Python versions that contain the given executable

See `pyenv help &lt;command&gt;' for information on a specific command.
For full documentation, see: https://github.com/yyuu/pyenv#readme
</code></pre>
<h3 id="3-pyenv-virtualenv-的使用">3. Pyenv virtualenv 的使用</h3>
<h4 id="31-创建">3.1 创建：</h4>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [-u|--upgrade] [VIRTUALENV_OPTIONS] &lt;version&gt; &lt;virtualenv-name&gt;
</code></pre>
<ul>
<li><code>-f</code> 表示强制的（假如虚拟环境已存在，将会覆盖这个虚拟环境）</li>
<li><code>-u</code> 表示upgrade，用于修改已经存在的虚拟环境的Python版本</li>
<li><code>VIRTUALENV_OPTIONS</code> 是传递给virtualenv的选项，可以通过virtualenv的帮助获取选项的含义</li>
<li><code>version</code> 表示Python版本</li>
<li><code>virtualenv-name</code> 指定虚拟环境名</li>
</ul>
<h4 id="32-使用">3.2 使用</h4>
<p>pyenv的virtual不用手动去激活环境；当把本地目录与环境相关联起来后，将自动激活虚拟环境，离开目录时自动退出虚拟环境</p>
<h3 id="注意事项">注意事项：</h3>
<ol>
<li>pyenv 下载慢：<a href="http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/">http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/</a></li>
</ol>
<blockquote>
<p>先去官网下载对应版本的源码：https://www.python.org/downloads/source/<br>
然后创建/.pyenv/cache目录： mkdir /.pyenv/cache (如果已经有该目录直接进入: cd /.pyenv/cache) 然后 <code>pyenv install 3.6.0</code></p>
</blockquote>
<ol start="2">
<li>打包出错，提示需要 python-dev：<a href="https://github.com/pyenv/pyenv/issues/1095">https://github.com/pyenv/pyenv/issues/1095</a></li>
</ol>
<blockquote>
<p>使用以下命令进行安装：</p>
<pre><code class="language-bash">PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install 3.6.0
</code></pre>
</blockquote>
<h3 id="删除虚拟环境">删除虚拟环境</h3>
<pre><code class="language-bash">$ pyenv local system
$ pyenv virtualenv-delete venv
pyenv-virtualenv: remove /home/will/.pyenv/versions/3.4.1/envs/venv? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.1
  3.4.2

$ pyenv uninstall 3.4.1
pyenv: remove /home/will/.pyenv/versions/3.4.1? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.2
</code></pre>
<h2 id="windows-上的虚拟环境管理">Windows 上的虚拟环境管理</h2>
<p>Windows 上同样支持 Virtualenv 进行虚拟环境的管理的。步骤与上述差不多。</p>
<p>Windows 不支持 Pyenv 。</p>
<h3 id="安装-virtualenvwrapper">安装  virtualenvwrapper</h3>
<p>使用 virtualenvwrapper 能够比较容易的使用虚拟环境。</p>
<pre><code class="language-bash">$ pip install virtualenvwrapper-win
</code></pre>
<h3 id="创建-虚拟环境">创建 虚拟环境</h3>
<p>使用 <code>mkvirtualenv</code> 创建虚拟环境。</p>
<pre><code class="language-bash">$ mkvirtualenv -p [python路径] [虚拟环境名称]
</code></pre>
<p>环境默认创建地址为：<code>C:\Users\[username]\envs</code></p>
<h3 id="激活-虚拟环境">激活 虚拟环境</h3>
<p>使用 <code>workon + [虚拟环境名称]</code> 命令进行激活。</p>
<pre><code class="language-bash">$ workon env1
</code></pre>
<p>使用 <code>workon</code> 列出当前的虚拟环境：</p>
<pre><code class="language-bash">$ workon
</code></pre>
<p>退出虚拟环境：</p>
<pre><code class="language-bash">$ deactivate
</code></pre>
<p>删除环境：</p>
<pre><code class="language-bash">$ rmvirtualenv
</code></pre>
<p>复制虚拟环境：</p>
<pre><code class="language-bash">$ cpvirtualenv env1 env3
</code></pre>
<ul>
<li>参考：<a href="https://www.jianshu.com/p/60f361822a7e">https://www.jianshu.com/p/60f361822a7e</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hwang 的低质阅读单 New 1]]></title>
        <id>https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1</id>
        <link href="https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1">
        </link>
        <updated>2019-09-27T01:37:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="hwang-的低质阅读单-new">Hwang 的低质阅读单 New</h1>
<h6 id="这些文章来自-hwang-的-instapaper-从-rss-微博-微信等地方看到觉得自己应该仔细看看的文章收集进-instapaper-归档这些文章后才会出现这里-故而主观又缺乏时效性-很遗憾没有帮到你们">这些文章来自 Hwang 的 Instapaper 。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper ，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。</h6>
<ul>
<li><a href="https://ift.tt/2KP9jma"> 来自 Petra Collins 的“驱魔仪式” | 异视异色｜i-D 中国｜来自VICE的时尚频道</a></li>
<li><a href="https://ift.tt/2Jk8uyy"> 公众号「信息流」改版一周年，有人说没有想的那么糟糕 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2XAAcAp"> 复盘 Evernote：笔记 App 的开山鼻祖，为什么没落了？</a></li>
<li><a href="https://ift.tt/2Xb7HoL"> 苹果的后 iPhone 时代</a></li>
<li><a href="https://ift.tt/2YlJ2PI"> 无大台的时代</a></li>
<li><a href="https://ift.tt/2NxjMVH"> 苹果的跨平台计划：如何用 App 打通 iPad 和 Mac</a></li>
<li><a href="https://ift.tt/30hEzOj"> PyQt + QML 快速开发GUI总结</a></li>
<li><a href="https://ift.tt/2XvPdnd"> 2019中国α世代线上娱乐价值观念洞察 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2YyeXMJ"> 机器学习能成为因果推断的“圣杯”吗？</a></li>
<li><a href="https://ift.tt/2JnoboO"> 如何用 Python 和 BERT 做多标签（multi-label）文本分类？</a></li>
<li><a href="https://ift.tt/30kBQnD"> 怎么选择数据服务器？请记住这五条</a></li>
<li><a href="https://ift.tt/2Sz79YR"> 如何用约会软件进行艺术创作？</a></li>
<li><a href="https://ift.tt/2Y1EuwI"> 亚马逊中国停售纸质书／李楠宣布从魅族离职／京都动画大火已造成 33 人遇难</a></li>
<li><a href="https://ift.tt/2YIO4FW"> 社交围城里的刷新机器</a></li>
<li><a href="https://ift.tt/31I1TWt"> 马斯克的脑机接口来了，USB 连大脑，用 iPhone 操控 | 近未来 ⑫</a></li>
<li><a href="https://ift.tt/2YqQImZ"> 早报 | 明年 iPhone 或全线支持 5G vivo 首款 5G 手机或将亏本卖 《哪吒》破动画票房纪录</a></li>
<li><a href="https://ift.tt/2KIHh9H"> 港真，乱么？ | 可能吧</a></li>
<li><a href="https://ift.tt/301BHsJ"> win10引导错误的修复（内容系转载） - 技术经验 - W3xue</a></li>
<li><a href="https://ift.tt/2HJC7JV"> AI 语音模仿老板声音要求转账，成功骗走了 173 万</a></li>
<li><a href="https://ift.tt/2LcUqIn"> Designing Dark Mode</a></li>
<li><a href="https://ift.tt/2M7vv9w"> 一篇文章让你彻底搞清楚Python中self的含义 - jessonsh - 博客园</a></li>
<li><a href="https://ift.tt/332qNAv"> 出身清华姚班，斯坦福博士毕业，她的毕业论文成了「爆款」</a></li>
<li><a href="https://ift.tt/1PzbZyK"> 高清图标SVG解决方案全总结（上） - 文章 - 伯乐在线</a></li>
<li><a href="https://ift.tt/1PzL3P8"> 高清图标SVG解决方案全总结（下） - 文章 - 伯乐在线</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 用 Python 做计量 （一）—— 初识Python 的计量模块： Statsmodels ]]></title>
        <id>https://hwang.top/post/yong-python-zuo-ji-liang-yi-chu-shi-python-de-ji-liang-mo-kuai-statsmodels</id>
        <link href="https://hwang.top/post/yong-python-zuo-ji-liang-yi-chu-shi-python-de-ji-liang-mo-kuai-statsmodels">
        </link>
        <updated>2019-07-16T10:31:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文发布于 「 数据Seminar 」公众号：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1569839526&amp;ver=1884&amp;signature=hxZrP-JJKRnGggkDaM2PDBJc7DJsrqQWkpBciqqbDAEeqjNhRKIc37VK4bPqNUKSDjtXPGV0yto99QK5ywqoagPK1PhKPC0dynzFMNVchJWrQG5X3VUMMBadcyBnh7hi&amp;new=1</p>
</blockquote>
 <script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
 </script>
 <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<blockquote>
<p>阅读本文前需要掌握的基础知识：<br>
Python 的基础知识、 numpy 的基础知识、 pandas 的基础知识<br>
基本的计量知识<br>
如果你还不会，那么本文也会介绍一些 python 语法的基础内容，方便大家理解。</p>
</blockquote>
<p>随着数据资源的日渐丰富，学者们越来越多的需要接触到大数据的处理，许多学者还是习惯使用 Stata 对数据进行处理，而 Stata 由于其自身的限制，在处理大数据集时要么需要强劲的处理性能（昂贵的硬件成本），要么需要等待较长时间（更加昂贵的时间成本）。Python 和 R 也就日渐进入学者的视野，相对于 R ，Python 的语法更为简单，成为一部分学者的首选。</p>
<p>在数据处理上，numpy 和 pandas 的组合，使得 Python 能够轻松应对千万级别的数据处理。在攻克数据处理这一环后，在数据应用上，除了新潮的机器学习、深度学习的方法，对于现阶段社科学者来说，计量可能才是最现实的。在 Python 中处理的数据如果还需要调回到 Stata 中做计量，那未免太「蹩脚」。今天，数据Seminar 公众号将带大家体验 Python 上的第三方计量库：<a href="https://www.statsmodels.org/stable/index.html">Statsmodels</a> 。</p>
<h2 id="简介">简介</h2>
<p>Statsmodels 是一个Python的第三方模块，他封装了许多计量模型，方便学者直接调用。所谓封装，就相当于 Stata 中一个 <code>reg</code> 命令，代表了最基础的 OLS 回归命令，在Statsmodels 中也有类似 <code>reg</code> 的语句，提供给 OLS 估计。另外 Statsmodels 的开源协议为 <a href="https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE">BSD </a>（基本上对于用户来说属于为所欲为协议，你可以任意使用这款扩张包，具体参见链接地址）。</p>
<blockquote>
<p>statsmodels is a Python module that provides classes and functions for the estimation of many different statistical models, as well as for conducting statistical tests, and statistical data exploration. An extensive list of result statistics are available for each estimator. The results are tested against existing statistical packages to ensure that they are correct. The package is released under the open source Modified BSD (3-clause) license. The online documentation is hosted at statsmodels.org.</p>
</blockquote>
<h2 id="安装">安装：</h2>
<p>如果你使用 Anaconda 安装的 python ，那么：</p>
<pre><code class="language-bash">conda install statsmodels
</code></pre>
<p>如果你使用 pip 管理你的python包，那么：</p>
<pre><code class="language-bash">pip install statsmodels # python2 
</code></pre>
<p>或者：</p>
<pre><code class="language-bash">pip3 install statsmodels #python3
</code></pre>
<h2 id="精读代码初探ols">“精读”代码，初探：OLS</h2>
<p>官方的说明文档：<a href="http://www.statsmodels.org/stable/gettingstarted.html">http://www.statsmodels.org/stable/gettingstarted.html</a></p>
<p>首先先看了一下 OLS 的示例：</p>
<pre><code class="language-python">import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf

dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data
results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit()
print(results.summary())
</code></pre>
<p>运行后：<br>
<img src="DraggedImage.png" alt=""><br>
*(本文采用的编辑器为 Google 的 colab) *</p>
<p>是的，OLS就是这么几行，具体来看内容，其实进行 OLS 回归只需要一行内容。为了方便 Python 基础不那么好的同学，我们驻行“精读”一遍这些代码：</p>
<h3 id="1-导入模块">1. 导入模块</h3>
<pre><code class="language-python">import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf
</code></pre>
<p>首先是需要导入 numpy、statsmodels 的相关模块，numpy 推荐的缩写命名 np，statsmodels 推荐的缩写命名是 sm，这样后面的代码就可以通过 <code>np.[具体的函数\方法]</code> ，<code>sm. [具体的函数\方法]</code> 的方式来更加简洁的调用了。</p>
<h3 id="2-生成测试数据集">2. 生成测试数据集</h3>
<pre><code class="language-python">dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data
</code></pre>
<p>由于并没有现成数据，我们可以通过 statsmodels 中自带的数据集，关于该数据集的具体信息可以参考：<a href="https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Guerry.html">https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Guerry.html</a>，简单来说，这是一个关于犯罪、识字等相关内容的社会科学领域的数据集。<br>
<img src="DraggedImage-1.png" alt=""></p>
<p>这个数据集以DataFrame 格式的储存在了 <code>dat</code> 这个变量中。 DataFrame 格式在 Python 中被广泛的使用，可以说无论是机器学习还是本文介绍的计量相关内容，DataFrame 格式相关的操作都需要熟练掌握。关于 DataFrame 的相关内容，需要更加细致的去学习Python的另一个第三方库 pandas ，本文不再赘述。</p>
<h3 id="3-回归操作">3. 回归操作</h3>
<pre><code class="language-python">results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit()
</code></pre>
<p>首先是<code>smf.ols</code>， <code>smf</code> 就是前面的 <code>statsmodels.formula.api</code> ，OLS 回归的方法在 <code>statsmodels.formula.api</code>下，如果前文没有声明 <code>smf</code> 代表<code>statsmodels.formula.api</code> 的话，你这里可就要写成 <code>statsmodels.formula.api.ols</code> 了，可见合理的缩写声明对于代码的简洁美观非常有帮助。</p>
<p>接下来是括号内的内容<code>('Lottery ~ Literacy + np.log(Pop1831)', data=dat)</code><br>
这其实是<code>OLS</code>模型需要传入的参数，以<code>,</code>为区隔，第一个参数是回归模型，第二个参数是数据。</p>
<p>在这行代码中，回归模型是：<code>'Lottery ~ Literacy + np.log(Pop1831)'</code>，数据是前面加载的<code>dat</code> ，比较方便的是，<code>statsmodels</code>，直接从数据<code>dat</code>中读取了变量名称，并不需要进行额外的赋值操作。我们具体看一下这个模型的写法，对于没有接触过 Python 和 R 的读者来说，这种写法可能相对有些陌生，其实这个模型代表了：</p>
<figure data-type="image" tabindex="1"><img src="DraggedImage-2.png" alt=""></figure>
<p>这种写法参考了R的相关内容，具体是由 Python 中的 Patsy 库实现的。上面这个就是一个计量模型（他当然不是计算 <code>Literacy + np.log(Pop1831)</code>的和，<code>Literacy</code> 和 <code>np.log(Pop1831)</code> 都是矩阵）。这就和 Stata 中 <code>reg y x0 x1 x2</code> 是一样，只是在Python 中模型需要写成<code>y~x0+x1+x2</code>，而 reg 需要写成 <code>smf.ols()</code>。</p>
<p>这个模型中还用到了一个知识点：<code>np.log</code> ，就是说引用了 numpy 中的 log 函数，对变量<code>Pop1831</code> 取对数，就是使用 numpy 进行 log 运算。 如果你直接写 <code>log(Pop1831)</code>，Python是不知道 log 是做什么的，所以要告诉 Python，这个 log 来自于 numpy，这样 Python 就能正常处理 <code>Pop1831</code> 这个数据切片（“切片” 是Python数据处理中常用名词，可以理解为一个 DataFrame 的一列、一行或者几列、几行的数据）了。</p>
<p>最后 <code>data=dat</code> 就是声明对于这个模型，使用的数据时 <code>dat</code>， 这样前面的模型中的 <code>Lottery</code> 、<code>Literacy</code> 和 <code>Pop1831</code>，statsmodels 都能智能的去从 DataFrame 切片（切片操作需要学习Pandas哦），然后应用到模型中。</p>
<p>括号内的内容就是进行回归操作的核心。</p>
<p>括号外还有<code>.fit()</code>，就是告诉 Python，可以进行回归计算了。如果没有这个<code>.fit()</code> ，Python 只会记录这个模型和相关的数据信息，而添加了<code>.fit()</code>，记录时回归后的结果。<br>
<img src="DraggedImage-3.png" alt=""><br>
（上图可以看到储存在计算机中的内容是有差异的）</p>
<p>同样，<code>.fit()</code> 后输出的结果也并非像 Stata 那样那样直接输出的事结果，而是将结果储存，可以进行多种方式的调用。</p>
<p>如果想输入结果，那么就使用 <code>results.summary()</code> ，将其打印出来，正如示例中展示的那样：</p>
<figure data-type="image" tabindex="2"><img src="DraggedImage-4.png" alt=""></figure>
<h2 id="ols-实例">OLS 实例</h2>
<p>这里简单演示一下 OLS 回归，数据处理这一部分内容，在 Python 中主要使用 numpy 和 pandas，这里就不演示，本文直接读取处理完的数据来演示 OLS 的内容：</p>
<p>本文的数据来自CFPS，主要研究的内容是子女认知能力和服务是否创业的关系，处理后的第一个回归模型的内容主要是，母亲的创业状态（<code>self_employed_m_16</code>），教育年限(<code>edu</code>)，是否参加课外补习(<code>extra_classes</code>)，家庭药品支出(<code>expend_medical</code>)、自评健康状况(<code>health</code>)、家庭氛围(<code>quarrel</code>)、与母亲同住时长(<code>livewith_m</code>)、与父亲同住时常(<code>livewith_f</code>)、log的家庭收入(<code>lg_fin</code>)、子女数量(<code>num_chd</code>)、母亲的受教育程度(<code>edu_m</code>)、父亲的受教育程度(<code>edu_f</code>)、户口(<code>hukou</code>)、东中西部虚拟变量（<code>east 、 west</code>），然后被解释变量就是认知能力(<code>y_rznl</code>)。</p>
<pre><code class="language-python">import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf

df = pd.read_csv(&quot;testing.csv&quot;)
OLS_1 = smf.ols(&quot;y_rznl~ self_employed_m_16 + edu + extra_classes + \
    expend_medical + health + quarrel + livewith_m + livewith_f + \
    lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot;, data=df).fit()
print(OLS_1.summary())
</code></pre>
<p>最后输出结果：<br>
<img src="%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-07%20%E4%B8%8B%E5%8D%883.04.11.png" alt=""></p>
<p>而stata输出的结果（置信区间是97.5%）：<br>
<img src="%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-07%20%E4%B8%8B%E5%8D%883.11.40.png" alt=""></p>
<p>可以看到，结果基本一致。</p>
<p>最后，在OLS这里案例中，可以看到 Python 输出结果基本与 Stata 相同，在代码的撰写上， Python 同样非常方便，并且由于 Python 是一门编程语言，在一些循环的撰写上非常有优势，例如我需要多次循环某几个变量，以及对应的被解释变量：</p>
<pre><code class="language-python">import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf

df = pd.read_csv(&quot;testing.csv&quot;)
y_list =[y1, y2, y3, y4] # 被解释变量的列表
x0_list = [x0_1, x0_2, x0_3, x0_4, x0_5] # 某一个解释变量的列表
model_list = []
for y in y_list:
	for x0 in x0_list:
		model = &quot;%s ~ %s + edu + extra_classes + \
    expend_medical + health + quarrel + livewith_m + livewith_f + \
    lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot; % (y, x0)
		OLS = smf.ols(model, data = df).fit()
		print(OLS.summary())
		
</code></pre>
<p>这样就能一次性依次输出，以下内容的回归结果：</p>
<ul>
<li>
<p><code>y1 = x0_1 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y1 = x0_2 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y1 = x0_3 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y1 = x0_5 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y2 = x0_1 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y2 = x0_2 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y2 = x0_5 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y4 = x0_5 + edu + extra_calsses +...</code></p>
</li>
</ul>
<p>所以无论是数据处理还是计量回归中，都能给你极大的便利。</p>
<p>相比Stata，Python  是免费开源的，不需要额外的授权费用，并且如果志在机器学习，那么先从相对熟悉的计量入手或许是一个不错的选择。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 在 Windows 的共享文件夹中创建文件图标]]></title>
        <id>https://hwang.top/post/ru-he-zai-windows-de-gong-xiang-wen-jian-jia-zhong-chuang-jian-wen-jian-tu-biao</id>
        <link href="https://hwang.top/post/ru-he-zai-windows-de-gong-xiang-wen-jian-jia-zhong-chuang-jian-wen-jian-tu-biao">
        </link>
        <updated>2019-07-11T02:06:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Windows 系统中可以通过右键文件夹属性的方式创建文件夹图标。然而，在共享文件夹中并不能直接创建。</p>
<p>🎬 <a href="https://www.youtube.com/watch?v=oFHkWfXbxYo">Apply an Icon to a Folder on a NetWork Drive </a><br>
视频中演示了一种相对曲折的方法在共享文件夹中，创建带有图标的文件夹。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Windows 系统中可以通过右键文件夹属性的方式创建文件夹图标。然而，在共享文件夹中并不能直接创建。</p>
<p>🎬 <a href="https://www.youtube.com/watch?v=oFHkWfXbxYo">Apply an Icon to a Folder on a NetWork Drive </a><br>
视频中演示了一种相对曲折的方法在共享文件夹中，创建带有图标的文件夹。</p>
<!-- more -->
<p>究其原理，其实就是共享文件夹中系统没有创建 <code>desktop.ini</code> 文件的设置（可能是安全原因的考虑？）。</p>
<p>参考：<a href="https://superuser.com/questions/685732/set-custom-folder-icon-for-a-network-folder-in-windows-file-explorer">Set custom folder icon for a network folder in Windows file explorer</a></p>
<h2 id="做法">做法：</h2>
<p>这种方法的前提就是你有共享文件夹的写入权限，在windows 10 上已经不能正常使用了</p>
<ol>
<li>在本地创建一个有 icon 的文件夹；</li>
<li>移动该文件夹到 共享文件夹中；</li>
<li>在弹出窗口中 允许 <code>desktop.ini</code> 的相关选项；</li>
<li>刷新一下共享文件夹</li>
<li>OK</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL 的一些内容]]></title>
        <id>https://hwang.top/post/sql-de-yi-xie-nei-rong</id>
        <link href="https://hwang.top/post/sql-de-yi-xie-nei-rong">
        </link>
        <updated>2019-05-07T02:11:54.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mysql-累计求和">MySQL 累计求和</h2>
<pre><code class="language-sql">SET @csum := 0;
SELECT ADCODE, NAME, (@csum := @csum + ADCODE) AS CUMSUM
FROM all_location_data LIMIT 20;
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mysql-累计求和">MySQL 累计求和</h2>
<pre><code class="language-sql">SET @csum := 0;
SELECT ADCODE, NAME, (@csum := @csum + ADCODE) AS CUMSUM
FROM all_location_data LIMIT 20;
</code></pre>
<!-- more -->
<p>首先 是设置一个变量 @csum 为0<br>
接着 选择要显示的字段，设置一个公式<code>(@csum := @csum + ADCODE)</code> 这里 ADCODE 就是想要 累积加总的变量，将其记为 CUMSUM。<br>
最后加上 <code>FROM all_location_data LIMIT 20;</code> 限制了现实20条。</p>
<hr>
<h2 id="mysql-统计某个-字段-不重复的行数">MySQL 统计某个 字段 不重复的行数</h2>
<pre><code class="language-sql">SELECT count(DISTINCT name) AS nu FROM company;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python Pexpect 库的简单入门]]></title>
        <id>https://hwang.top/post/python-pexpect-ku-de-jian-dan-ru-men</id>
        <link href="https://hwang.top/post/python-pexpect-ku-de-jian-dan-ru-men">
        </link>
        <updated>2019-03-26T02:04:35.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>2019.03.26<br>
Hwang<br>
参考：<br>
1.<a href="https://www.jianshu.com/p/cfd163200d12">https://www.jianshu.com/p/cfd163200d12</a><br>
2.<a href="https://blog.csdn.net/Cloud_Strife0/article/details/82217494">https://blog.csdn.net/Cloud_Strife0/article/details/82217494</a></p>
</blockquote>
<h2 id="1-pexpect-是什么">1. Pexpect  是什么</h2>
<blockquote>
<p>pexpect 是 Python 语言的类 Expect 实现。<br>
而 expect 主要用于模拟人机对话，简单地说就是可以使用正则匹配捕捉系统的提问（ssh登录需要输入密码等），并且根据捕捉到的提问进行不同的操作。<br>
例子：</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>2019.03.26<br>
Hwang<br>
参考：<br>
1.<a href="https://www.jianshu.com/p/cfd163200d12">https://www.jianshu.com/p/cfd163200d12</a><br>
2.<a href="https://blog.csdn.net/Cloud_Strife0/article/details/82217494">https://blog.csdn.net/Cloud_Strife0/article/details/82217494</a></p>
</blockquote>
<h2 id="1-pexpect-是什么">1. Pexpect  是什么</h2>
<blockquote>
<p>pexpect 是 Python 语言的类 Expect 实现。<br>
而 expect 主要用于模拟人机对话，简单地说就是可以使用正则匹配捕捉系统的提问（ssh登录需要输入密码等），并且根据捕捉到的提问进行不同的操作。<br>
例子：</p>
</blockquote>
<!-- more -->
<pre><code class="language-python">import pexpect
import sys

# 用spawn来执行一个指令
child = pexpect.spawn('ftp ftp.openbsd.org')
# 用expect等待指定的关键字’name‘
child.expect('(?i)name .*: ')
# 若上一步匹配到了，则向计算机输入name
child.sendline('anonymous')
# 用expect等待指定的关键字’password‘
child.expect('(?i)password')
# 若上一步匹配到了，则向计算机输入password
child.sendline('pexpect@sourceforge.net')
# 用expect等待指定的关键字’ftp&gt;‘
child.expect('ftp&gt; ')
# 若上一步成功匹配，则意味着进入了ftp连接，现在做一些操作
child.sendline('cd /pub/OpenBSD/3.7/packages/i386')
child.expect('ftp&gt; ')
child.sendline('bin')
child.expect('ftp&gt; ')
child.sendline('prompt')
child.expect('ftp&gt; ')
child.sendline('pwd')
child.expect('ftp&gt; ')
print(&quot;Escape character is '^]'.\n&quot;)
sys.stdout.write (child.after)
sys.stdout.flush()
child.interact() # Escape character defaults to ^]
# At this point this script blocks until the user presses the escape character
# or until the child exits. The human user and the child should be talking
# to each other now.

# At this point the script is running again.
print('Left interactve mode.')

# The rest is not strictly necessary. This just demonstrates a few functions.
# This makes sure the child is dead; although it would be killed when Python exits.
if child.isalive():
    child.sendline('bye') # Try to ask ftp child to exit.
    child.close()
# Print the final state of the child. Normally isalive() should be FALSE.
if child.isalive():
    print('Child did not exit gracefully.')
else:
    print('Child exited gracefully.')
</code></pre>
<h2 id="2-用法">2. 用法</h2>
<h3 id="21-spawn">2.1 spawn()</h3>
<pre><code class="language-python">demo_ssh = pexpect.spawn('ssh xxx@&lt;ip&gt;')
</code></pre>
<p>如上例中，spawn() 返还的是句柄（handle）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，一般用法：<code>spawn(&lt;cmd 命令&gt;)</code> ， 后续的操作都会基于这里定义的变量 <code>demo_ssh</code>	。</p>
<blockquote>
<p>注意: spawn() ，或者说 pexpect 并不会转译任何特殊字符 比如 <code>| *</code>字符在Linux的shell中有特殊含义，但是在 pexpect 中不会转译它们，如果在 linux 系统中想使用这些符号的正确含义就必须加上 shell 来运行，这是很容易犯的一个错误。<br>
正确的方式：</p>
<pre><code class="language-python">process = pexpect.spawn('/bin/bash -c &quot;ls -l | grep LOG &gt; log_list.txt&quot;')
process.expect(pexpect.EOF)
</code></pre>
</blockquote>
<h4 id="参数">参数</h4>
<ul>
<li>timeout</li>
</ul>
<p>设置超时时间（30默认）</p>
<ul>
<li>
<p>maxread 缓存设置<br>
默认 2000 字符</p>
</li>
<li>
<p>searchwindowsize - 模式匹配阀值</p>
</li>
<li>
<p>logfile - 运行输出控制</p>
</li>
<li>
<p>logfile_read - 获取标准输出的内容</p>
</li>
<li>
<p>logfile_send - 获取发送的内容</p>
</li>
<li>
<p>cwd - 指定命令执行的目录</p>
</li>
<li>
<p>env - 指定环境变量</p>
</li>
<li>
<p>ignore_sighup - 是否过滤 SIGHUP 信号</p>
</li>
<li>
<p>delaybeforesend - 字符发送延时</p>
</li>
</ul>
<h3 id="22-expect">2.2 expect()</h3>
<p>关键字匹配，当spawn 启动一个程序并且返回程序控制句柄后，可以用expect() 来指定匹配内容。 使用 expect() 使用正则表达式来匹配。</p>
<h3 id="221-expect_exact">2.2.1 expect_exact()</h3>
<p>精确匹配，它的使用和 expect() 是一样的，唯一不同的就是它的匹配列表中不再使用正则表达式。<br>
从性能上来说 expect_exact() 要更好一些，因为即使你没有使用正则表达式而只是简单的用了几个字符 expect() 也会先将它们转换成正则表达式模式然后再搜索，但 expect_exact() 不会，而且也不会把一些特殊符号转换掉。</p>
<h3 id="222expect_list">2.2.2expect_list()</h3>
<p>预转换匹配，使用方式和 expect() 一样，唯一不同的就是它里面接受的正则表达式列表只会转换一次。</p>
<h3 id="223-expect_loop">2.2.3 expect_loop()</h3>
<p>用于从标准输入中获取内容，loop这个词代表它会进入一个循环，必须要从标准输入中获取到关键字才会往下继续执行。</p>
<h3 id="23-send">2.3 send()</h3>
<p>发送关键字。用来向程序发送指定的字符串。</p>
<h3 id="231-sendline">2.3.1 sendline()</h3>
<p>发送带回车符的字符串。</p>
<h3 id="232-sendcontrol">2.3.2 sendcontrol()</h3>
<p>发送控制信号</p>
<h3 id="233-sendeof">2.3.3 sendeof()</h3>
<p>发送 EOF 信号</p>
<h3 id="234-sendintr">2.3.4 sendintr()</h3>
<p>发送终止信号</p>
<h3 id="24-interact-将控制权交给用户">2.4 interact() - 将控制权交给用户</h3>
<center><span style="font-size:40px">🧡</span></center>
<p>interact() 表示将控制权限交给用户（或者说标准输入）。一般情况下 pexpect 会接管所有的输入和输出，但有的时候还是希望用户介入，或者仅仅是为了完成一部分工作的时候， interact() 就很有用了。</p>
<h3 id="25-close">2.5 close()</h3>
<p>停止应用程序<br>
如果想中途关闭子程序，那么可以用 close 来完成，调用这个方法后会返回这个程序的返回值。<br>
如果设置 force=True 会强行关闭这个程序，大概的过程就是先发送 SIGHUP 和 SIGINT 信号，如果都无效的话就发 SIGKILL 信号，反正不管怎么样都会保证这个程序被关闭掉。<br>
多次调用这个方法是允许的，但是不保证每次都能返回正确的返回值。尽量不要这么做，如果想保证程序被关闭的话只要设置force的值就可以了。</p>
<h3 id="26-terminate">2.6 terminate()</h3>
<p>可以看作是上面 close() 的别名</p>
<h3 id="27-kill">2.7 Kill()</h3>
<p>发送 SIGKILL 信号，向子程序发送 SIGKILL 的信号。</p>
<h3 id="28-flush">2.8 flush()</h3>
<p>什么都不干，只是为了与文件方法兼容而已。</p>
<h3 id="29-isalive">2.9 isalive()</h3>
<p>检查子程序运行状态。<br>
检查被调用的子程序是否正在运行，这个方法是运行在非阻断模式下面的。<br>
如果获得的返回是 True 表示子程序正在运行；返回 False 则表示程序运行终止。</p>
<h3 id="210-isatty">2.10 isatty()</h3>
<p>检查是否运行在 TTY （即控制台）设备上</p>
<h3 id="211-next">2.11 next()</h3>
<p>返回下一行内容，和操作文件一样，这个方法也是返回缓存中下一行的内容。</p>
<h3 id="212-read">2.12 read()</h3>
<p>返回剩下的所有内容。</p>
<p>获取子程序返回的所有内容，一般情况下我们可以用 expect 来期待某些内容，然后通过 process.before 这样的方式来获取，但这种方式有一个前提：那就是必须先 expect 某些字符，然后才能用 process.before 来获取缓存中剩下的内容。</p>
<p>read() 的使用很不同，它期待一个 EOF 信号，然后将直到这个信号之前的所有输出全部返回，就像读一个文件那样。<br>
一般情况下，交互式程序只有关闭的时候才会返回 EOF ，比如用 by 命令关闭 ftp 服务器，或者用 exit 命令关闭一个 ssh 连接。<br>
这个方法使用范围比较狭窄，因为完全可以用 expect.EOF 方式来代替。当然如果是本机命令，每执行完一次之后都会返回 EOF ，这种情况下倒是很有用：</p>
<pre><code>process = pexpect.spawn('ls -l')output = process.read()print output
</code></pre>
<p>看起来这么做有点无聊？但我想一定有什么理由支持这个方法。<br>
可以用指定 read(size=-1) 的方式来设置返回的字符数，如果没有设置或者设置为负数则返回所有内容，正数则返回指定数量的内容，返回的内容是字符串形式。</p>
<h3 id="213-readlines-返回列表模式的所有输出">2.13 readlines() - 返回列表模式的所有输出</h3>
<p>返回一个列表，列表中的每个元素都是一行（包括\r\n字符）。</p>
<h3 id="214-setecho-子程序响应模式">2.14 setecho() - 子程序响应模式</h3>
<p>设置子程序运行时的响应方式，一般情况下向子程序发送字符的时候，这些字符都会在标准输出上显示出来，这样你可以看到你发送出去的内容，但是有的时候，我们不需要显示，那么就可以用这个方法来设置了。<br>
注意，必须在发送字符之前设置，设置之后在之后的代码中都一直有效。比如：</p>
<pre><code>process = pexpect.spawn('cat')# 默认情况下，下面的1234这个字符串会显示2次，一次是pexpect返回的，一次是cat命令返回的process.sendline(&quot;1234&quot;)# 现在我们关闭pexpect()的echo功能process.setecho(False)# 下面的字符只会显示一次了，这是由cat返回的process.sendline(&quot;abcd&quot;)# 现在重新开启echo功能，就可以再次看到我们发送的字符了process.setecho(True)
</code></pre>
<h3 id="215-setwinsize-控制台窗口大小">2.15 setwinsize() - 控制台窗口大小</h3>
<p>如果子程序是一个控制台（TTY），比如 SSH 连接、 Telnet 连接这种通过网络登陆到系统并发送命令的都算控制台，那么可以用这个方法来设置这个控制太的大小（或者说长宽）。<br>
它的调用方式是 <code>process.setwinsize(r, c)</code><br>
默认值是 <code>setwinsize(24, 80)</code>，其中 24 是高度，单位是行； 80 是宽度，单位是字符。<br>
为什么要用它？想像下面的场景：<br>
有的时候你通过pexpect登陆到某个ssh控制台之后，又用 interact() 来将控制权交给用户，然后用户到控制台里面写自己的命令，如果命令比较长，就会发现当命令到屏幕边缘之后不会自动换行，而是又返回到这一行的最前面重新覆盖前面的字符；这不会影响命令的实际效果，但是很恼人。<br>
这种情况用 setwinsize() 就可以解决，找到自己终端支持的长度，重新设置一下，比如 setwinsize(25, 96 )，如果设置的正确的话就可以解决了。</p>
<h3 id="216-wait-执行等待">2.16 wait() - 执行等待</h3>
<p>直到被调用的子程序执行完毕之前，程序都停止（或者说等待）执行。它不会从被调用的子程序中读取任何内容。</p>
<h3 id="217-waitnoecho">2.17 waitnoecho()</h3>
<p>它使用的地方比较特殊，唯一匹配的地方就是：当子程序的 echo 功能被设置为 Fals 时。<br>
看起来很奇怪？其实这个功能是基于一个很让人难以置信但的确是真实的情况：<br>
在命令行模式下，很多要求输入密码的地方，比如 FTP/SSH 等，密码实际上都会在你输入之后又重新返回并打印出来的，但是为什么我们看不到我们自己输入的密码呢？这就是因为密码在要打印出来之前被程序将 echo 功能设置为 False 了。<br>
现在知道为什么有这么一个方法了吧？比如要进行一个 ssh 连接时，如何检查是否要输入密码？用关键字 password 是一个方法，但还有一个方法就是这样：</p>
<pre><code class="language-python"># 启动ssh连接
process = pexpect.spawn(&quot;ssh user@example.com&quot;)
# 等待echo被设置为False，这就意味着本地不会有回显
process.waitnoecho()
process.sendline('mypassword')
</code></pre>
<p>可以设置超时时间，默认是：<code>waitnoecho(timeout=-1)</code>，表示和系统设置的超时时间相同，也可以设置为 None 表示永远等待，直到回显被设置为 False ，当然还可以设置其他的数字来表示超时时间。</p>
<h3 id="218-write-发送字符串">2.18  write() - 发送字符串</h3>
<p>类似于send()命令，只不过不会返回发送的字符数。</p>
<h3 id="219-writelines-发送包含字符串的列表">2.19 writelines() - 发送包含字符串的列表</h3>
<p>类似于 write() 命令，只不过接受的是一个字符串列表， writelines() 会向子程序一条一条的发送列表中的元素，但是不会自动在每个元素的最后加上回车换行符。<br>
与 write() 相似的是，这个方法也不会返回发送的字符数量。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。（参见封装）。通俗的说就是我们调用句柄就是调用句柄所提供的服务，即句柄已经把它能做的操作都设定好了，我们只能在句柄所提供的操作范围内进行操作，但是普通指针的操作却多种多样，不受限制。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[去思考，去理解，去猜测，《xxx快速入门》指北 ]]></title>
        <id>https://hwang.top/post/qu-si-kao-qu-li-jie-qu-cai-ce-lesslessxxx-kuai-su-ru-men-greatergreater-zhi-bei</id>
        <link href="https://hwang.top/post/qu-si-kao-qu-li-jie-qu-cai-ce-lesslessxxx-kuai-su-ru-men-greatergreater-zhi-bei">
        </link>
        <updated>2019-03-15T10:30:15.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文发布于少数派：https://beta.sspai.com/post/52935</p>
</blockquote>
<p>2018年，于我而言是人生中最非同一般的一年，我从大三升到了大四，更为重要的是我从「学习」的状态转变为了「工作」状态。说出来我自己也不信，2018年初我还是一个立志成为「经济学家」的学子，2018年底我却深度参与到了一项创业活动中。我的文档库中从文献笔记，变为了代码与日志。在这之中，需要去适应许多的改变，少数派是一个讲求「效率」的网站，各种「酸甜苦辣」自然按下不表，作为2018年的年度总结，下文我会尝试梳理这一年中对我产生影响的学习「陌生概念」的思路，希望能够为大家提供一些参考。</p>
<p>事先需要声明的是，效率思维看起来太过「空洞」，而本人对于各种思考范式的认识也并非「专家」，所以撰文、用词、举例之中有偏颇之处也请包涵。本文叙述的也只是我本人的经验，并不一定适用于他人。</p>
<p>这一年，我做的最多的事就是在不断做新的事。我是经济学的在读本科生，6个月前，我连 vim 编辑器需要先按 「i」 进入编辑模式才能修改文本都不知道；而现在，我已经能够实现基本的诸如 apache 、nginx 的各种配置了。2018年，我第一次学习了使用命令行的方式操作系统，第一次知道原来有配置文件这种东西，第一次知道了虚拟化这种东西，第一次写了网页，第一次编写了程序，<em>我甚至知道了 Windows 系统在执行打印操作是把文件暂存在C:\\WINDOWS\Spool\printers 系统文件夹内，然后慢慢发给打印机进行处理的</em>。而且这之中大多数东西，都是下半年才发生的，因为2018年上半年，我每周还有三天是上课的。同事都认为这是因为我「学习能力强」，但是你凭什么就「学习能力强」了？ 我并不觉得，这之中有任何一件事情对我来说是简单的、容易的。</p>
<p><em>2018年第一次进机房部署服务</em></p>
<p>这些事都是有外力推动你去做的。大多数人，需要进入一个新的领域时，会选择先从诸如《xxx快速入门》、《xxx快速上手》这样的内容出发，去学习这个领域的东西。但是，由于我往往是有这个需求时，这个项目就要求你需要快速上手，解决问题。基本上不可能让你一步一个脚印的去学习然后等你学会了再去解决这个需求。也就是说，一个外生的变量迫使你不得不快速的进入状态。这个外生变量，直接拒绝「不积跬步，无以至千里」这样的想法。我的解决方法是第一步，先去思考「需要的是什么」；第二步，再去理解你所需要的「对象」大体上是长得什么样的，最后描绘出符合自己需求学习清单，按照理解的步骤学习，按照重要程度进行精力的分配。这种像蜻蜓点水的学习方法，帮助我较为快速的上手解决问题。下面我总结了一些自己的经验：</p>
<h2 id="一需要的是什么">（一）需要的是什么</h2>
<p>首先，是明确「需要的是什么」。一开始思考的「需要的是什么」，应当是从需求出发的思考，就是做这件事目的是什么。这个话术的前提是，你对这个需求所需要的背景知识几乎「一无所知」。所以需要优先构建的是这个需求的背景知识。也就是说要先与这个陌生的概念建立联系，并且能够基本定位到这些背景知识在自己已有的知识体系的未知。所以，我一般会进行两步：</p>
<p>**1.利用搜索引擎，建立与陌生概念的联系。 **许多时候是相对明确的。例如一个经济学学生，被老师要求学习 Stata ，那么他需要的其实就是：<strong>学会使用这个软件进行计量分析</strong>。这个就是「目标」，那么假设我是一个对于 Stata 一片空白人。我需要的首先就是 <strong>「Stata 是什么？」</strong>，这个问题很容易就能在搜索引擎中找到。不过，当我在进行空白的概念理解时，我会多搜索几个关键词，例如「stata 经济学」（空格在一般搜索引擎中都是「和」的意思）。**这是非常重要的一步，因为当你把一个未知概念（stata）与你所知概念（经济学）结合时，出现的内容，大概率是你知晓大半但是不全懂的东西。**也许这个技巧，你觉得这并没有什么了不起的，但是这个习惯就能一下将陌生概念变得更加清晰，消除令人恐惧的陌生感，下图展示了这一步的重要性。</p>
<p><img src="DraggedImage.png" alt=""><br>
<em>经济学学生在「stata 经济学」的搜索结果中能够很直接获取他正真需要的信息。</em></p>
<p>简单几轮下来，当你很容易就能把「 Stata 」与「计量经济学」相联系。现实中遇到问题可能并不那么快速，但是这样的方法能够让你更加快速的理解「陌生概念」对于「你所需要的是什么」的相对位置。即这个「陌生概念」，对于你已有的知识体系，所处的位置。例如使用 Stata 是更加「靠近」计量经济学，而不是数理经济学或者其他什么的。这样在头脑地图中有一个比较明确的标的，上手起真正的「未知概念」会有莫大的帮助。</p>
<figure data-type="image" tabindex="1"><img src="DraggedImage-1.png" alt=""></figure>
<p>合格的搜索引擎会提供了许多维度的过滤方式——高级检索语法，能够更加快速的搜到你真正需要的东西，在这里提供了一个我自己收集整理的 <a href="https://docs.google.com/spreadsheets/d/12SLN7V2b9KkI_ObRQAZ5z6A4-aK6uSGvLJRKl9irBhI/edit?usp=sharing">Google高级语法表</a> 。</p>
<p>**2.把握「规律」来迁移已有的知识。**我一直将知识想象成一个多层的网状的结构，这样的一个「库」，里面的各个元素之间都会有复杂的链接，而我相信这之中会有某种「规律」，能够在较大程度上去解释这些「链接」。而这些「规律」，可以理解为各种思维方法，这些思维方法能够帮助你进行知识点与知识点的链接。这里说的可能有些玄妙了，举例来说，类比的思维方式能够在你理解一个逻辑的前提下，快速理解另一个逻辑。例如当你理解「外网」，是通过 IP 地址来识别各种请求的，这样你去理解内网就非常容易了。再比如，你知道 Stata 中回归的命令是 <code>reg y x1 x2 x3</code> ，其中 <code>reg</code> 是命令，后面的 <code>y x1 x2 x3</code> 是参数，那么你就能理解<code>ssh -p 10022 admin@192.168.1.1</code> ，类似的 <code>ssh</code> 也是某种命令， <code>-p 1022 admin@192.168.1.1</code> 都是类似的不同参数。这就是类比的思维去迁移。当然例子中提到的仅仅是类比的思维而已，许多学科的「方法论」内容能够在一定程度上去理解其他的内容（至少经济学在这一方面做的相对不错）。</p>
<p>这两步写了这么大段的文字，但其实在真正操作起来并不复杂，用搜索引擎去搜索不知道的和你知道的关键词，然后去猜测这个「需要的是什么」，在实际中可能只是你坐在电脑前面按两下 Ctrl 键，唤起 Alfred ，键入关键词然后回车，再拿笔写写画画，再按两下 Ctrl 键，再次唤起 Alfred ，键入关键词然后回车的过程。</p>
<p>理解了这个位置概念的基本背景知识，并且有所标的的迁移到已有的知识体系后，你就能基本明确这个陌生概念对于自己目标的实现需要的是什么了。</p>
<p>最后，如果你对自己模式化思维的能力有所怀疑，可以看看几年前的畅销书《思考的快与慢》，应该会有所帮助，如果对经济学的解释感兴趣，可以看看张五常的《经济解释》，非科班出生看第一本就能看到很多关于经济学方法论的内容（虽然没有目前主流的计量内容）。</p>
<h2 id="二对象长什么样">（二）「对象」长什么样</h2>
<p>这种迁移不仅仅对理解「需要什么」有帮助，其实也对厘清「对象长什么样」有帮助。对象长什么样，就是要对这个位置概念又一个较为整体的认识。只要较为整体即可，并不需要非常完整的认识，因为这个认识总是随着知识水平的提高，不断完善的。那些与目前需求无关的连接点，并不需要在快速入门的情况下被关注。</p>
<p>**首先，阅读「前言」性质的内容，快速形成概念的整体认识。 **看前言或者摘要这一类性质的内容，是理解一个概念、一篇文章的捷径。一般作者都会在这里就先整理好这个概念的历史。例如<a href="https://sspai.com/post/31500"> URL Schemes 使用详解</a> 中，前3部分就是这个性质的内容。阅读这些内容，并不需要多大的基础，集中精力基本都能看懂。这里也没有太多的技巧，唯一有的建议就是看优秀的内容生产者生产的文字会更加节省时间。</p>
<p>其次，对于这些「知识点」的认识，我的思考角度一般是这样的，先从对于员工的我来说这个「陌生概念」是怎么样的，其次是对于公司来说这个「陌生概念」起到的重要程度是怎么样的：</p>
<p>**1.这个「陌生概念」在我所做的工作流程中应当处于什么位置。**因为这个「对象长什么样」是对于我来说的，也就是说，我需要理解他对于我来说到底有多重要，然后是对于公司业务来说有多重要。所以，这里「什么位置」主要是为其贴上重要程度的分类、业务流程的分类、技能结构的分类以及其他有助于梳理的标签。例如，我有一段时间被要求去学习 R 语言。那么我基本了解到了，R 主要应用于大数据处理相关的工作，例如大数据的计量、画图等，还在机器学习方面有一定的应用。而我的背景是学习了一些 Python 基础，Python 的应用比 R 广泛，能够覆盖到我一些运维的工作。所以这是一个在我的工作流程中相对不那么重要的事情，但是我依然需要去解决它。在业务上，这是一项我们必须要做的业务，所以我需要的就是把它放在一个「需要被解决的需求」的位置上就可以了。解决完这个问题后，我并不需要过多的再去关注其他领域的东西。第一步就界定好这个「位置」，才能做到下手又轻重，避免不必要的精力花费。</p>
<p><strong>3. 尝试去理解团队对这个需求的要求是什么。</strong> 最后一个，对于小团队来说非常适用，因为产品信息可能相对透明。当领导让你去实现一个陌生的需求时，如果有可能，那么去揣度一些产品真正的需求是什么，能够帮助我们判断哪里是需要精益求精的，哪里是会有「加工余量」的，这样能够更加快速的安排工作。这里的建议就是，能够偷懒的地方，需要慎重，因为「坑」一般是要自己填的。理解上级需求的前提是，你是知道公司的产品是怎么样的产品。如果连这个都不知道，那么还是不要做过多的揣度。</p>
<p>除了从个人、团队角度的思考外，还有一种普遍性很强的思维方式，即横向的思考和纵向的思考。<strong>1.所谓横向的思考</strong>，就是与其他东西做横向的比较，然后得出差异，来标定这个「陌生概念」到底需要多少投入。<strong>2.所谓纵向思考</strong>，就是在时间线上去理解思考。在学习新事物这件事上，其实主要是考虑未来这个「陌生概念」中会不会有几个部分是对团队非常重要的内容。</p>
<p>最后，总结一下，这一步的思考其实就是需要肢解这个「陌生概念」，然后去理解这个「陌生概念」中的知识点，并尝试划分轻重缓急，为后续有重点的快速入门作准备。我认为这一样是一个思考、理解、猜测的过程。</p>
<h2 id="三为自己写下清单">（三）为自己写下清单</h2>
<p>在思考「需要什么」时，可以理解为 GTD 的「收集」工作，因为这些关键词的结果，其实是进行具体的学习与操作的素材。在定位「对象」时，也可以认为在「处理」与「组织」，重点是为厘清后续的操作。在思考完这些事情后，我一般会在 Todoist 中创建具体的任务。一般我至少会打上以下标签：</p>
<ol>
<li>重要程度：Todoist 中 p1 表示重要，没有标注就表示一般。</li>
<li>难度：困难、简单</li>
<li>时间范围：DDL 表示截止日、 FT（free time）表示闲暇时、Hold 表示需要注意再次安排的，以及具体的时间</li>
<li>精力：专注 ，表示要集中精力做的，没有标注就表示一般。</li>
<li>其他根据具体情况会再添加辅助分类用的标签。</li>
</ol>
<p>清单写完后，就是根据 Todoist 的任务一项一项进行学习与操作。</p>
<figure data-type="image" tabindex="2"><img src="WechatIMG74.jpeg" alt=""></figure>
<p>少数派之前关于精力管理的文章，让我开始意识到学习中投入精力这件事。以我自己的经验来说，我现在仍然清晰的记着在小学的时候，就习惯在下午 2:30 的时候，搬着小板凳开始写作业，所以我一直以来的习惯就是在下午2-3点的时候精力较为集中，Todoist 的纪录同样验证了这一点。以前自己并没有刻意关注这个问题，但是实际的体验在说明，精力集中时，我自己的脑子就是会更加清晰。自己精力最为充沛的时间段做那些需要集中精力的事情才是最优决策。所以筛选出需要集中精力的任务非常有必要。如果你对于自己何时精力充沛没有认识，可以尝试此前少数派介绍过的<a href="https://sspai.com/post/45357">精力管理模板</a>。然后这个结果也许会是一种安慰剂，暗示自己能够实现高效的集中精力，完成自己的目标。</p>
<p>大胆的猜测，需要你有更多信息这样能够更好的辅助自己的判断。所以更多的阅读是有必要的。少数派上有不少关于阅读流程的内容，我也参照着学习过，对于 Web 内容我依然使用 RSS 作为主要的信息摄入方式，我也没有将其精简，因为对于我来说，内容没读完并不会让我感到焦虑，我也没有一定要在 RSS 中获得什么的想发，更多的是一种眼界的拓宽，思维的拓展。我十分习惯也热衷于「刷 RSS」 。简单来说，我的阅读流程大概是这样的：在 Reeder 中看简单文章，觉得好的保存道印象笔记中，需要仔细看的发到 Instapaper 中，需要学习的发送到 Goodnotes 中，最后都归档到印象笔记中。我希望自己看到更加看到更加多元的东西，但是我也不想让算法暴露我的癖好，所以我选择用 RSS 来作为主要的信息摄入渠道。</p>
<p>总体来说，我的经验是，如果你需要快速入门一个东西，那么比起抓紧时间，更为重要时期是去思考，去理解。而面对陌生概念，要勇敢的去猜测，去迁移自己的知识，之后才是按照轻重缓急的去学习，去操作。就像前文提到的，本文所提到的方法，并不一定适用于他人。但是，于我而言，这些都是有效的，这些都是影响我的。所以，请去思考，去理解，去猜测，大胆践行自己的思考，为自己所做承担即可。</p>
]]></content>
    </entry>
</feed>