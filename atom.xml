<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hwang.top</id>
    <title>Hwang&apos;s Blog</title>
    <updated>2019-10-06T07:41:26.410Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hwang.top"/>
    <link rel="self" href="https://hwang.top/atom.xml"/>
    <subtitle>欢迎来到 Hwang 的小博客</subtitle>
    <logo>https://hwang.top/images/avatar.png</logo>
    <icon>https://hwang.top/favicon.ico</icon>
    <rights>All rights reserved 2019, Hwang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Qt for Python 的小Tips —— 外部加载 QSS]]></title>
        <id>https://hwang.top/post/qt-for-python-de-xiao-tips-wai-bu-jia-zai-qss</id>
        <link href="https://hwang.top/post/qt-for-python-de-xiao-tips-wai-bu-jia-zai-qss">
        </link>
        <updated>2019-10-06T07:37:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="pyqt5pyside2-加载-qss-文件">PyQt5/PySide2 —— 加载 QSS 文件</h2>
<pre><code class="language-python">class beautifyUI(object):
    def __init__(self):
        pass
    def readQss(self, qssfile):
        &quot;&quot;&quot;
        加载 QSS 文件；
        qssfile：qss文件路径；
        &quot;&quot;&quot;
        with open(qssfile, &quot;r&quot;) as f:
            return f.read()   
</code></pre>
<p>定义一个函数，基本上就可以通过这个 读取 QSS 作为字符串，然后存为变量，读取进去就OK了。</p>
<p>当然这个文件在打包时也要特殊处理：要么作为字符串储存于某个变量中，要么直接在特定目录下去读取这个文件。在mac的应用打包中，格外需要注意这点。请尽量使用绝对路径记录信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Qt for Python 的小 Tips - 不显示软件的「大下巴」— QStatus]]></title>
        <id>https://hwang.top/post/qt-for-python-bu-xian-shi-ruan-jian-de-da-xia-ba-qstatus</id>
        <link href="https://hwang.top/post/qt-for-python-bu-xian-shi-ruan-jian-de-da-xia-ba-qstatus">
        </link>
        <updated>2019-10-06T07:35:37.000Z</updated>
        <content type="html"><![CDATA[<p>这里设置 软件的底部信息栏，PySide 中称为 QStatusbar。</p>
<p>利用 QT Creator 生成的 mainWindows 软件会自动添加该部件。如果不需要底部状态栏，注释掉就可以了。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/10/06/3iQ5fJxY1rZNEgb.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Procreate 练习]]></title>
        <id>https://hwang.top/post/procreate-lian-xi</id>
        <link href="https://hwang.top/post/procreate-lian-xi">
        </link>
        <updated>2019-10-01T12:17:19.000Z</updated>
        <content type="html"><![CDATA[<p>画图，画图。</p>
<p>好久没有动笔了。线条画的一点都不流畅了。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/10/01/xwQ8BVtOInGfvW7.png" alt="IMG_0404.PNG"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Update 了一下 figma 的封面]]></title>
        <id>https://hwang.top/post/update-liao-yi-xia-figma-de-feng-mian</id>
        <link href="https://hwang.top/post/update-liao-yi-xia-figma-de-feng-mian">
        </link>
        <updated>2019-09-30T10:00:58.000Z</updated>
        <content type="html"><![CDATA[<p>更新了一下figma的封面：<br>
<img src="https://hwang.top/post-images/1569837778140.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个用了 3 个月 PyQt 的人，在学 Vue.js 基础]]></title>
        <id>https://hwang.top/post/yi-ge-yong-liao-3-ge-yue-pyqt-de-ren-zai-xue-vuejs-ji-chu</id>
        <link href="https://hwang.top/post/yi-ge-yong-liao-3-ge-yue-pyqt-de-ren-zai-xue-vuejs-ji-chu">
        </link>
        <updated>2019-09-30T01:53:10.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>el:</p>
</li>
<li>
<p>data:</p>
</li>
<li>
<p>methods: 用于存放 事件内的方法。 可以理解为 PyQt 中 存放 槽函数 的一个字典。</p>
</li>
<li>
<p>v-cloak 能够解决插值表达式（<code>{{}}</code>） 闪烁 的问题<br>
<code>&lt;v-test='msg'&gt;</code></p>
</li>
<li>
<p>v-test 没有闪烁问题，会覆盖元素中原本的内容，但是，插值表达式只会替换自己的占位符。</p>
</li>
<li>
<p>v-html : 输出闪烁问题</p>
</li>
<li>
<p>v-blind : 绑定 属性 的指令，简写为 <code>:</code> ; v-blind 可以写合法的 js 表达式</p>
</li>
<li>
<p>v-on : 绑定 事件的 （类似 qt 中的 信号与槽的绑定），简写为 <code>@</code></p>
</li>
<li>
<p>v-model: 双向数据绑定，只能用在表单元素（input（radio、text、address、email...） select checkbox textarea）中。</p>
</li>
<li>
<p>v-for: 循环操作</p>
<ul>
<li><code>&lt;p v-for =&quot;item in list&quot;&gt;{{item}}&lt;/p&gt;</code></li>
<li><code>&lt;p v-for =&quot;(item, i) in list&quot;&gt;索引值:{{i}} --- 项目：{{item}}&lt;/p&gt;</code></li>
<li>可以迭代 1.普通数组；2.对象数组；3.对象；4. 数字（起始是1）</li>
<li>在组件中使用 V-for 循环的时候，必须使用 v-for 的同时，制定唯一的字符串/数字类型的 key 值</li>
</ul>
</li>
<li>
<p>v-if</p>
<ul>
<li>每次都会重新删除或者创建元素</li>
<li>有较高的切换性能消耗</li>
</ul>
</li>
<li>
<p>v-show</p>
<ul>
<li>切换元素的 display:none 样式</li>
<li>有较高的初始渲染消耗</li>
</ul>
</li>
</ul>
<h2 id="事件修饰符">事件修饰符</h2>
<ul>
<li>@click.stop 阻止事件的冒泡（从内到外，触发事件）</li>
<li>@click.prevent 阻止默认行为的使用</li>
<li>.capture 以捕获机制触发行为（从外到里，触发事件）</li>
<li>.self 只有自身的时候执行</li>
<li>.once 只触发一次</li>
</ul>
<h2 id="vue-中使用样式">vue 中使用样式</h2>
<ul>
<li>使用数组 <code>:class = ['style1','style2']</code> 会给出style1和style2的合并样式效果</li>
<li><code>:class = ['style1','style2',{'style3':flag}]</code>使用 v-blind ，伪 Class 表达可以使用对象的方式赋值，能够更好的实现样式变化的情况,在data中：<br>
<code>data flag: true }</code><br>
此时能够通过js来控制这个样式的实现与否。</li>
<li>在数组中可以使用 <a href="#">三元表达式</a>(https://baike.baidu.com/item/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/1394210)，python 中 类是 if 的判断语句</li>
<li>可以直接使用对象的方式调用样式。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 的虚拟环境管理  virtualenv & pyenv]]></title>
        <id>https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv</id>
        <link href="https://hwang.top/post/python-de-xu-ni-huan-jing-guan-li-virtualenv-and-pyenv">
        </link>
        <updated>2019-09-29T02:11:01.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>pyenv : 用于Python版本管理。<br>
virtualenv ：用于构建按项目的虚拟环境。<br>
pyenv-virtualenv  ： pyenv 的插件，用于构建项目的虚拟环境。</p>
</blockquote>
<!-- more -->
<p>由于生产需要，用 PyQt5 写了小程序，打包成 <code>.app</code> 过程中发现，打包后竟然有200多M，应该是因为之前使用的python环境中其他包比较多的关系。所以就想到建虚拟环境，来打包。</p>
<p>首先想到的是按项目建虚拟环境，那就用virtualenv 。简单看了一下，实践如下：</p>
<h2 id="virtualenv">virtualenv</h2>
<h3 id="1-安装virtualenv">1. 安装virtualenv</h3>
<p>用pip进行安装。</p>
<pre><code class="language-bash">$ pip install virtualenv 
</code></pre>
<p>先建文件夹，再<code>cd</code>到需要的文件夹中，运行下面的命令：</p>
<pre><code class="language-bash">$ virtualenv --python=&quot;/usr/local/bin/python3.7&quot; --no-site-packages venv
</code></pre>
<p>其中：</p>
<pre><code class="language-bash">--python （-p） # 用于指定版本
--no-site-packges # 表示不需要包
venv # 虚拟环境的名称
</code></pre>
<p>其它选项：</p>
<pre><code class="language-bash">--version
#显示当前版本号。
-h, --help
#显示帮助信息。
-v, --verbose
#显示详细信息。
-q, --quiet
#不显示详细信息。
-p PYTHON_EXE, --python=PYTHON_EXE
#指定所用的python解析器的版本，比如 --python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前系统安装(/usr/bin/python)的python解析器
--clear
#清空非root用户的安装，并重头开始创建隔离环境。
--no-site-packages
#令隔离环境不能访问系统全局的site-packages目录。
--system-site-packages
#令隔离环境可以访问系统全局的site-packages目录。
--unzip-setuptools
#安装时解压Setuptools或Distribute
--relocatable
#重定位某个已存在的隔离环境。使用该选项将修正脚本并令所有.pth文件使用相当路径。
--distribute
#使用Distribute代替Setuptools，也可设置环境变量VIRTUALENV_DISTRIBUTE达到同样效要。
--extra-search-dir=SEARCH_DIRS
#用于查找setuptools/distribute/pip发布包的目录。可以添加任意数量的–extra-search-dir路径。
--never-download
#禁止从网上下载任何数据。此时，如果在本地搜索发布包失败，virtualenv就会报错。
--prompt==PROMPT
#定义隔离环境的命令行前缀。
#环境变量和配置文件
</code></pre>
<h3 id="2-激活虚拟环境">2. 激活虚拟环境</h3>
<pre><code class="language-bash">$ . venv/bin/activate
</code></pre>
<figure data-type="image" tabindex="1"><img src="DraggedImage.png" alt=""></figure>
<p>前面出现<code>(venv)</code> 即可。</p>
<h3 id="一些发现">一些发现</h3>
<ul>
<li>virtualenv 默认似乎是从原环境中下载包的。就是优先直接从原有库中拷贝，不通过下载。这样速度会比较快。</li>
</ul>
<blockquote>
<p>由于本地环境除了 anaconda 的以为， Python 3.7。在打包中出现了一些兼容性问题，具体可见：<br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/1957">https://github.com/pyinstaller/pyinstaller/issues/1957</a><br>
<a href="https://github.com/pyinstaller/pyinstaller/issues/3753">https://github.com/pyinstaller/pyinstaller/issues/3753</a><br>
即便按照issues里说的做了，我也没能解决问题。所以想到下载 3.6版本的 Python 来使用。所以就想到了用 pyenv</p>
</blockquote>
<h2 id="pyenv">pyenv</h2>
<p>基本过程可参考：<a href="https://www.jianshu.com/p/4646dedaaff5">https://www.jianshu.com/p/4646dedaaff5</a></p>
<h3 id="1-安装">1. 安装</h3>
<p>我是通过 Homebrew 下载的（可参考：<a href="https://zhuanlan.zhihu.com/p/27294128">https://zhuanlan.zhihu.com/p/27294128</a>）。</p>
<blockquote>
<p>备份一下 <code>.bash_profile</code></p>
</blockquote>
<pre><code class="language-bash"># Setting PATH for Python 3.7
# The original version is saved in .bash_profile.pysave
PATH=&quot;/Library/Frameworks/Python.framework/Versions/3.7/bin:${PATH}&quot;
export PATH

# added by Anaconda3 5.2.0 installer
export PATH=&quot;/Users/wangxuexi/anaconda3/bin:$PATH&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
export PYENV_ROOT=&quot;$HOME/.pyenv&quot;
export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;
eval &quot;$(pyenv init -)&quot;
eval &quot;$(pyenv virtualenv-init -)&quot;
</code></pre>
<pre><code class="language-bash">$ brew install pyenv
</code></pre>
<p>有可能需要：</p>
<pre><code class="language-bash">$ echo 'export PYENV_ROOT=&quot;$HOME/.pyenv&quot;' &gt;&gt; ~/.bash_profile
$ echo 'export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;' &gt;&gt; ~/.bash_profile
$ echo 'eval &quot;$(pyenv init -)&quot;' &gt;&gt; ~/.bash_profile
</code></pre>
<p>写完后，用以下命令重新登录一下：</p>
<pre><code class="language-bash">$ source ~/.bash_profile
</code></pre>
<p>如果有需要可以安装 pyenv-virtualenv:</p>
<pre><code class="language-bash">$ brew install pyenv-virtualenv
</code></pre>
<p>同样的：</p>
<pre><code class="language-bash">$ echo 'eval &quot;$(pyenv virtualenv-init -)&quot;' &gt;&gt; ~/.bash_profile
# 写入 profile
$ source  ~/.bash_profile
# 重新进登录一遍
</code></pre>
<p>命令参数如下</p>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt; # 建虚拟环境
pyenv virtualenv activate &lt;virtualenv-name&gt; # 激活虚拟环境
pyenv virtualenv-delete &lt;virtualenv-name&gt; # 删除虚拟环境
</code></pre>
<h3 id="2-pyenv-的使用">2. pyenv 的使用</h3>
<p>基本的下载、删除 命令：</p>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v # 用国内源安装很快
</code></pre>
<pre><code class="language-bash">v=3.6.7|wget http://mirrors.sohu.com/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install
</code></pre>
<hr>
<pre><code class="language-bash">$ pyenv install -v 3.6.0  # 安装

$ pyenv uninstall 2.7.10 # 删除
</code></pre>
<p>激活，pyenv 有几种激活方式：</p>
<pre><code class="language-bash">local       Set or show the local application-specific Python version
global      Set or show the global Python version
shell       Set or show the shell-specific Python version
</code></pre>
<p>通过<code>version</code> 、  <code>versions</code>  查看版本。</p>
<p>其他：</p>
<pre><code class="language-bash">Usage: pyenv &lt;command&gt; [&lt;args&gt;]

Some useful pyenv commands are:
   commands    List all available pyenv commands
   local       Set or show the local application-specific Python version
   global      Set or show the global Python version
   shell       Set or show the shell-specific Python version
   install     Install a Python version using python-build
   uninstall   Uninstall a specific Python version
   rehash      Rehash pyenv shims (run this after installing executables)
   version     Show the current Python version and its origin
   versions    List all Python versions available to pyenv
   which       Display the full path to an executable
   whence      List all Python versions that contain the given executable

See `pyenv help &lt;command&gt;' for information on a specific command.
For full documentation, see: https://github.com/yyuu/pyenv#readme
</code></pre>
<h3 id="3-pyenv-virtualenv-的使用">3. Pyenv virtualenv 的使用</h3>
<h4 id="31-创建">3.1 创建：</h4>
<pre><code class="language-bash">pyenv virtualenv [-f|--force] [-u|--upgrade] [VIRTUALENV_OPTIONS] &lt;version&gt; &lt;virtualenv-name&gt;
</code></pre>
<ul>
<li><code>-f</code> 表示强制的（假如虚拟环境已存在，将会覆盖这个虚拟环境）</li>
<li><code>-u</code> 表示upgrade，用于修改已经存在的虚拟环境的Python版本</li>
<li><code>VIRTUALENV_OPTIONS</code> 是传递给virtualenv的选项，可以通过virtualenv的帮助获取选项的含义</li>
<li><code>version</code> 表示Python版本</li>
<li><code>virtualenv-name</code> 指定虚拟环境名</li>
</ul>
<h4 id="32-使用">3.2 使用</h4>
<p>pyenv的virtual不用手动去激活环境；当把本地目录与环境相关联起来后，将自动激活虚拟环境，离开目录时自动退出虚拟环境</p>
<h3 id="注意事项">注意事项：</h3>
<ol>
<li>pyenv 下载慢：<a href="http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/">http://huanyouchen.github.io/2018/04/29/pyenv-install-python-very-slow/</a></li>
</ol>
<blockquote>
<p>先去官网下载对应版本的源码：https://www.python.org/downloads/source/<br>
然后创建/.pyenv/cache目录： mkdir /.pyenv/cache (如果已经有该目录直接进入: cd /.pyenv/cache) 然后 <code>pyenv install 3.6.0</code></p>
</blockquote>
<ol start="2">
<li>打包出错，提示需要 python-dev：<a href="https://github.com/pyenv/pyenv/issues/1095">https://github.com/pyenv/pyenv/issues/1095</a></li>
</ol>
<blockquote>
<p>使用以下命令进行安装：</p>
<pre><code class="language-bash">PYTHON_CONFIGURE_OPTS=&quot;--enable-framework&quot; pyenv install 3.6.0
</code></pre>
</blockquote>
<h3 id="删除虚拟环境">删除虚拟环境</h3>
<pre><code class="language-bash">$ pyenv local system
$ pyenv virtualenv-delete venv
pyenv-virtualenv: remove /home/will/.pyenv/versions/3.4.1/envs/venv? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.1
  3.4.2

$ pyenv uninstall 3.4.1
pyenv: remove /home/will/.pyenv/versions/3.4.1? y
$ pyenv versions
* system (set by /home/will/test/.python-version)
  3.4.2
</code></pre>
<h2 id="windows-上的虚拟环境管理">Windows 上的虚拟环境管理</h2>
<p>Windows 上同样支持 Virtualenv 进行虚拟环境的管理的。步骤与上述差不多。</p>
<p>Windows 不支持 Pyenv 。</p>
<h3 id="安装-virtualenvwrapper">安装  virtualenvwrapper</h3>
<p>使用 virtualenvwrapper 能够比较容易的使用虚拟环境。</p>
<pre><code class="language-bash">$ pip install virtualenvwrapper-win
</code></pre>
<h3 id="创建-虚拟环境">创建 虚拟环境</h3>
<p>使用 <code>mkvirtualenv</code> 创建虚拟环境。</p>
<pre><code class="language-bash">$ mkvirtualenv -p [python路径] [虚拟环境名称]
</code></pre>
<p>环境默认创建地址为：<code>C:\Users\[username]\envs</code></p>
<h3 id="激活-虚拟环境">激活 虚拟环境</h3>
<p>使用 <code>workon + [虚拟环境名称]</code> 命令进行激活。</p>
<pre><code class="language-bash">$ workon env1
</code></pre>
<p>使用 <code>workon</code> 列出当前的虚拟环境：</p>
<pre><code class="language-bash">$ workon
</code></pre>
<p>退出虚拟环境：</p>
<pre><code class="language-bash">$ deactivate
</code></pre>
<p>删除环境：</p>
<pre><code class="language-bash">$ rmvirtualenv
</code></pre>
<p>复制虚拟环境：</p>
<pre><code class="language-bash">$ cpvirtualenv env1 env3
</code></pre>
<ul>
<li>参考：<a href="https://www.jianshu.com/p/60f361822a7e">https://www.jianshu.com/p/60f361822a7e</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hwang 的低质阅读单 New 1]]></title>
        <id>https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1</id>
        <link href="https://hwang.top/post/hwang-de-di-zhi-yue-du-dan-new-1">
        </link>
        <updated>2019-09-27T01:37:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="hwang-的低质阅读单-new">Hwang 的低质阅读单 New</h1>
<h6 id="这些文章来自-hwang-的-instapaper-从-rss-微博-微信等地方看到觉得自己应该仔细看看的文章收集进-instapaper-归档这些文章后才会出现这里-故而主观又缺乏时效性-很遗憾没有帮到你们">这些文章来自 Hwang 的 Instapaper 。从 RSS、微博、微信等地方看到，觉得自己应该仔细看看的文章，收集进 Instapaper ，归档这些文章后，才会出现这里。故而，主观又缺乏时效性。很遗憾没有帮到你们。</h6>
<ul>
<li><a href="https://ift.tt/2KP9jma"> 来自 Petra Collins 的“驱魔仪式” | 异视异色｜i-D 中国｜来自VICE的时尚频道</a></li>
<li><a href="https://ift.tt/2Jk8uyy"> 公众号「信息流」改版一周年，有人说没有想的那么糟糕 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2XAAcAp"> 复盘 Evernote：笔记 App 的开山鼻祖，为什么没落了？</a></li>
<li><a href="https://ift.tt/2Xb7HoL"> 苹果的后 iPhone 时代</a></li>
<li><a href="https://ift.tt/2YlJ2PI"> 无大台的时代</a></li>
<li><a href="https://ift.tt/2NxjMVH"> 苹果的跨平台计划：如何用 App 打通 iPad 和 Mac</a></li>
<li><a href="https://ift.tt/30hEzOj"> PyQt + QML 快速开发GUI总结</a></li>
<li><a href="https://ift.tt/2XvPdnd"> 2019中国α世代线上娱乐价值观念洞察 | 人人都是产品经理</a></li>
<li><a href="https://ift.tt/2YyeXMJ"> 机器学习能成为因果推断的“圣杯”吗？</a></li>
<li><a href="https://ift.tt/2JnoboO"> 如何用 Python 和 BERT 做多标签（multi-label）文本分类？</a></li>
<li><a href="https://ift.tt/30kBQnD"> 怎么选择数据服务器？请记住这五条</a></li>
<li><a href="https://ift.tt/2Sz79YR"> 如何用约会软件进行艺术创作？</a></li>
<li><a href="https://ift.tt/2Y1EuwI"> 亚马逊中国停售纸质书／李楠宣布从魅族离职／京都动画大火已造成 33 人遇难</a></li>
<li><a href="https://ift.tt/2YIO4FW"> 社交围城里的刷新机器</a></li>
<li><a href="https://ift.tt/31I1TWt"> 马斯克的脑机接口来了，USB 连大脑，用 iPhone 操控 | 近未来 ⑫</a></li>
<li><a href="https://ift.tt/2YqQImZ"> 早报 | 明年 iPhone 或全线支持 5G vivo 首款 5G 手机或将亏本卖 《哪吒》破动画票房纪录</a></li>
<li><a href="https://ift.tt/2KIHh9H"> 港真，乱么？ | 可能吧</a></li>
<li><a href="https://ift.tt/301BHsJ"> win10引导错误的修复（内容系转载） - 技术经验 - W3xue</a></li>
<li><a href="https://ift.tt/2HJC7JV"> AI 语音模仿老板声音要求转账，成功骗走了 173 万</a></li>
<li><a href="https://ift.tt/2LcUqIn"> Designing Dark Mode</a></li>
<li><a href="https://ift.tt/2M7vv9w"> 一篇文章让你彻底搞清楚Python中self的含义 - jessonsh - 博客园</a></li>
<li><a href="https://ift.tt/332qNAv"> 出身清华姚班，斯坦福博士毕业，她的毕业论文成了「爆款」</a></li>
<li><a href="https://ift.tt/1PzbZyK"> 高清图标SVG解决方案全总结（上） - 文章 - 伯乐在线</a></li>
<li><a href="https://ift.tt/1PzL3P8"> 高清图标SVG解决方案全总结（下） - 文章 - 伯乐在线</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 用 Python 做计量 （一）—— 初识Python 的计量模块： Statsmodels ]]></title>
        <id>https://hwang.top/post/yong-python-zuo-ji-liang-yi-chu-shi-python-de-ji-liang-mo-kuai-statsmodels</id>
        <link href="https://hwang.top/post/yong-python-zuo-ji-liang-yi-chu-shi-python-de-ji-liang-mo-kuai-statsmodels">
        </link>
        <updated>2019-07-16T10:31:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文发布于 「 数据Seminar 」公众号：https://mp.weixin.qq.com/s?src=11&amp;timestamp=1569839526&amp;ver=1884&amp;signature=hxZrP-JJKRnGggkDaM2PDBJc7DJsrqQWkpBciqqbDAEeqjNhRKIc37VK4bPqNUKSDjtXPGV0yto99QK5ywqoagPK1PhKPC0dynzFMNVchJWrQG5X3VUMMBadcyBnh7hi&amp;new=1</p>
</blockquote>
 <script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
 </script>
 <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<blockquote>
<p>阅读本文前需要掌握的基础知识：<br>
Python 的基础知识、 numpy 的基础知识、 pandas 的基础知识<br>
基本的计量知识<br>
如果你还不会，那么本文也会介绍一些 python 语法的基础内容，方便大家理解。</p>
</blockquote>
<p>随着数据资源的日渐丰富，学者们越来越多的需要接触到大数据的处理，许多学者还是习惯使用 Stata 对数据进行处理，而 Stata 由于其自身的限制，在处理大数据集时要么需要强劲的处理性能（昂贵的硬件成本），要么需要等待较长时间（更加昂贵的时间成本）。Python 和 R 也就日渐进入学者的视野，相对于 R ，Python 的语法更为简单，成为一部分学者的首选。</p>
<p>在数据处理上，numpy 和 pandas 的组合，使得 Python 能够轻松应对千万级别的数据处理。在攻克数据处理这一环后，在数据应用上，除了新潮的机器学习、深度学习的方法，对于现阶段社科学者来说，计量可能才是最现实的。在 Python 中处理的数据如果还需要调回到 Stata 中做计量，那未免太「蹩脚」。今天，数据Seminar 公众号将带大家体验 Python 上的第三方计量库：<a href="https://www.statsmodels.org/stable/index.html">Statsmodels</a> 。</p>
<h2 id="简介">简介</h2>
<p>Statsmodels 是一个Python的第三方模块，他封装了许多计量模型，方便学者直接调用。所谓封装，就相当于 Stata 中一个 <code>reg</code> 命令，代表了最基础的 OLS 回归命令，在Statsmodels 中也有类似 <code>reg</code> 的语句，提供给 OLS 估计。另外 Statsmodels 的开源协议为 <a href="https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE">BSD </a>（基本上对于用户来说属于为所欲为协议，你可以任意使用这款扩张包，具体参见链接地址）。</p>
<blockquote>
<p>statsmodels is a Python module that provides classes and functions for the estimation of many different statistical models, as well as for conducting statistical tests, and statistical data exploration. An extensive list of result statistics are available for each estimator. The results are tested against existing statistical packages to ensure that they are correct. The package is released under the open source Modified BSD (3-clause) license. The online documentation is hosted at statsmodels.org.</p>
</blockquote>
<h2 id="安装">安装：</h2>
<p>如果你使用 Anaconda 安装的 python ，那么：</p>
<pre><code class="language-bash">conda install statsmodels
</code></pre>
<p>如果你使用 pip 管理你的python包，那么：</p>
<pre><code class="language-bash">pip install statsmodels # python2 
</code></pre>
<p>或者：</p>
<pre><code class="language-bash">pip3 install statsmodels #python3
</code></pre>
<h2 id="精读代码初探ols">“精读”代码，初探：OLS</h2>
<p>官方的说明文档：<a href="http://www.statsmodels.org/stable/gettingstarted.html">http://www.statsmodels.org/stable/gettingstarted.html</a></p>
<p>首先先看了一下 OLS 的示例：</p>
<pre><code class="language-python">import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf

dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data
results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit()
print(results.summary())
</code></pre>
<p>运行后：<br>
<img src="DraggedImage.png" alt=""><br>
*(本文采用的编辑器为 Google 的 colab) *</p>
<p>是的，OLS就是这么几行，具体来看内容，其实进行 OLS 回归只需要一行内容。为了方便 Python 基础不那么好的同学，我们驻行“精读”一遍这些代码：</p>
<h3 id="1-导入模块">1. 导入模块</h3>
<pre><code class="language-python">import numpy as np
import statsmodels.api as sm
import statsmodels.formula.api as smf
</code></pre>
<p>首先是需要导入 numpy、statsmodels 的相关模块，numpy 推荐的缩写命名 np，statsmodels 推荐的缩写命名是 sm，这样后面的代码就可以通过 <code>np.[具体的函数\方法]</code> ，<code>sm. [具体的函数\方法]</code> 的方式来更加简洁的调用了。</p>
<h3 id="2-生成测试数据集">2. 生成测试数据集</h3>
<pre><code class="language-python">dat = sm.datasets.get_rdataset(&quot;Guerry&quot;, &quot;HistData&quot;).data
</code></pre>
<p>由于并没有现成数据，我们可以通过 statsmodels 中自带的数据集，关于该数据集的具体信息可以参考：<a href="https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Guerry.html">https://vincentarelbundock.github.io/Rdatasets/doc/HistData/Guerry.html</a>，简单来说，这是一个关于犯罪、识字等相关内容的社会科学领域的数据集。<br>
<img src="DraggedImage-1.png" alt=""></p>
<p>这个数据集以DataFrame 格式的储存在了 <code>dat</code> 这个变量中。 DataFrame 格式在 Python 中被广泛的使用，可以说无论是机器学习还是本文介绍的计量相关内容，DataFrame 格式相关的操作都需要熟练掌握。关于 DataFrame 的相关内容，需要更加细致的去学习Python的另一个第三方库 pandas ，本文不再赘述。</p>
<h3 id="3-回归操作">3. 回归操作</h3>
<pre><code class="language-python">results = smf.ols('Lottery ~ Literacy + np.log(Pop1831)', data=dat).fit()
</code></pre>
<p>首先是<code>smf.ols</code>， <code>smf</code> 就是前面的 <code>statsmodels.formula.api</code> ，OLS 回归的方法在 <code>statsmodels.formula.api</code>下，如果前文没有声明 <code>smf</code> 代表<code>statsmodels.formula.api</code> 的话，你这里可就要写成 <code>statsmodels.formula.api.ols</code> 了，可见合理的缩写声明对于代码的简洁美观非常有帮助。</p>
<p>接下来是括号内的内容<code>('Lottery ~ Literacy + np.log(Pop1831)', data=dat)</code><br>
这其实是<code>OLS</code>模型需要传入的参数，以<code>,</code>为区隔，第一个参数是回归模型，第二个参数是数据。</p>
<p>在这行代码中，回归模型是：<code>'Lottery ~ Literacy + np.log(Pop1831)'</code>，数据是前面加载的<code>dat</code> ，比较方便的是，<code>statsmodels</code>，直接从数据<code>dat</code>中读取了变量名称，并不需要进行额外的赋值操作。我们具体看一下这个模型的写法，对于没有接触过 Python 和 R 的读者来说，这种写法可能相对有些陌生，其实这个模型代表了：</p>
<figure data-type="image" tabindex="1"><img src="DraggedImage-2.png" alt=""></figure>
<p>这种写法参考了R的相关内容，具体是由 Python 中的 Patsy 库实现的。上面这个就是一个计量模型（他当然不是计算 <code>Literacy + np.log(Pop1831)</code>的和，<code>Literacy</code> 和 <code>np.log(Pop1831)</code> 都是矩阵）。这就和 Stata 中 <code>reg y x0 x1 x2</code> 是一样，只是在Python 中模型需要写成<code>y~x0+x1+x2</code>，而 reg 需要写成 <code>smf.ols()</code>。</p>
<p>这个模型中还用到了一个知识点：<code>np.log</code> ，就是说引用了 numpy 中的 log 函数，对变量<code>Pop1831</code> 取对数，就是使用 numpy 进行 log 运算。 如果你直接写 <code>log(Pop1831)</code>，Python是不知道 log 是做什么的，所以要告诉 Python，这个 log 来自于 numpy，这样 Python 就能正常处理 <code>Pop1831</code> 这个数据切片（“切片” 是Python数据处理中常用名词，可以理解为一个 DataFrame 的一列、一行或者几列、几行的数据）了。</p>
<p>最后 <code>data=dat</code> 就是声明对于这个模型，使用的数据时 <code>dat</code>， 这样前面的模型中的 <code>Lottery</code> 、<code>Literacy</code> 和 <code>Pop1831</code>，statsmodels 都能智能的去从 DataFrame 切片（切片操作需要学习Pandas哦），然后应用到模型中。</p>
<p>括号内的内容就是进行回归操作的核心。</p>
<p>括号外还有<code>.fit()</code>，就是告诉 Python，可以进行回归计算了。如果没有这个<code>.fit()</code> ，Python 只会记录这个模型和相关的数据信息，而添加了<code>.fit()</code>，记录时回归后的结果。<br>
<img src="DraggedImage-3.png" alt=""><br>
（上图可以看到储存在计算机中的内容是有差异的）</p>
<p>同样，<code>.fit()</code> 后输出的结果也并非像 Stata 那样那样直接输出的事结果，而是将结果储存，可以进行多种方式的调用。</p>
<p>如果想输入结果，那么就使用 <code>results.summary()</code> ，将其打印出来，正如示例中展示的那样：</p>
<figure data-type="image" tabindex="2"><img src="DraggedImage-4.png" alt=""></figure>
<h2 id="ols-实例">OLS 实例</h2>
<p>这里简单演示一下 OLS 回归，数据处理这一部分内容，在 Python 中主要使用 numpy 和 pandas，这里就不演示，本文直接读取处理完的数据来演示 OLS 的内容：</p>
<p>本文的数据来自CFPS，主要研究的内容是子女认知能力和服务是否创业的关系，处理后的第一个回归模型的内容主要是，母亲的创业状态（<code>self_employed_m_16</code>），教育年限(<code>edu</code>)，是否参加课外补习(<code>extra_classes</code>)，家庭药品支出(<code>expend_medical</code>)、自评健康状况(<code>health</code>)、家庭氛围(<code>quarrel</code>)、与母亲同住时长(<code>livewith_m</code>)、与父亲同住时常(<code>livewith_f</code>)、log的家庭收入(<code>lg_fin</code>)、子女数量(<code>num_chd</code>)、母亲的受教育程度(<code>edu_m</code>)、父亲的受教育程度(<code>edu_f</code>)、户口(<code>hukou</code>)、东中西部虚拟变量（<code>east 、 west</code>），然后被解释变量就是认知能力(<code>y_rznl</code>)。</p>
<pre><code class="language-python">import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf

df = pd.read_csv(&quot;testing.csv&quot;)
OLS_1 = smf.ols(&quot;y_rznl~ self_employed_m_16 + edu + extra_classes + \
    expend_medical + health + quarrel + livewith_m + livewith_f + \
    lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot;, data=df).fit()
print(OLS_1.summary())
</code></pre>
<p>最后输出结果：<br>
<img src="%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-07%20%E4%B8%8B%E5%8D%883.04.11.png" alt=""></p>
<p>而stata输出的结果（置信区间是97.5%）：<br>
<img src="%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-07-07%20%E4%B8%8B%E5%8D%883.11.40.png" alt=""></p>
<p>可以看到，结果基本一致。</p>
<p>最后，在OLS这里案例中，可以看到 Python 输出结果基本与 Stata 相同，在代码的撰写上， Python 同样非常方便，并且由于 Python 是一门编程语言，在一些循环的撰写上非常有优势，例如我需要多次循环某几个变量，以及对应的被解释变量：</p>
<pre><code class="language-python">import numpy as np
import pandas as pd
import statsmodels.api as sm
import statsmodels.formula.api as smf

df = pd.read_csv(&quot;testing.csv&quot;)
y_list =[y1, y2, y3, y4] # 被解释变量的列表
x0_list = [x0_1, x0_2, x0_3, x0_4, x0_5] # 某一个解释变量的列表
model_list = []
for y in y_list:
	for x0 in x0_list:
		model = &quot;%s ~ %s + edu + extra_classes + \
    expend_medical + health + quarrel + livewith_m + livewith_f + \
    lg_fin + num_chd + edu_m + edu_f + hukou + east + west&quot; % (y, x0)
		OLS = smf.ols(model, data = df).fit()
		print(OLS.summary())
		
</code></pre>
<p>这样就能一次性依次输出，以下内容的回归结果：</p>
<ul>
<li>
<p><code>y1 = x0_1 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y1 = x0_2 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y1 = x0_3 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y1 = x0_5 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y2 = x0_1 + edu + extra_calsses +...</code></p>
</li>
<li>
<p><code>y2 = x0_2 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y2 = x0_5 + edu + extra_calsses +...</code><br>
…</p>
</li>
<li>
<p><code>y4 = x0_5 + edu + extra_calsses +...</code></p>
</li>
</ul>
<p>所以无论是数据处理还是计量回归中，都能给你极大的便利。</p>
<p>相比Stata，Python  是免费开源的，不需要额外的授权费用，并且如果志在机器学习，那么先从相对熟悉的计量入手或许是一个不错的选择。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何 在 Windows 的共享文件夹中创建文件图标]]></title>
        <id>https://hwang.top/post/ru-he-zai-windows-de-gong-xiang-wen-jian-jia-zhong-chuang-jian-wen-jian-tu-biao</id>
        <link href="https://hwang.top/post/ru-he-zai-windows-de-gong-xiang-wen-jian-jia-zhong-chuang-jian-wen-jian-tu-biao">
        </link>
        <updated>2019-07-11T02:06:24.000Z</updated>
        <summary type="html"><![CDATA[<p>Windows 系统中可以通过右键文件夹属性的方式创建文件夹图标。然而，在共享文件夹中并不能直接创建。</p>
<p>🎬 <a href="https://www.youtube.com/watch?v=oFHkWfXbxYo">Apply an Icon to a Folder on a NetWork Drive </a><br>
视频中演示了一种相对曲折的方法在共享文件夹中，创建带有图标的文件夹。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Windows 系统中可以通过右键文件夹属性的方式创建文件夹图标。然而，在共享文件夹中并不能直接创建。</p>
<p>🎬 <a href="https://www.youtube.com/watch?v=oFHkWfXbxYo">Apply an Icon to a Folder on a NetWork Drive </a><br>
视频中演示了一种相对曲折的方法在共享文件夹中，创建带有图标的文件夹。</p>
<!-- more -->
<p>究其原理，其实就是共享文件夹中系统没有创建 <code>desktop.ini</code> 文件的设置（可能是安全原因的考虑？）。</p>
<p>参考：<a href="https://superuser.com/questions/685732/set-custom-folder-icon-for-a-network-folder-in-windows-file-explorer">Set custom folder icon for a network folder in Windows file explorer</a></p>
<h2 id="做法">做法：</h2>
<p>这种方法的前提就是你有共享文件夹的写入权限，在windows 10 上已经不能正常使用了</p>
<ol>
<li>在本地创建一个有 icon 的文件夹；</li>
<li>移动该文件夹到 共享文件夹中；</li>
<li>在弹出窗口中 允许 <code>desktop.ini</code> 的相关选项；</li>
<li>刷新一下共享文件夹</li>
<li>OK</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL 的一些内容]]></title>
        <id>https://hwang.top/post/sql-de-yi-xie-nei-rong</id>
        <link href="https://hwang.top/post/sql-de-yi-xie-nei-rong">
        </link>
        <updated>2019-05-07T02:11:54.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="mysql-累计求和">MySQL 累计求和</h2>
<pre><code class="language-sql">SET @csum := 0;
SELECT ADCODE, NAME, (@csum := @csum + ADCODE) AS CUMSUM
FROM all_location_data LIMIT 20;
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h2 id="mysql-累计求和">MySQL 累计求和</h2>
<pre><code class="language-sql">SET @csum := 0;
SELECT ADCODE, NAME, (@csum := @csum + ADCODE) AS CUMSUM
FROM all_location_data LIMIT 20;
</code></pre>
<!-- more -->
<p>首先 是设置一个变量 @csum 为0<br>
接着 选择要显示的字段，设置一个公式<code>(@csum := @csum + ADCODE)</code> 这里 ADCODE 就是想要 累积加总的变量，将其记为 CUMSUM。<br>
最后加上 <code>FROM all_location_data LIMIT 20;</code> 限制了现实20条。</p>
<hr>
<h2 id="mysql-统计某个-字段-不重复的行数">MySQL 统计某个 字段 不重复的行数</h2>
<pre><code class="language-sql">SELECT count(DISTINCT name) AS nu FROM company;
</code></pre>
]]></content>
    </entry>
</feed>