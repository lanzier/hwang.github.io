<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hwang.top</id>
    <title>Hwang&apos;s Blog</title>
    <updated>2020-02-26T07:30:35.428Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hwang.top"/>
    <link rel="self" href="https://hwang.top/atom.xml"/>
    <subtitle>&lt;div&gt;
欢迎来到 Hwang 的小博客 
&lt;div style=&quot;font-size:10px&quot;&gt;
📚 博客通过 Gridea 搭建，感谢 Gridea 的免费服务；蹭在 Github，感谢 Github.com 提供的服务器资源  &lt;br&gt;
✏️ 文章由 Hwang，在 Ulysses 上完成写作/亦或者拷贝&lt;br&gt;
👨‍🎨 封面由 Hwang，在 Figma 上完成创作 &lt;br&gt;
这里显然不是什么技术博客，也不会有太多值得期待的干货。
&lt;/div&gt;
&lt;/div&gt;</subtitle>
    <logo>https://hwang.top/images/avatar.png</logo>
    <icon>https://hwang.top/favicon.ico</icon>
    <rights>All rights reserved 2020, Hwang&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Oracle 的 循环实例]]></title>
        <id>https://hwang.top/post/oracle-de-xun-huan-shi-li/</id>
        <link href="https://hwang.top/post/oracle-de-xun-huan-shi-li/">
        </link>
        <updated>2020-02-26T07:15:53.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>好久没有整 Oracle 了，最近因为数据库服务器需要腾挪空间，所以这个本来DBA干的事情，又落到了我这个万金油的头上🤦‍♂️。<br>
折腾了几天，终算是有些明白了... 各种工具链也相对有些熟悉了，还算顺利的把备份做了，用户表删了。数据泵导出、表空间压缩、表空间扩容，都做了一遍，算是有点基础的 DBA 能力了🤦‍♂️...<br>
本文是写给同事看的 Oracle 循环；</p>
</blockquote>
<p>在开始学习循环之前，有以下几个概念，可以先了解：</p>
<h2 id="1-字符串拼接">1. 字符串拼接</h2>
<p>我们使用循环，是为了节省我们的代码数量，提高编写SQL的效率，所以首先我们就需要把 SQL 语句作为字符串进行拼接处理。在oracle中，用<code>'字符串'</code>，来表示这是一个字符串，而 拼接字符串：</p>
<pre><code class="language-sql">'select column '||变量a||' from table;'
</code></pre>
<p>通过<code>||</code>（英文输入下，按住shift + 回车键上面那个键打出）来连接变量与字符串，如果变量的值是 <code>column2</code> 那么这个字符串就会是：</p>
<pre><code class="language-sql">'select column colmn2 from table;'
</code></pre>
<p>所以我只需要将一列数据传入，这个字符串就会动态的变化：</p>
<pre><code class="language-sql">'select column colmn3 from table;'
'select column colmn4 from table;'
'select column colmn5 from table;'
</code></pre>
<ul>
<li>注意事项1 ⚠️: 在<code>'</code> 和 <code>||</code> 之间要注意空格的使用，字符串中的空格是有效的，字符串外的空格可能是无效的；</li>
<li>注意事项2 ⚠️：在字符串内如果想要使用<code>'</code>，那么是通过<code>''</code> 两个单引号表示；</li>
</ul>
<h2 id="2显示自己循环的代码以及-执行字符串内的sql代码">2.显示自己循环的代码以及 执行字符串内的sql代码</h2>
<h3 id="21-显示循环的效果">2.1 显示循环的效果：</h3>
<p>Oracle 中可以使用 <code>sys.dbms_output.put_line()</code> （括内填入需要显示的内容）的方式来查看代码，<strong>这样方便在编写循环时，更加具体的查看到自己的循环结构。</strong></p>
<p>在Navicat 中，可以通过 「DBMS 导出」标签看到输出的内容。</p>
<h3 id="22-执行这个字符串">2.2 执行这个字符串</h3>
<p>通过<code>EXECUTE IMMEDIATE</code>执行语句</p>
<ul>
<li>注意事项3⚠️： 是没有<code>()</code> 的哦。</li>
</ul>
<p>具体的关于 <code>EXECUTE IMMEDIATE</code>的用法参考：</p>
<ul>
<li><a href="https://blog.csdn.net/wang_zhong_cheng/article/details/81202086?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">EXECUTE IMMEDIATE用法小结</a></li>
</ul>
<h2 id="3-具体的-for-循环语句">3. 具体的 for 循环语句</h2>
<p>基本的结构：</p>
<pre><code class="language-sql">BEGIN
	for i in 1 .. 10 
	loop
		sys.dbms_output_line('循环到数字' || i)
	end loop;
END
</code></pre>
<p><code>BEGIN ... END</code> : 包裹住这么个 SQL 语句块，说明这段代码按照块来执行；<br>
<code>for i in 1 .. 10 loop ... end loop</code>: <code>foor</code> 到第一个 <code>loop</code> ,  表示 <code>i</code> 是1开始，一直取到10（<code>..</code> 表示范围），这个区间是闭合的，1和10都能取到，所以这个 i 会以次变成 1、2、3、4、5… 带入到下面的代码中； <code>loop</code> 到 <code>end loop</code> 表示具体的对循环执行的代码；</p>
<h3 id="实例循环添加数字-依次添加column_201到column_-304的的变量">实例：循环添加数字 —— 依次添加column_201到column_ 304的的变量</h3>
<pre><code class="language-sql">BEGIN
	for i in 201 .. 304 
	loop
		execute immediate 'select column_|| i || 'form table'
	end loop;
END
</code></pre>
<p>这样就可以动态的选取了选区了，不过这个语句会有 100 多个结果，实际中肯定不会这种使用：<br>
下例，为表空间添加237-274的<code>dbf</code>文件：<br>
<img src="DraggedImage-1.png" alt="" loading="lazy"></p>
<h3 id="实例循环某个查询到临时表其中的一列">实例：循环某个查询到临时表其中的一列</h3>
<p>这应该是更加实用的：</p>
<pre><code class="language-sql">BEGIN
	for v_cur in (select t.user_name from user_table_qy t where group_id ='qy') 
	loop
		execute immediate 'drop table' ||v_cur.user_name|| ' purge';
	end loop;
END
</code></pre>
<p>首先：<code>for v_cur in (select t.user_name from user_table_qy t where group_id ='qy') loop</code> 表示，<code>v_cur</code> 是后面这个语句的结果，虽然只有一个变量，但它还是一张表，所以在执行语句时 <code>v_cur.user_name</code> 就表示 <code>user_name</code> 这一列，所以会依次去执行<code>drop table</code> 操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Nest.js —— 学习笔记]]></title>
        <id>https://hwang.top/post/try-nestjs-xue-xi-bi-ji/</id>
        <link href="https://hwang.top/post/try-nestjs-xue-xi-bi-ji/">
        </link>
        <updated>2020-02-18T11:11:49.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>用到啥学啥系列<br>
其实也是为了另一个小项目写一个小后端。<br>
推荐参考 -&gt; 去这看吧，非常清楚： <a href="https://tc9011.com/2019/07/14/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/">https://tc9011.com/2019/07/14/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</a></p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>用到啥学啥系列<br>
其实也是为了另一个小项目写一个小后端。<br>
推荐参考 -&gt; 去这看吧，非常清楚： <a href="https://tc9011.com/2019/07/14/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/">https://tc9011.com/2019/07/14/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</a></p>
</blockquote>
<!-- more -->
<h2 id="1-什么是-nestjs">1. 什么是 Nest.js</h2>
<blockquote>
<p>Nestjs 是 Node 渐进式框架，底层默认使用 express（可以通过 Adapter 转换到 fastify），可以使用 express 或者 fastify 所有中间件，完美支持 TypeScript。熟悉 Spring 和 Angular 的同学可以很快上手 Nestjs，它大量借鉴了 Spring 和 Angular 中的设计思想</p>
</blockquote>
<h2 id="2-核心理念">2. 核心理念</h2>
<ul>
<li>
<p>Dependency Injection (DI)，一般翻译为 依赖注入；</p>
</li>
<li>
<p>Inversion of Control （loC），控制反转：主要用降低代码耦合度；相当于是用一个中转的函数来抽象原来类里面需要的变量，这样就实现了耦合度的降低。</p>
<ul>
<li>在 nest.js中，通过 <code>@Injectable()</code> 装饰器来像 loC 容易注册。</li>
</ul>
</li>
<li>
<p>模块化：Module 把controller、service和pipe等打包成内聚的功能块，每个模块聚焦于一个特性区域、业务领域、工作流或通用工具。</p>
<ul>
<li>每个属于这个模块的controller、service等都需要在这个模块中注册，如果需要引入其他模块或者第三方模块，需要将它注册到imports，通过exports可以将相应的service、module等共享出去。</li>
<li>在 nest.js中，通过 <code>@Module()</code> 装饰器来像声明一个模块；</li>
</ul>
</li>
<li>
<p>AOP, 面向切片编程（Aspect Oriented Programming），主要有这么几个切片：</p>
<ul>
<li>Middlewares：中间键</li>
<li>Guards：Guards 和前端路由中的路由守卫一样，主要确定请求是否应该由路由处理程序处理。通过守卫可以知道将要执行的上下文信息，所以和 middleware 相比，守卫可以确切知道将要执行什么。</li>
<li>Interceptors (在流被操纵之前)：可以给每一个需要执行的函数绑定，拦截器将在该函数执行前或者执行后运行。可以转换函数执行后返回的结果，扩展基本函数行为等。</li>
<li>Pipes：是具有 @Injectable() 装饰器的类，并实现了 PipeTransform 接口。通常 pipe 用来将输入数据转换为所需的输出或者处理验证。
<ul>
<li>参数验证等内容</li>
</ul>
</li>
<li>Interceptors (在流被操纵之后)</li>
<li>Exception filters (如果发现任何异常)：内置的 Exception filters 负责处理整个应用程序中的所有抛出的异常，也是 Nestjs 中在 response 前，最后能捕获异常的机会。</li>
</ul>
</li>
<li>
<p>DTO：数据访问对象简称DTO（Data Transfer Object）， 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。</p>
</li>
<li>
<p>ORM ：是”对象-关系映射”（Object/Relational Mapping） 的缩写，通过实例对象的语法，完成关系型数据库的操作。通过 ORM 就可以用面向对象编程的方式去操作关系型数据库。</p>
<ul>
<li>在 Java 中，常用 DAO （Data Access Object， 数据访问对象）层来进行各种数据库的操作。DAO 主要作用是分离业务层与数据层，避免业务层与数据层耦合。</li>
<li>Nest.js 中可以使用 typeORM 为 DAO 层，支持MySQL / MariaDB / Postgres / CockroachDB / SQLite / Microsoft SQL Server / Oracle / MongoDB / NoSQL。在 typeORM 中数据库的表对应的就是一个类，通过定义一个类来创建实体。实体（Entity）是一个映射到数据库表（或使用 MongoDB 时的集合）的类，通过@Entity()来标记，具体的：</li>
</ul>
<pre><code class="language-js">import {Entity, PrimaryGeneratedColumn, Column} from &quot;typeorm&quot;;

@Entity()
export class User {

    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    firstName: string;

    @Column()
    lastName: string;

    @Column()
    age: number;

}
//上面代码将创建以下数据库表：

//+-------------+--------------+----------------------------+
//|                          user                           |
//+-------------+--------------+----------------------------+
//| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
//| firstName   | varchar(255) |                            |
//| lastName    | varchar(255) |                            |
//| isActive    | boolean      |                            |
//+-------------+--------------+----------------------------+
//	使用 @InjectRepository() 修饰器注入 对应的Repository，就可以在这个Repository对象上进行数据库的一些操作。

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './user.entity';

@Injectable()
export class UserService {
  constructor(
	@InjectRepository(User)
	private readonly userRepository: Repository&lt;User&gt;,
  ) {}

  async findAll(): Promise&lt;User[]&gt; {
	return await this.userRepository.find();
  }
}
</code></pre>
</li>
</ul>
<h2 id="3-上手-hello-world">3. 上手 hello world ！</h2>
<p>安装：</p>
<pre><code class="language-js">$ npm install -g @nestjs/cli
$ nest new my-awesome-app 
</code></pre>
<p>启动</p>
<pre><code class="language-js">$ npm start
</code></pre>
<p>自此，通过<code>http://loaclhost:3000</code> 就可以看到 Hello World 了。</p>
<h2 id="4-controller">4. Controller</h2>
<p>在 Nest.js 中 Contraller 负责处理传入的请求，并调用对应的 service 完成处理，返回对客户端的响应，可以通过 CLI 来创建 controller：</p>
<pre><code>$nest g co [your-cintroller]
</code></pre>
<p>这时候，CLI 会自动生成 controller 文件，并且把 controller 注册到对应的 module 中。<br>
并且和其他一些 node 框架不一样，Nestjs 路由不是集中式管理，而是分散在 controller 中，通过@controller()中声明的（可选）前缀和请求装饰器中指定的任何路由来确定的。</p>
<pre><code class="language-js">import { Controller, Get } from '@nestjs/common';

import { CatsService } from './cats.service';

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {
  }

  @Get(':id')
  findOne(@Param('id') id: string): string {
    return this.catsService.getCat();
  }
}
</code></pre>
<p>上面这段代码中，通过 Get 请求去请求http://localhost:3000/cats/1就会调用findOne方法。如果需要调整，添加前缀，可以在 main.ts 中使用 GlobalPrefix 设置：</p>
<pre><code class="language-js">import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.setGlobalPrefix('api/v1');
  await app.listen(3000);
}
bootstrap();
</code></pre>
<h2 id="5-service">5. Service</h2>
<p>在 Nest.js 中，controller 就像是调用 service 的指挥者，把对应的请求分发到相应的 service 中去处理。在 controller 中，我们注意到，在构造函数中注入了<strong>CatsService</strong>实例，来调用对应 service 中的方法。这就是 Nest.js 中依赖注入的注入方式 — 构造函数注入。service 可以看做夹在 controller 和 model 之间的一层，在 service 调用 DAO （在 Nestjs 中是各种 ORM 工具或者自己封装的 DAO 层）实现数据库的访问，进行数据的处理整合。</p>
<pre><code>import { Injectable } from '@nestjs/common';

@Injectable()
export class CatsService {
  getCat(id: string): string {
    return `This action returns ${id} cats`;
  }
}
</code></pre>
<p>上面代码中通过@Injectable()定义了一个 service，这样你就可以在其他 controller 或者 service 中注入这个 service。</p>
<hr>
<p>参考：<a href="https://tc9011.com/2019/07/22/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">https://tc9011.com/2019/07/22/nestjs%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Electron记实（八）— 组件传参\ Electron Node 模块支持问题 \文件路径问题 ]]></title>
        <id>https://hwang.top/post/try-electron-ji-shi-ba-zu-jian-chuan-can-electron-node-mo-kuai-zhi-chi-wen-ti-wen-jian-lu-jing-wen-ti/</id>
        <link href="https://hwang.top/post/try-electron-ji-shi-ba-zu-jian-chuan-can-electron-node-mo-kuai-zhi-chi-wen-ti-wen-jian-lu-jing-wen-ti/">
        </link>
        <updated>2020-02-17T13:11:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>是的，用的啥学啥系列。</p>
</blockquote>
<h2 id="传参这是基础了复习复习">传参，这是基础了，复习复习</h2>
<ul>
<li>父组件和子组件可以通过 props 获取，父组件发送的形式是用bind(用缩写:)绑定值到子组件身上。然后子组件用属性props接收。</li>
<li>子组件传值父组件，首先是子组件发送 this.$emit，父组件on监听的方法，然后父组件通过@事件名=获取值的方法。</li>
<li>兄弟组件一般通过 bus 进行传递，就是建立一个公共区域的组件。</li>
</ul>
<h2 id="使用-electron-rebuild-来重新编译-node-模块">使用 electron-rebuild 来重新编译 Node 模块</h2>
<p>官方文档：<a href="https://www.electronjs.org/docs/tutorial/using-native-node-modules">https://www.electronjs.org/docs/tutorial/using-native-node-modules</a></p>
<pre><code class="language-js">// 安装electron-rebuild，不需要全局安装
npm install --save-dev electron-rebuild

//执行命令
./node_modules/.bin/electron-rebuild

// 在windows下如果上述命令遇到了问题，尝试：
./node_modules/.bin/electron-rebuild.cmd

</code></pre>
<h2 id="用-node-的path读到的文件路径在electron-原来是不一样的">用 node 的path，读到的文件路径在electron 原来是不一样的...</h2>
<p>今天在渲染进程中使用 <code>fs.readSync()</code> ，显然是不正确的。渲染进程的前端开发，项目文件会被webpack打包，自然不能这样用。</p>
<h3 id="静态资源的引入">静态资源的引入：</h3>
<blockquote>
<p>1.静态资源如css,img，js,请放在根目录的static文件夹里，<br>
因为electron打包后会复制一份static文件夹到dist文件夹中，这样项目引入的静态资源就不会报路径错误了。</p>
</blockquote>
<h2 id="electron-获取打包后-可执行文件-的文件路径">electron 获取打包后 可执行文件 的文件路径</h2>
<p>参考链接：<a href="https://stackoverflow.com/questions/46307797/how-to-get-the-original-path-of-a-portable-electron-app">https://stackoverflow.com/questions/46307797/how-to-get-the-original-path-of-a-portable-electron-app</a></p>
<ol>
<li><code>app.getAppPath()</code> 获取文件的路径，例如 <code>c:\desktop\win-ia32-unpacked\resources\app.asar</code></li>
<li>Node.js 的<code>__dirname</code>，获取的路径： <code>c:\desktop\win-ia32-unpacked\resources\app.asar\dist\electron</code></li>
<li><code>process.execPath</code> ，获取的路径<code>c:\desktop\win-ia32-unpacked\xxx.exe</code></li>
<li><code>process.cwd()</code> ， 获取的路径<code>c:\desktop\win-ia32-unpacked</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Electron记实（七）— 先学习 Vue.js 实现拖拽再应用到 electron 中]]></title>
        <id>https://hwang.top/post/try-electron-ji-shi-qi-xian-xue-xi-vuejs-shi-xian-tuo-zhuai-zai-ying-yong-dao-electron-zhong/</id>
        <link href="https://hwang.top/post/try-electron-ji-shi-qi-xian-xue-xi-vuejs-shi-xian-tuo-zhuai-zai-ying-yong-dao-electron-zhong/">
        </link>
        <updated>2020-02-17T05:31:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>是的，用的啥学啥系列。<br>
参考：<a href="https://www.jianshu.com/p/873512cdbd0f">https://www.jianshu.com/p/873512cdbd0f</a></p>
</blockquote>
<p>首先，ant-design 是提供了 <code>a-upload</code> 组件，用于上传的，但是不幸的是，前端一般是拿不到真实的本机路径的。所以简单考虑后，决定直接写一个通过 Electron API 的方法的上传框。</p>
<h2 id="vuejs-里面怎么做">Vue.js 里面怎么做</h2>
<h3 id="1-涉及的时间-dragenter-dragover-drop-事件">1. 涉及的时间 dragenter、dragover、drop 事件</h3>
<blockquote>
<p>当把文件拖动到浏览器的拖动区域时，会触发三种事件：<br>
文件第一次进入拖动区时，触发 dragenter 事件<br>
文件在拖动区来回拖拽时，不断触发 dragover 事件<br>
文件已经在拖动区，并松开鼠标时，触发 drop 事件<br>
实现拖动上传，我们只需要关心 drop 事件。不过另外两个事件也需要监听，目的是阻止浏览器默认行为。如果不阻止，那么把文件拖到浏览器时，浏览器就会自动下载这个文件（默认行为），drop 事件触发不出来。<br>
所以要做的就是阻止默认的事件。需要再 mounted 挂载后处理。（有点不懂，mounted 不是加载完了吗？ Vue 不推荐直接操作 DOM 元素，是不是可以直接用 v-on 绑定到 methods 里面。）</p>
</blockquote>
<p>接着就是再 methods 对象中写函数。具体参见文章，写的比较清楚，包括进度条如何实现都有的。</p>
<h3 id="2-具体到-electron-中">2. 具体到 Electron 中</h3>
<p>在electron 中：</p>
<blockquote>
<p>为了让用户能够通过HTML5的file API直接操作本地文件，DOM的File接口提供了对本地文件的抽象。Electron在File接口中增加了一个path属性，它是文件在系统中的真实路径。</p>
</blockquote>
<p>而这个 path 属性就是我需要的。<br>
其中，methods：</p>
<pre><code class="language-js">  methods: {
    onDrag: function(e) {
      e.stopPropagation();
      e.preventDefault();
    },
    onDrop: function(e) {
      e.stopPropagation();
      e.preventDefault();
      let file = e.dataTransfer.files[0];
      console.log('path-&gt;', file.path);

    }
  }
</code></pre>
<p>这里，使用   e.stopPropagation()、e.preventDefault()来阻止默认的行为。<br>
我也直接在<code>&lt;div&gt;</code> 标签上使用 v-on 进行绑定，并没有什么问题。</p>
<h3 id="3-利用-ipcrenderer-模块打开文件选择框">3. 利用 ipcRenderer  模块，打开文件选择框</h3>
<p>我选择的方式是使用 remote 模块直接打开文件夹，代码片段如下：</p>
<pre><code class="language-js">const dialog = require('electron').remote.dialog;
dialog.showOpenDialog({ properties: ['openFile']}).then((file) =&gt;{
	if (file.filePaths.length === 1) {
		this.fileSelected = file.filePaths[0];
		console.log(this.fileSelected);
	} 
})
</code></pre>
<p>使用 <code>remote.dialog</code>，调用主进程内的 electron 模块，获取文件路径即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Electron记实（六）— Vue 的 Mixins 混入  / 小知识补习：` import ` 与 `import {}`]]></title>
        <id>https://hwang.top/post/try-electron-ji-shi-liu-vue-de-mixins-hun-ru-xiao-zhi-shi-bu-xi-import-yu-import/</id>
        <link href="https://hwang.top/post/try-electron-ji-shi-liu-vue-de-mixins-hun-ru-xiao-zhi-shi-bu-xi-import-yu-import/">
        </link>
        <updated>2020-02-17T05:29:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="mixins-混用">Mixins 混用</h2>
<p>**用途：**用于Vue组件中，可复用的功能；一个 Mixins 对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混入”该组件中。</p>
<p><strong>理解：</strong> 利用 Vue 的方式实现组件的功能的自由服用与组合。</p>
<p>官方示例，一看就懂：</p>
<pre><code class="language-js">// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}

// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin]
})

var component = new Component() // =&gt; &quot;hello from mixin!&quot;
</code></pre>
<p>**一些特性： **</p>
<ul>
<li>同名的情况：
<ul>
<li>同名的钩子函数将被合并为一个数组，因此会被一起调用。Mixins 的钩子将先被执行；</li>
<li>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。<br>
更多信息：<a href="https://cn.vuejs.org/v2/guide/mixins.html">https://cn.vuejs.org/v2/guide/mixins.html</a></li>
</ul>
</li>
</ul>
<h2 id="小知识补习import-与-import">小知识补习：<code>import</code> 与 <code>import {}</code></h2>
<p>一般情况下，其实是需要 <code>import {} from xxx</code>，但是一般的模块都会设置：</p>
<blockquote>
<p>至于为什么能 <code>import lodash from 'lodash'</code><br>
是因为，为了给用户提供方便，<code>lodash</code> 用到<code>export default</code> 命令，为模块指定了默认输出，让<code>lodash</code> 的使用者不用阅读文档就能用任意自定义模块名加载 <code>lodash</code>。<br>
所以，<code>import lodash from 'lodash'</code> 这句，你喜欢的话也能写成<code>import _ from 'lodash'</code><br>
其次，<code>from` 后面的</code> 'lodash' 为什么不是 <code>node_modules</code>里 <code>lodash</code>的完整路径呢<code>（ / node_modules / .bin / lodash ）</code>，是因为你的项目里 npm 帮忙做了配置呀，自动帮它加了前缀，一般补全模块路径是这事是npm帮做的。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hwang Reading List - New 07]]></title>
        <id>https://hwang.top/post/hwang-reading-list-new-07/</id>
        <link href="https://hwang.top/post/hwang-reading-list-new-07/">
        </link>
        <updated>2020-02-11T09:33:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>注：链接是 <a href="ifttt.com">IFTTT</a> 生成的，可能需要科学的上网方式，才能够访问</p>
</blockquote>
<p><a href="https://ift.tt/2QCCQ3e">中国企业获设计“剽窃奖”被质疑</a></p>
<blockquote>
<p>近日，一则中国制造商包揽德国“金鼻子剽窃奖”前十名的消息引发关注。中国设计是否存在山寨外国设计再次引发热议。</p>
</blockquote>
<p><a href="https://ift.tt/2tm6vG7">为什么DevOps很好，但却很难落地，大家对DevOps是怎么理解的？</a></p>
<blockquote>
<p>关于 DevOps 为什么难落地，与其我们在这里闭门造车，倒不如看看来自专家的看法</p>
</blockquote>
<p><a href="https://ift.tt/3a4CZW0">为什么进度条永远卡在 99%？</a></p>
<blockquote>
<p>机密处万籁俱寂，防守严格，他一路破解密码，悄声潜入，没料到 U 盘一插电脑，警报就开始厉声鸣叫，门外死神般的脚步纷至沓来，踩得他浑身汗如雨下。</p>
</blockquote>
<p><a href="https://ift.tt/2Rop4Bl">阿里巴巴发布全新奥运组合LOGO！仅用9根线“托”起五环！</a></p>
<blockquote>
<p>微信号 AlibabaDesign 功能介绍 这是一个充满魅力的组织，是一群疯狂热爱用户体验的家伙；这里有国际音乐家、有舞者、游戏玩家、摄影师以及各个领域的爱好者；我们坚信，创新、设计、技术和客户第一的价值观粘合在一起，</p>
</blockquote>
<p><a href="https://ift.tt/2QWZzXW">2020，我想如何讲述自己的故事——2019总结</a></p>
<blockquote>
<p>12月的 Monthly Review 已经做了2019年终总结的播客有声版，加上2019半年总结也写了，总感觉下半年应该没什么值得记录。而且一直没有想清楚2020年的目标和展望，想通过整理成文字版的过程给自己一些灵感。</p>
</blockquote>
<p><a href="https://ift.tt/2NapoT0">2019，小程序又给了谁机会？</a></p>
<blockquote>
<p>以上是宏观的生态数据，透过这些数据，我们不免会有一个疑惑：是谁承担起了这些流量？</p>
</blockquote>
<p><a href="https://ift.tt/39k6GRO">iPhone 可有设计哲学？</a></p>
<blockquote>
<p>iPhone 4G 出来之前，注定会有更多强大，快速，激动人心的新设备来挑战智能手机的巅峰 : 3GS 。</p>
</blockquote>
<p><a href="https://ift.tt/2tpSyH7">2019 创业回顾</a></p>
<blockquote>
<p>2019 公司人数 +1 -1，最后是四个人。还是蛮多人知道会惊讶一下，你们只有四个人？两个运营，加一个全能工程师，加我（还有两只猫）。</p>
</blockquote>
<p><a href="https://diygod.me/2019/">2019 我做了什么</a></p>
<blockquote>
<p>虽然维护的项目有保持健康的成长，但没有做什么新东西 2020 打算投入更多的时间在开源项目上，不再怠惰于现有项目的日常维护，而是做一些新东西，（可能）有 DPlayer 重构、Telegram Bot 平台、RSS 客户端等</p>
</blockquote>
<p><a href="https://ift.tt/30fNiC1">刘慈欣：中国变成民主体制会是人间地狱</a></p>
<blockquote>
<p>断章取义通常有危险。但刘慈欣在接受《纽约客》采访时的这几段话已经刻板八股到了 caricature 的程度，断章与否其实没有任何区别了。采访是樊嘉扬做的，所以说的应该是普通话。</p>
</blockquote>
<p><a href="https://ift.tt/39jANbM">钉钉 Dark Mode 设计</a></p>
<blockquote>
<p>微信号 AlibabaDesign 功能介绍 这是一个充满魅力的组织，是一群疯狂热爱用户体验的家伙；这里有国际音乐家、有舞者、游戏玩家、摄影师以及各个领域的爱好者；我们坚信，创新、设计、技术和客户第一的价值观粘合在一起，</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Electron记实（五）— 异步的一些东西 ：Promise 对象]]></title>
        <id>https://hwang.top/post/try-electron-ji-shi-wu-yi-bu-de-yi-xie-dong-xi-promise-dui-xiang/</id>
        <link href="https://hwang.top/post/try-electron-ji-shi-wu-yi-bu-de-yi-xie-dong-xi-promise-dui-xiang/">
        </link>
        <updated>2020-02-11T09:29:46.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544">https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544</a></p>
</blockquote>
<p>先吐槽，从来没有接触过 Promise 对象相关的东西，只知道 JS 的世界里，异步是一个非常重要的概念。今天写逻辑代码，第一次接触到了，因为 function 异步执行，想当然的以为 return 的就是给赋值的结果，结果因为异步并没有拿到最后的结果。</p>
<p>首先，关于 Promise 和 async/await ：<a href="https://zhuanlan.zhihu.com/p/23249103">https://zhuanlan.zhihu.com/p/23249103</a>：</p>
<blockquote>
<p>可以很明显的看到，callback 来控制异步的方式虽然非常简单，但也过于原始。在实际的使用中代码的逻辑顺序和业务的顺序是不相同的，错误控制基本靠手动检查err参数。<br>
而到了 Promise 中这种情况好了很多，通过链式调用，Promise 可以直接在 then 中返回一个新的 Promise 来将异步操作串联起来，也有了统一的 catch 来做错误处理。美中不足的是，你仍然需要传递一个回调函数给 then，通过 then 来串联虽然保证了至少代码顺序上和真正的逻辑顺序一致，但和同步代码的差别仍然很大。<br>
async/await 则直接将其变成了同步的写法，心智负担大大降低。</p>
</blockquote>
<p>具体的：</p>
<blockquote>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。<br>
resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>
Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
</blockquote>
<blockquote>
<p>then方法可以接受两个回调函数作为参数。<br>
第一个回调函数是Promise对象的状态变为resolved时调用，<br>
第二个回调函数是Promise对象的状态变为rejected时调用。<br>
其中，第二个函数是可选的，不一定要提供。<br>
这两个函数都接受Promise对象传出的值作为参数。</p>
</blockquote>
<p>用法：</p>
<pre><code class="language-js">const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});


promise.then(function(value) {
  // success
}, function(error) {
  // failure
});

</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Electron记实（四）— 项目中添加路由]]></title>
        <id>https://hwang.top/post/try-electron-ji-shi-si-xiang-mu-zhong-tian-jia-lu-you/</id>
        <link href="https://hwang.top/post/try-electron-ji-shi-si-xiang-mu-zhong-tian-jia-lu-you/">
        </link>
        <updated>2020-02-11T09:29:32.000Z</updated>
        <content type="html"><![CDATA[<p>通过路由的方式进行侧边导航栏的切换：</p>
<ol>
<li>安装 vue-router，并添加到项目中；</li>
<li>在 main.js 中引入 vue-router 插件；</li>
</ol>
<pre><code class="language-bash">...
... //省略其他
import Router from 'vue-router'

Vue.use(Router)

</code></pre>
<ol start="3">
<li>引入路由文件，并在 Vue 实例中添加配置</li>
</ol>
<pre><code>import router from '.'router/index'
...//省略其他
new Vue({
  router: router, //添加配置
  render: h =&gt; h(App),
}).$mount('#app')

</code></pre>
<ol start="4">
<li>
<p>编辑路由文件<code>router/index.js</code> 中添加需要的路由路径</p>
</li>
<li>
<p><code>&lt;router-link to=&quot;&quot;&gt;</code> 和 <code>&lt;router-view&gt;</code> 标签 一个是用来跳转的，一个是用来显示调整页面的。</p>
</li>
</ol>
<p>Done！ 基础的路由添加步骤就是这样了。在其他具体的事情，具体在看吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Electron记实（三）— ant-design-vue 主题的修改]]></title>
        <id>https://hwang.top/post/try-electron-ji-shi-san-ant-design-vue-zhu-ti-de-xiu-gai/</id>
        <link href="https://hwang.top/post/try-electron-ji-shi-san-ant-design-vue-zhu-ti-de-xiu-gai/">
        </link>
        <updated>2020-02-10T08:07:32.000Z</updated>
        <content type="html"><![CDATA[<p>官方文档描述：</p>
<blockquote>
<p>在 vue cli 3 中定制主题<br>
项目根目录下新建文件vue.config.js</p>
<pre><code>// vue.config.js
module.exports = {
  css: {
    loaderOptions: {
      less: {
        modifyVars: {
          'primary-color': '#1DA57A',
          'link-color': '#1DA57A',
          'border-radius-base': '2px',
        },
        javascriptEnabled: true
      }
    }
  }
}
</code></pre>
</blockquote>
<h3 id="关于-vueconfigjs">关于- vue.config.js :</h3>
<blockquote>
<p>每次在终端运行 vue-cli-service 时，都会先找到对应的 vue.config.js，获取到相关配置，才继续执行其它操作</p>
</blockquote>
<h3 id="动手试试">动手试试</h3>
<p>直接在项目跟目录添加这么一个配置文件即可。<br>
因为 vue.config.js 是在 vue-cli-service 运行时检查的，所以在使用 electron-builder 构建的项目中，并不能热更新。<br>
我的理解是，这个 vue-cli-service 启动后，才可以热更新 electron 的窗体程序和Vue写的前端页面的，热更新并不会重新启动一遍 vue-cli-service。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Try Electron记实（二）— ant-design 的引入、font-awesome 的引入]]></title>
        <id>https://hwang.top/post/try-electron-ji-shi-er-ant-design-de-yin-ru-font-awesome-de-yin-ru/</id>
        <link href="https://hwang.top/post/try-electron-ji-shi-er-ant-design-de-yin-ru-font-awesome-de-yin-ru/">
        </link>
        <updated>2020-02-07T10:47:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>简单记录一下；<br>
有一点点的坑是引入 less 的事情，其他都挺顺利的；</p>
</blockquote>
<p>ant-design 和 font-awesome 的引入</p>
<ol>
<li>引入，在 <code>src/main.js</code> 文件内引入：</li>
</ol>
<pre><code class="language-bash">import Vue from 'vue';
import App from './App.vue';
import Antd from 'ant-design-vue';
import 'ant-design-vue/dist/antd.less';
import { library } from '@fortawesome/fontawesome-svg-core'
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome'
import {
	【需要的包】
} from '@fortawesome/free-solid-svg-icons'

library.add(
	【需要的包】
)
 
Vue.component('font-awesome-icon', FontAwesomeIcon)

Vue.config.productionTip = false;
Vue.use(Antd);


new Vue({
  render: h =&gt; h(App),
}).$mount('#app')

</code></pre>
<ol start="2">
<li>其中，如果需要配置 ant 的主题</li>
</ol>
<pre><code class="language-bash">	import 'ant-design-vue/dist/antd.less';
	```
	使用 less 配置主题。</code></pre>
]]></content>
    </entry>
</feed>